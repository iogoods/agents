{"version":3,"sources":["../src/index.ts","../src/telegramClient.ts","../src/messageManager.ts","../src/templates.ts","../src/utils.ts","../src/constants.ts","../src/getOrCreateRecommenderInBe.ts","../src/environment.ts"],"sourcesContent":["import { elizaLogger } from \"@elizaos/core\";\r\nimport type { Client, IAgentRuntime } from \"@elizaos/core\";\r\nimport { TelegramClient } from \"./telegramClient.ts\";\r\nimport { validateTelegramConfig } from \"./environment.ts\";\r\n\r\nexport const TelegramClientInterface: Client = {\r\n    start: async (runtime: IAgentRuntime) => {\r\n        await validateTelegramConfig(runtime);\r\n\r\n        const tg = new TelegramClient(\r\n            runtime,\r\n            runtime.getSetting(\"TELEGRAM_BOT_TOKEN\")\r\n        );\r\n\r\n        await tg.start();\r\n\r\n        elizaLogger.success(\r\n            `‚úÖ Telegram client successfully started for character ${runtime.character.name}`\r\n        );\r\n        return tg;\r\n    },\r\n    stop: async (_runtime: IAgentRuntime) => {\r\n        elizaLogger.warn(\"Telegram client does not support stopping yet\");\r\n    },\r\n};\r\n\r\nexport default TelegramClientInterface;\r\n","import { type Context, Telegraf } from \"telegraf\";\r\nimport { message } from \"telegraf/filters\";\r\nimport { type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\r\nimport { MessageManager } from \"./messageManager.ts\";\r\nimport { getOrCreateRecommenderInBe } from \"./getOrCreateRecommenderInBe.ts\";\r\n\r\nexport class TelegramClient {\r\n    private bot: Telegraf<Context>;\r\n    private runtime: IAgentRuntime;\r\n    private messageManager: MessageManager;\r\n    private backend;\r\n    private backendToken;\r\n    private tgTrader;\r\n    private options;\r\n\r\n    constructor(runtime: IAgentRuntime, botToken: string) {\r\n        elizaLogger.log(\"üì± Constructing new TelegramClient...\");\r\n        this.options = {\r\n            telegram: {\r\n                apiRoot: runtime.getSetting(\"TELEGRAM_API_ROOT\") || process.env.TELEGRAM_API_ROOT || \"https://api.telegram.org\"\r\n            },\r\n        };\r\n        this.runtime = runtime;\r\n        this.bot = new Telegraf(botToken,this.options);\r\n        this.messageManager = new MessageManager(this.bot, this.runtime);\r\n        this.backend = runtime.getSetting(\"BACKEND_URL\");\r\n        this.backendToken = runtime.getSetting(\"BACKEND_TOKEN\");\r\n        this.tgTrader = runtime.getSetting(\"TG_TRADER\"); // boolean To Be added to the settings\r\n        elizaLogger.log(\"‚úÖ TelegramClient constructor completed\");\r\n    }\r\n\r\n    public async start(): Promise<void> {\r\n        elizaLogger.log(\"üöÄ Starting Telegram bot...\");\r\n        try {\r\n            await this.initializeBot();\r\n            this.setupMessageHandlers();\r\n            this.setupShutdownHandlers();\r\n        } catch (error) {\r\n            elizaLogger.error(\"‚ùå Failed to launch Telegram bot:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async initializeBot(): Promise<void> {\r\n        this.bot.launch({ dropPendingUpdates: true });\r\n        elizaLogger.log(\r\n            \"‚ú® Telegram bot successfully launched and is running!\"\r\n        );\r\n\r\n        const botInfo = await this.bot.telegram.getMe();\r\n        this.bot.botInfo = botInfo;\r\n        elizaLogger.success(`Bot username: @${botInfo.username}`);\r\n\r\n        this.messageManager.bot = this.bot;\r\n    }\r\n\r\n    private async isGroupAuthorized(ctx: Context): Promise<boolean> {\r\n        const config = this.runtime.character.clientConfig?.telegram;\r\n        if (ctx.from?.id === ctx.botInfo?.id) {\r\n            return false;\r\n        }\r\n\r\n        if (!config?.shouldOnlyJoinInAllowedGroups) {\r\n            return true;\r\n        }\r\n\r\n        const allowedGroups = config.allowedGroupIds || [];\r\n        const currentGroupId = ctx.chat.id.toString();\r\n\r\n        if (!allowedGroups.includes(currentGroupId)) {\r\n            elizaLogger.info(`Unauthorized group detected: ${currentGroupId}`);\r\n            try {\r\n                await ctx.reply(\"Not authorized. Leaving.\");\r\n                await ctx.leaveChat();\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    `Error leaving unauthorized group ${currentGroupId}:`,\r\n                    error\r\n                );\r\n            }\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private setupMessageHandlers(): void {\r\n        elizaLogger.log(\"Setting up message handler...\");\r\n\r\n        this.bot.on(message(\"new_chat_members\"), async (ctx) => {\r\n            try {\r\n                const newMembers = ctx.message.new_chat_members;\r\n                const isBotAdded = newMembers.some(\r\n                    (member) => member.id === ctx.botInfo.id\r\n                );\r\n\r\n                if (isBotAdded && !(await this.isGroupAuthorized(ctx))) {\r\n                    return;\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error handling new chat members:\", error);\r\n            }\r\n        });\r\n\r\n        this.bot.on(\"message\", async (ctx) => {\r\n            try {\r\n                // Check group authorization first\r\n                if (!(await this.isGroupAuthorized(ctx))) {\r\n                    return;\r\n                }\r\n\r\n                if (this.tgTrader) {\r\n                    const userId = ctx.from?.id.toString();\r\n                    const username =\r\n                        ctx.from?.username || ctx.from?.first_name || \"Unknown\";\r\n                    if (!userId) {\r\n                        elizaLogger.warn(\r\n                            \"Received message from a user without an ID.\"\r\n                        );\r\n                        return;\r\n                    }\r\n                    try {\r\n                        await getOrCreateRecommenderInBe(\r\n                            userId,\r\n                            username,\r\n                            this.backendToken,\r\n                            this.backend\r\n                        );\r\n                    } catch (error) {\r\n                        elizaLogger.error(\r\n                            \"Error getting or creating recommender in backend\",\r\n                            error\r\n                        );\r\n                    }\r\n                }\r\n\r\n                await this.messageManager.handleMessage(ctx);\r\n            } catch (error) {\r\n                elizaLogger.error(\"‚ùå Error handling message:\", error);\r\n                // Don't try to reply if we've left the group or been kicked\r\n                if (error?.response?.error_code !== 403) {\r\n                    try {\r\n                        await ctx.reply(\r\n                            \"An error occurred while processing your message.\"\r\n                        );\r\n                    } catch (replyError) {\r\n                        elizaLogger.error(\r\n                            \"Failed to send error message:\",\r\n                            replyError\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        this.bot.on(\"photo\", (ctx) => {\r\n            elizaLogger.log(\r\n                \"üì∏ Received photo message with caption:\",\r\n                ctx.message.caption\r\n            );\r\n        });\r\n\r\n        this.bot.on(\"document\", (ctx) => {\r\n            elizaLogger.log(\r\n                \"üìé Received document message:\",\r\n                ctx.message.document.file_name\r\n            );\r\n        });\r\n\r\n        this.bot.catch((err, ctx) => {\r\n            elizaLogger.error(`‚ùå Telegram Error for ${ctx.updateType}:`, err);\r\n            ctx.reply(\"An unexpected error occurred. Please try again later.\");\r\n        });\r\n    }\r\n\r\n    private setupShutdownHandlers(): void {\r\n        const shutdownHandler = async (signal: string) => {\r\n            elizaLogger.log(\r\n                `‚ö†Ô∏è Received ${signal}. Shutting down Telegram bot gracefully...`\r\n            );\r\n            try {\r\n                await this.stop();\r\n                elizaLogger.log(\"üõë Telegram bot stopped gracefully\");\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    \"‚ùå Error during Telegram bot shutdown:\",\r\n                    error\r\n                );\r\n                throw error;\r\n            }\r\n        };\r\n\r\n        process.once(\"SIGINT\", () => shutdownHandler(\"SIGINT\"));\r\n        process.once(\"SIGTERM\", () => shutdownHandler(\"SIGTERM\"));\r\n        process.once(\"SIGHUP\", () => shutdownHandler(\"SIGHUP\"));\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        elizaLogger.log(\"Stopping Telegram bot...\");\r\n        //await \r\n            this.bot.stop();\r\n        elizaLogger.log(\"Telegram bot stopped\");\r\n    }\r\n}\r\n","import type { Message } from \"@telegraf/types\";\r\nimport type { Context, Telegraf } from \"telegraf\";\r\nimport {\r\n    composeContext,\r\n    elizaLogger,\r\n    ServiceType,\r\n    composeRandomUser,\r\n} from \"@elizaos/core\";\r\nimport { getEmbeddingZeroVector } from \"@elizaos/core\";\r\nimport {\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type IImageDescriptionService,\r\n    type Memory,\r\n    ModelClass,\r\n    type State,\r\n    type UUID,\r\n    type Media,\r\n} from \"@elizaos/core\";\r\nimport { stringToUuid } from \"@elizaos/core\";\r\nimport { generateMessageResponse, generateShouldRespond } from \"@elizaos/core\";\r\nimport {\r\n    telegramMessageHandlerTemplate,\r\n    telegramShouldRespondTemplate,\r\n    telegramAutoPostTemplate,\r\n    telegramPinnedMessageTemplate,\r\n} from \"./templates\";\r\nimport { cosineSimilarity, escapeMarkdown } from \"./utils\";\r\nimport {\r\n    MESSAGE_CONSTANTS,\r\n    TIMING_CONSTANTS,\r\n    RESPONSE_CHANCES,\r\n    TEAM_COORDINATION,\r\n} from \"./constants\";\r\n\r\nimport fs from \"fs\";\r\n\r\nenum MediaType {\r\n    PHOTO = \"photo\",\r\n    VIDEO = \"video\",\r\n    DOCUMENT = \"document\",\r\n    AUDIO = \"audio\",\r\n    ANIMATION = \"animation\",\r\n}\r\n\r\nconst MAX_MESSAGE_LENGTH = 4096; // Telegram's max message length\r\n\r\ninterface MessageContext {\r\n    content: string;\r\n    timestamp: number;\r\n}\r\n\r\ninterface AutoPostConfig {\r\n    enabled: boolean;\r\n    monitorTime: number;\r\n    inactivityThreshold: number; // milliseconds\r\n    mainChannelId: string;\r\n    pinnedMessagesGroups: string[]; // Instead of announcementChannelIds\r\n    lastAutoPost?: number;\r\n    minTimeBetweenPosts?: number;\r\n}\r\n\r\nexport type InterestChats = {\r\n    [key: string]: {\r\n        currentHandler: string | undefined;\r\n        lastMessageSent: number;\r\n        messages: { userId: UUID; userName: string; content: Content }[];\r\n        previousContext?: MessageContext;\r\n        contextSimilarityThreshold?: number;\r\n    };\r\n};\r\n\r\nexport class MessageManager {\r\n    public bot: Telegraf<Context>;\r\n    private runtime: IAgentRuntime;\r\n    private interestChats: InterestChats = {};\r\n    private teamMemberUsernames: Map<string, string> = new Map();\r\n\r\n    private autoPostConfig: AutoPostConfig;\r\n    private lastChannelActivity: { [channelId: string]: number } = {};\r\n    private autoPostInterval: NodeJS.Timeout;\r\n\r\n    constructor(bot: Telegraf<Context>, runtime: IAgentRuntime) {\r\n        this.bot = bot;\r\n        this.runtime = runtime;\r\n\r\n        this._initializeTeamMemberUsernames().catch((error) =>\r\n            elizaLogger.error(\r\n                \"Error initializing team member usernames:\",\r\n                error\r\n            )\r\n        );\r\n\r\n        this.autoPostConfig = {\r\n            enabled:\r\n                this.runtime.character.clientConfig?.telegram?.autoPost\r\n                    ?.enabled || false,\r\n            monitorTime:\r\n                this.runtime.character.clientConfig?.telegram?.autoPost\r\n                    ?.monitorTime || 300000,\r\n            inactivityThreshold:\r\n                this.runtime.character.clientConfig?.telegram?.autoPost\r\n                    ?.inactivityThreshold || 3600000,\r\n            mainChannelId:\r\n                this.runtime.character.clientConfig?.telegram?.autoPost\r\n                    ?.mainChannelId,\r\n            pinnedMessagesGroups:\r\n                this.runtime.character.clientConfig?.telegram?.autoPost\r\n                    ?.pinnedMessagesGroups || [],\r\n            minTimeBetweenPosts:\r\n                this.runtime.character.clientConfig?.telegram?.autoPost\r\n                    ?.minTimeBetweenPosts || 7200000,\r\n        };\r\n\r\n        if (this.autoPostConfig.enabled) {\r\n            this._startAutoPostMonitoring();\r\n        }\r\n    }\r\n\r\n    private async _initializeTeamMemberUsernames(): Promise<void> {\r\n        if (!this.runtime.character.clientConfig?.telegram?.isPartOfTeam)\r\n            return;\r\n\r\n        const teamAgentIds =\r\n            this.runtime.character.clientConfig.telegram.teamAgentIds || [];\r\n\r\n        for (const id of teamAgentIds) {\r\n            try {\r\n                const chat = await this.bot.telegram.getChat(id);\r\n                if (\"username\" in chat && chat.username) {\r\n                    this.teamMemberUsernames.set(id, chat.username);\r\n                    elizaLogger.info(\r\n                        `Cached username for team member ${id}: ${chat.username}`\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    `Error getting username for team member ${id}:`,\r\n                    error\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    private _startAutoPostMonitoring(): void {\r\n        // Wait for bot to be ready\r\n        if (this.bot.botInfo) {\r\n            elizaLogger.info(\r\n                \"[AutoPost Telegram] Bot ready, starting monitoring\"\r\n            );\r\n            this._initializeAutoPost();\r\n        } else {\r\n            elizaLogger.info(\r\n                \"[AutoPost Telegram] Bot not ready, waiting for ready event\"\r\n            );\r\n            this.bot.telegram.getMe().then(() => {\r\n                elizaLogger.info(\r\n                    \"[AutoPost Telegram] Bot ready, starting monitoring\"\r\n                );\r\n                this._initializeAutoPost();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _initializeAutoPost(): void {\r\n        // Give the bot a moment to fully initialize\r\n        setTimeout(() => {\r\n            // Monitor with random intervals between 2-6 hours\r\n            // Monitor with random intervals between 2-6 hours\r\n            this.autoPostInterval = setInterval(() => {\r\n                this._checkChannelActivity();\r\n            }, Math.floor(Math.random() * (4 * 60 * 60 * 1000) + 2 * 60 * 60 * 1000));\r\n        }, 5000);\r\n    }\r\n\r\n    private async _checkChannelActivity(): Promise<void> {\r\n        if (!this.autoPostConfig.enabled || !this.autoPostConfig.mainChannelId)\r\n            return;\r\n\r\n        try {\r\n            // Get last message time\r\n            const now = Date.now();\r\n            const lastActivityTime =\r\n                this.lastChannelActivity[this.autoPostConfig.mainChannelId] ||\r\n                0;\r\n            const timeSinceLastMessage = now - lastActivityTime;\r\n            const timeSinceLastAutoPost =\r\n                now - (this.autoPostConfig.lastAutoPost || 0);\r\n\r\n            // Add some randomness to the inactivity threshold (¬±30 minutes)\r\n            const randomThreshold =\r\n                this.autoPostConfig.inactivityThreshold +\r\n                (Math.random() * 1800000 - 900000);\r\n\r\n            // Check if we should post\r\n            if (\r\n                timeSinceLastMessage > randomThreshold &&\r\n                timeSinceLastAutoPost >\r\n                    (this.autoPostConfig.minTimeBetweenPosts || 0)\r\n            ) {\r\n                try {\r\n                    const roomId = stringToUuid(\r\n                        this.autoPostConfig.mainChannelId +\r\n                            \"-\" +\r\n                            this.runtime.agentId\r\n                    );\r\n                    const memory = {\r\n                        id: stringToUuid(`autopost-${Date.now()}`),\r\n                        userId: this.runtime.agentId,\r\n                        agentId: this.runtime.agentId,\r\n                        roomId,\r\n                        content: {\r\n                            text: \"AUTO_POST_ENGAGEMENT\",\r\n                            source: \"telegram\",\r\n                        },\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: Date.now(),\r\n                    };\r\n\r\n                    let state = await this.runtime.composeState(memory, {\r\n                        telegramBot: this.bot,\r\n                        agentName: this.runtime.character.name,\r\n                    });\r\n\r\n                    const context = composeContext({\r\n                        state,\r\n                        template:\r\n                            this.runtime.character.templates\r\n                                ?.telegramAutoPostTemplate ||\r\n                            telegramAutoPostTemplate,\r\n                    });\r\n\r\n                    const responseContent = await this._generateResponse(\r\n                        memory,\r\n                        state,\r\n                        context\r\n                    );\r\n                    if (!responseContent?.text) return;\r\n\r\n                    console.log(\r\n                        `[Auto Post Telegram] Recent Messages: ${responseContent}`\r\n                    );\r\n\r\n                    // Send message directly using telegram bot\r\n                    const messages = await Promise.all(\r\n                        this.splitMessage(responseContent.text.trim()).map(\r\n                            (chunk) =>\r\n                                this.bot.telegram.sendMessage(\r\n                                    this.autoPostConfig.mainChannelId,\r\n                                    chunk\r\n                                )\r\n                        )\r\n                    );\r\n\r\n                    // Create and store memories\r\n                    const memories = messages.map((m) => ({\r\n                        id: stringToUuid(\r\n                            roomId + \"-\" + m.message_id.toString()\r\n                        ),\r\n                        userId: this.runtime.agentId,\r\n                        agentId: this.runtime.agentId,\r\n                        content: {\r\n                            ...responseContent,\r\n                            text: m.text,\r\n                        },\r\n                        roomId,\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: m.date * 1000,\r\n                    }));\r\n\r\n                    for (const m of memories) {\r\n                        await this.runtime.messageManager.createMemory(m);\r\n                    }\r\n\r\n                    this.autoPostConfig.lastAutoPost = Date.now();\r\n                    state = await this.runtime.updateRecentMessageState(state);\r\n                    await this.runtime.evaluate(memory, state, true);\r\n                } catch (error) {\r\n                    elizaLogger.warn(\"[AutoPost Telegram] Error:\", error);\r\n                }\r\n            } else {\r\n                elizaLogger.warn(\r\n                    \"[AutoPost Telegram] Activity within threshold. Not posting.\"\r\n                );\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.warn(\r\n                \"[AutoPost Telegram] Error checking channel activity:\",\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private async _monitorPinnedMessages(ctx: Context): Promise<void> {\r\n        if (!this.autoPostConfig.pinnedMessagesGroups.length) {\r\n            elizaLogger.warn(\r\n                \"[AutoPost Telegram] Auto post config no pinned message groups\"\r\n            );\r\n            return;\r\n        }\r\n\r\n        if (!ctx.message || !(\"pinned_message\" in ctx.message)) {\r\n            return;\r\n        }\r\n\r\n        const pinnedMessage = ctx.message.pinned_message;\r\n        if (!pinnedMessage) return;\r\n\r\n        if (\r\n            !this.autoPostConfig.pinnedMessagesGroups.includes(\r\n                ctx.chat.id.toString()\r\n            )\r\n        )\r\n            return;\r\n\r\n        const mainChannel = this.autoPostConfig.mainChannelId;\r\n        if (!mainChannel) return;\r\n\r\n        try {\r\n            elizaLogger.info(\r\n                `[AutoPost Telegram] Processing pinned message in group ${ctx.chat.id}`\r\n            );\r\n\r\n            // Explicitly type and handle message content\r\n            const messageContent: string =\r\n                \"text\" in pinnedMessage &&\r\n                typeof pinnedMessage.text === \"string\"\r\n                    ? pinnedMessage.text\r\n                    : \"caption\" in pinnedMessage &&\r\n                      typeof pinnedMessage.caption === \"string\"\r\n                    ? pinnedMessage.caption\r\n                    : \"New pinned message\";\r\n\r\n            const roomId = stringToUuid(\r\n                mainChannel + \"-\" + this.runtime.agentId\r\n            );\r\n            const memory = {\r\n                id: stringToUuid(`pinned-${Date.now()}`),\r\n                userId: this.runtime.agentId,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                content: {\r\n                    text: messageContent,\r\n                    source: \"telegram\",\r\n                    metadata: {\r\n                        messageId: pinnedMessage.message_id,\r\n                        pinnedMessageData: pinnedMessage,\r\n                    },\r\n                },\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: Date.now(),\r\n            };\r\n\r\n            let state = await this.runtime.composeState(memory, {\r\n                telegramBot: this.bot,\r\n                pinnedMessageContent: messageContent,\r\n                pinnedGroupId: ctx.chat.id.toString(),\r\n                agentName: this.runtime.character.name,\r\n            });\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates\r\n                        ?.telegramPinnedMessageTemplate ||\r\n                    telegramPinnedMessageTemplate,\r\n            });\r\n\r\n            const responseContent = await this._generateResponse(\r\n                memory,\r\n                state,\r\n                context\r\n            );\r\n            if (!responseContent?.text) return;\r\n\r\n            // Send message using telegram bot\r\n            const messages = await Promise.all(\r\n                this.splitMessage(responseContent.text.trim()).map((chunk) =>\r\n                    this.bot.telegram.sendMessage(mainChannel, chunk)\r\n                )\r\n            );\r\n\r\n            const memories = messages.map((m) => ({\r\n                id: stringToUuid(roomId + \"-\" + m.message_id.toString()),\r\n                userId: this.runtime.agentId,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    ...responseContent,\r\n                    text: m.text,\r\n                },\r\n                roomId,\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: m.date * 1000,\r\n            }));\r\n\r\n            for (const m of memories) {\r\n                await this.runtime.messageManager.createMemory(m);\r\n            }\r\n\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n            await this.runtime.evaluate(memory, state, true);\r\n        } catch (error) {\r\n            elizaLogger.warn(\r\n                `[AutoPost Telegram] Error processing pinned message:`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private _getTeamMemberUsername(id: string): string | undefined {\r\n        return this.teamMemberUsernames.get(id);\r\n    }\r\n\r\n    private _getNormalizedUserId(id: string | number): string {\r\n        return id.toString().replace(/[^0-9]/g, \"\");\r\n    }\r\n\r\n    private _isTeamMember(userId: string | number): boolean {\r\n        const teamConfig = this.runtime.character.clientConfig?.telegram;\r\n        if (!teamConfig?.isPartOfTeam || !teamConfig.teamAgentIds) return false;\r\n\r\n        const normalizedUserId = this._getNormalizedUserId(userId);\r\n        return teamConfig.teamAgentIds.some(\r\n            (teamId) => this._getNormalizedUserId(teamId) === normalizedUserId\r\n        );\r\n    }\r\n\r\n    private _isTeamLeader(): boolean {\r\n        return (\r\n            this.bot.botInfo?.id.toString() ===\r\n            this.runtime.character.clientConfig?.telegram?.teamLeaderId\r\n        );\r\n    }\r\n\r\n    private _isTeamCoordinationRequest(content: string): boolean {\r\n        const contentLower = content.toLowerCase();\r\n        return TEAM_COORDINATION.KEYWORDS?.some((keyword) =>\r\n            contentLower.includes(keyword.toLowerCase())\r\n        );\r\n    }\r\n\r\n    private _isRelevantToTeamMember(\r\n        content: string,\r\n        chatId: string,\r\n        lastAgentMemory: Memory | null = null\r\n    ): boolean {\r\n        const teamConfig = this.runtime.character.clientConfig?.telegram;\r\n\r\n        // Check leader's context based on last message\r\n        if (this._isTeamLeader() && lastAgentMemory?.content.text) {\r\n            const timeSinceLastMessage = Date.now() - lastAgentMemory.createdAt;\r\n            if (timeSinceLastMessage > MESSAGE_CONSTANTS.INTEREST_DECAY_TIME) {\r\n                return false;\r\n            }\r\n\r\n            const similarity = cosineSimilarity(\r\n                content.toLowerCase(),\r\n                lastAgentMemory.content.text.toLowerCase()\r\n            );\r\n\r\n            return (\r\n                similarity >=\r\n                MESSAGE_CONSTANTS.DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS\r\n            );\r\n        }\r\n\r\n        // Check team member keywords\r\n        if (!teamConfig?.teamMemberInterestKeywords?.length) {\r\n            return false; // If no keywords defined, only leader maintains conversation\r\n        }\r\n\r\n        // Check if content matches any team member keywords\r\n        return teamConfig.teamMemberInterestKeywords.some((keyword) =>\r\n            content.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    }\r\n\r\n    private async _analyzeContextSimilarity(\r\n        currentMessage: string,\r\n        previousContext?: MessageContext,\r\n        agentLastMessage?: string\r\n    ): Promise<number> {\r\n        if (!previousContext) return 1;\r\n\r\n        const timeDiff = Date.now() - previousContext.timestamp;\r\n        const timeWeight = Math.max(0, 1 - timeDiff / (5 * 60 * 1000));\r\n\r\n        const similarity = cosineSimilarity(\r\n            currentMessage.toLowerCase(),\r\n            previousContext.content.toLowerCase(),\r\n            agentLastMessage?.toLowerCase()\r\n        );\r\n\r\n        return similarity * timeWeight;\r\n    }\r\n\r\n    private async _shouldRespondBasedOnContext(\r\n        message: Message,\r\n        chatState: InterestChats[string]\r\n    ): Promise<boolean> {\r\n        const messageText =\r\n            \"text\" in message\r\n                ? message.text\r\n                : \"caption\" in message\r\n                ? message.caption\r\n                : \"\";\r\n\r\n        if (!messageText) return false;\r\n\r\n        // Always respond if mentioned\r\n        if (this._isMessageForMe(message)) return true;\r\n\r\n        // If we're not the current handler, don't respond\r\n        if (chatState?.currentHandler !== this.bot.botInfo?.id.toString())\r\n            return false;\r\n\r\n        // Check if we have messages to compare\r\n        if (!chatState.messages?.length) return false;\r\n\r\n        // Get last user message (not from the bot)\r\n        const lastUserMessage = [...chatState.messages].reverse().find(\r\n            (m, index) =>\r\n                index > 0 && // Skip first message (current)\r\n                m.userId !== this.runtime.agentId\r\n        );\r\n\r\n        if (!lastUserMessage) return false;\r\n\r\n        const lastSelfMemories = await this.runtime.messageManager.getMemories({\r\n            roomId: stringToUuid(\r\n                message.chat.id.toString() + \"-\" + this.runtime.agentId\r\n            ),\r\n            unique: false,\r\n            count: 5,\r\n        });\r\n\r\n        const lastSelfSortedMemories = lastSelfMemories\r\n            ?.filter((m) => m.userId === this.runtime.agentId)\r\n            .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));\r\n\r\n        // Calculate context similarity\r\n        const contextSimilarity = await this._analyzeContextSimilarity(\r\n            messageText,\r\n            {\r\n                content: lastUserMessage.content.text || \"\",\r\n                timestamp: Date.now(),\r\n            },\r\n            lastSelfSortedMemories?.[0]?.content?.text\r\n        );\r\n\r\n        const similarityThreshold =\r\n            this.runtime.character.clientConfig?.telegram\r\n                ?.messageSimilarityThreshold ||\r\n            chatState.contextSimilarityThreshold ||\r\n            MESSAGE_CONSTANTS.DEFAULT_SIMILARITY_THRESHOLD;\r\n\r\n        return contextSimilarity >= similarityThreshold;\r\n    }\r\n\r\n    private _isMessageForMe(message: Message): boolean {\r\n        const botUsername = this.bot.botInfo?.username;\r\n        if (!botUsername) return false;\r\n\r\n        const messageText =\r\n            \"text\" in message\r\n                ? message.text\r\n                : \"caption\" in message\r\n                ? message.caption\r\n                : \"\";\r\n        if (!messageText) return false;\r\n\r\n        const isReplyToBot =\r\n            (message as any).reply_to_message?.from?.is_bot === true &&\r\n            (message as any).reply_to_message?.from?.username === botUsername;\r\n        const isMentioned = messageText.includes(`@${botUsername}`);\r\n        const hasUsername = messageText\r\n            .toLowerCase()\r\n            .includes(botUsername.toLowerCase());\r\n\r\n        return (\r\n            isReplyToBot ||\r\n            isMentioned ||\r\n            (!this.runtime.character.clientConfig?.telegram\r\n                ?.shouldRespondOnlyToMentions &&\r\n                hasUsername)\r\n        );\r\n    }\r\n\r\n    private _checkInterest(chatId: string): boolean {\r\n        const chatState = this.interestChats[chatId];\r\n        if (!chatState) return false;\r\n\r\n        const lastMessage = chatState.messages[chatState.messages.length - 1];\r\n        const timeSinceLastMessage = Date.now() - chatState.lastMessageSent;\r\n\r\n        if (timeSinceLastMessage > MESSAGE_CONSTANTS.INTEREST_DECAY_TIME) {\r\n            delete this.interestChats[chatId];\r\n            return false;\r\n        } else if (\r\n            timeSinceLastMessage > MESSAGE_CONSTANTS.PARTIAL_INTEREST_DECAY\r\n        ) {\r\n            return this._isRelevantToTeamMember(\r\n                lastMessage?.content.text || \"\",\r\n                chatId\r\n            );\r\n        }\r\n\r\n        // Team leader specific checks\r\n        if (this._isTeamLeader() && chatState.messages.length > 0) {\r\n            if (\r\n                !this._isRelevantToTeamMember(\r\n                    lastMessage?.content.text || \"\",\r\n                    chatId\r\n                )\r\n            ) {\r\n                const recentTeamResponses = chatState.messages\r\n                    .slice(-3)\r\n                    .some(\r\n                        (m) =>\r\n                            m.userId !== this.runtime.agentId &&\r\n                            this._isTeamMember(m.userId.toString())\r\n                    );\r\n\r\n                if (recentTeamResponses) {\r\n                    delete this.interestChats[chatId];\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Process image messages and generate descriptions\r\n    private async processImage(\r\n        message: Message\r\n    ): Promise<{ description: string } | null> {\r\n        try {\r\n            let imageUrl: string | null = null;\r\n\r\n            elizaLogger.info(`Telegram Message: ${message}`);\r\n\r\n            if (\"photo\" in message && message.photo?.length > 0) {\r\n                const photo = message.photo[message.photo.length - 1];\r\n                const fileLink = await this.bot.telegram.getFileLink(\r\n                    photo.file_id\r\n                );\r\n                imageUrl = fileLink.toString();\r\n            } else if (\r\n                \"document\" in message &&\r\n                message.document?.mime_type?.startsWith(\"image/\")\r\n            ) {\r\n                const fileLink = await this.bot.telegram.getFileLink(\r\n                    message.document.file_id\r\n                );\r\n                imageUrl = fileLink.toString();\r\n            }\r\n\r\n            if (imageUrl) {\r\n                const imageDescriptionService =\r\n                    this.runtime.getService<IImageDescriptionService>(\r\n                        ServiceType.IMAGE_DESCRIPTION\r\n                    );\r\n                const { title, description } =\r\n                    await imageDescriptionService.describeImage(imageUrl);\r\n                return { description: `[Image: ${title}\\n${description}]` };\r\n            }\r\n        } catch (error) {\r\n            console.error(\"‚ùå Error processing image:\", error);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    // Decide if the bot should respond to the message\r\n    private async _shouldRespond(\r\n        message: Message,\r\n        state: State\r\n    ): Promise<boolean> {\r\n        if (\r\n            this.runtime.character.clientConfig?.telegram\r\n                ?.shouldRespondOnlyToMentions\r\n        ) {\r\n            return this._isMessageForMe(message);\r\n        }\r\n\r\n        // Respond if bot is mentioned\r\n        if (\r\n            \"text\" in message &&\r\n            message.text?.includes(`@${this.bot.botInfo?.username}`)\r\n        ) {\r\n            elizaLogger.info(`Bot mentioned`);\r\n            return true;\r\n        }\r\n\r\n        // Respond to private chats\r\n        if (message.chat.type === \"private\") {\r\n            return true;\r\n        }\r\n\r\n        // Don't respond to images in group chats\r\n        if (\r\n            \"photo\" in message ||\r\n            (\"document\" in message &&\r\n                message.document?.mime_type?.startsWith(\"image/\"))\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        const chatId = message.chat.id.toString();\r\n        const chatState = this.interestChats[chatId];\r\n        const messageText =\r\n            \"text\" in message\r\n                ? message.text\r\n                : \"caption\" in message\r\n                ? message.caption\r\n                : \"\";\r\n\r\n        // Check if team member has direct interest first\r\n        if (\r\n            this.runtime.character.clientConfig?.telegram?.isPartOfTeam &&\r\n            !this._isTeamLeader() &&\r\n            this._isRelevantToTeamMember(messageText, chatId)\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        // Team-based response logic\r\n        if (this.runtime.character.clientConfig?.telegram?.isPartOfTeam) {\r\n            // Team coordination\r\n            if (this._isTeamCoordinationRequest(messageText)) {\r\n                if (this._isTeamLeader()) {\r\n                    return true;\r\n                } else {\r\n                    const randomDelay =\r\n                        Math.floor(\r\n                            Math.random() *\r\n                                (TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MAX -\r\n                                    TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MIN)\r\n                        ) + TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MIN; // 1-3 second random delay\r\n                    await new Promise((resolve) =>\r\n                        setTimeout(resolve, randomDelay)\r\n                    );\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            if (\r\n                !this._isTeamLeader() &&\r\n                this._isRelevantToTeamMember(messageText, chatId)\r\n            ) {\r\n                // Add small delay for non-leader responses\r\n                await new Promise((resolve) =>\r\n                    setTimeout(resolve, TIMING_CONSTANTS.TEAM_MEMBER_DELAY)\r\n                ); //1.5 second delay\r\n\r\n                // If leader has responded in last few seconds, reduce chance of responding\r\n                if (chatState.messages?.length) {\r\n                    const recentMessages = chatState.messages.slice(\r\n                        -MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT\r\n                    );\r\n                    const leaderResponded = recentMessages.some(\r\n                        (m) =>\r\n                            m.userId ===\r\n                                this.runtime.character.clientConfig?.telegram\r\n                                    ?.teamLeaderId &&\r\n                            Date.now() - chatState.lastMessageSent < 3000\r\n                    );\r\n\r\n                    if (leaderResponded) {\r\n                        // 50% chance to respond if leader just did\r\n                        return Math.random() > RESPONSE_CHANCES.AFTER_LEADER;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            // If I'm the leader but message doesn't match my keywords, add delay and check for team responses\r\n            if (\r\n                this._isTeamLeader() &&\r\n                !this._isRelevantToTeamMember(messageText, chatId)\r\n            ) {\r\n                const randomDelay =\r\n                    Math.floor(\r\n                        Math.random() *\r\n                            (TIMING_CONSTANTS.LEADER_DELAY_MAX -\r\n                                TIMING_CONSTANTS.LEADER_DELAY_MIN)\r\n                    ) + TIMING_CONSTANTS.LEADER_DELAY_MIN; // 2-4 second random delay\r\n                await new Promise((resolve) =>\r\n                    setTimeout(resolve, randomDelay)\r\n                );\r\n\r\n                // After delay, check if another team member has already responded\r\n                if (chatState?.messages?.length) {\r\n                    const recentResponses = chatState.messages.slice(\r\n                        -MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT\r\n                    );\r\n                    const otherTeamMemberResponded = recentResponses.some(\r\n                        (m) =>\r\n                            m.userId !== this.runtime.agentId &&\r\n                            this._isTeamMember(m.userId)\r\n                    );\r\n\r\n                    if (otherTeamMemberResponded) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update current handler if we're mentioned\r\n            if (this._isMessageForMe(message)) {\r\n                const channelState = this.interestChats[chatId];\r\n                if (channelState) {\r\n                    channelState.currentHandler =\r\n                        this.bot.botInfo?.id.toString();\r\n                    channelState.lastMessageSent = Date.now();\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // Don't respond if another teammate is handling the conversation\r\n            if (chatState?.currentHandler) {\r\n                if (\r\n                    chatState.currentHandler !==\r\n                        this.bot.botInfo?.id.toString() &&\r\n                    this._isTeamMember(chatState.currentHandler)\r\n                ) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Natural conversation cadence\r\n            if (!this._isMessageForMe(message) && this.interestChats[chatId]) {\r\n                const recentMessages = this.interestChats[\r\n                    chatId\r\n                ].messages.slice(-MESSAGE_CONSTANTS.CHAT_HISTORY_COUNT);\r\n                const ourMessageCount = recentMessages.filter(\r\n                    (m) => m.userId === this.runtime.agentId\r\n                ).length;\r\n\r\n                if (ourMessageCount > 2) {\r\n                    const responseChance = Math.pow(0.5, ourMessageCount - 2);\r\n                    if (Math.random() > responseChance) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check context-based response for team conversations\r\n        if (chatState?.currentHandler) {\r\n            const shouldRespondContext =\r\n                await this._shouldRespondBasedOnContext(message, chatState);\r\n\r\n            if (!shouldRespondContext) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Use AI to decide for text or captions\r\n        if (\"text\" in message || (\"caption\" in message && message.caption)) {\r\n            const shouldRespondContext = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates\r\n                        ?.telegramShouldRespondTemplate ||\r\n                    this.runtime.character?.templates?.shouldRespondTemplate ||\r\n                    composeRandomUser(telegramShouldRespondTemplate, 2),\r\n            });\r\n\r\n            const response = await generateShouldRespond({\r\n                runtime: this.runtime,\r\n                context: shouldRespondContext,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            return response === \"RESPOND\";\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Send long messages in chunks\r\n    private async sendMessageInChunks(\r\n        ctx: Context,\r\n        content: Content,\r\n        replyToMessageId?: number\r\n    ): Promise<Message.TextMessage[]> {\r\n        if (content.attachments && content.attachments.length > 0) {\r\n            content.attachments.map(async (attachment: Media) => {\r\n                const typeMap: { [key: string]: MediaType } = {\r\n                    \"image/gif\": MediaType.ANIMATION,\r\n                    image: MediaType.PHOTO,\r\n                    doc: MediaType.DOCUMENT,\r\n                    video: MediaType.VIDEO,\r\n                    audio: MediaType.AUDIO,\r\n                };\r\n\r\n                let mediaType: MediaType | undefined = undefined;\r\n\r\n                for (const prefix in typeMap) {\r\n                    if (attachment.contentType.startsWith(prefix)) {\r\n                        mediaType = typeMap[prefix];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!mediaType) {\r\n                    throw new Error(\r\n                        `Unsupported Telegram attachment content type: ${attachment.contentType}`\r\n                    );\r\n                }\r\n\r\n                await this.sendMedia(\r\n                    ctx,\r\n                    attachment.url,\r\n                    mediaType,\r\n                    attachment.description\r\n                );\r\n            });\r\n        } else {\r\n            const chunks = this.splitMessage(content.text);\r\n            const sentMessages: Message.TextMessage[] = [];\r\n\r\n            for (let i = 0; i < chunks.length; i++) {\r\n                const chunk = escapeMarkdown(chunks[i]);\r\n                const sentMessage = (await ctx.telegram.sendMessage(\r\n                    ctx.chat.id,\r\n                    chunk,\r\n                    {\r\n                        reply_parameters:\r\n                            i === 0 && replyToMessageId\r\n                                ? { message_id: replyToMessageId }\r\n                                : undefined,\r\n                        parse_mode: \"Markdown\",\r\n                    }\r\n                )) as Message.TextMessage;\r\n\r\n                sentMessages.push(sentMessage);\r\n            }\r\n\r\n            return sentMessages;\r\n        }\r\n    }\r\n\r\n    private async sendMedia(\r\n        ctx: Context,\r\n        mediaPath: string,\r\n        type: MediaType,\r\n        caption?: string\r\n    ): Promise<void> {\r\n        try {\r\n            const isUrl = /^(http|https):\\/\\//.test(mediaPath);\r\n            const sendFunctionMap: Record<MediaType, Function> = {\r\n                [MediaType.PHOTO]: ctx.telegram.sendPhoto.bind(ctx.telegram),\r\n                [MediaType.VIDEO]: ctx.telegram.sendVideo.bind(ctx.telegram),\r\n                [MediaType.DOCUMENT]: ctx.telegram.sendDocument.bind(\r\n                    ctx.telegram\r\n                ),\r\n                [MediaType.AUDIO]: ctx.telegram.sendAudio.bind(ctx.telegram),\r\n                [MediaType.ANIMATION]: ctx.telegram.sendAnimation.bind(\r\n                    ctx.telegram\r\n                ),\r\n            };\r\n\r\n            const sendFunction = sendFunctionMap[type];\r\n\r\n            if (!sendFunction) {\r\n                throw new Error(`Unsupported media type: ${type}`);\r\n            }\r\n\r\n            if (isUrl) {\r\n                // Handle HTTP URLs\r\n                await sendFunction(ctx.chat.id, mediaPath, { caption });\r\n            } else {\r\n                // Handle local file paths\r\n                if (!fs.existsSync(mediaPath)) {\r\n                    throw new Error(`File not found at path: ${mediaPath}`);\r\n                }\r\n\r\n                const fileStream = fs.createReadStream(mediaPath);\r\n\r\n                try {\r\n                    await sendFunction(\r\n                        ctx.chat.id,\r\n                        { source: fileStream },\r\n                        { caption }\r\n                    );\r\n                } finally {\r\n                    fileStream.destroy();\r\n                }\r\n            }\r\n\r\n            elizaLogger.info(\r\n                `${\r\n                    type.charAt(0).toUpperCase() + type.slice(1)\r\n                } sent successfully: ${mediaPath}`\r\n            );\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                `Failed to send ${type}. Path: ${mediaPath}. Error: ${error.message}`\r\n            );\r\n            elizaLogger.debug(error.stack);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Split message into smaller parts\r\n    private splitMessage(text: string): string[] {\r\n        const chunks: string[] = [];\r\n        let currentChunk = \"\";\r\n\r\n        const lines = text.split(\"\\n\");\r\n        for (const line of lines) {\r\n            if (currentChunk.length + line.length + 1 <= MAX_MESSAGE_LENGTH) {\r\n                currentChunk += (currentChunk ? \"\\n\" : \"\") + line;\r\n            } else {\r\n                if (currentChunk) chunks.push(currentChunk);\r\n                currentChunk = line;\r\n            }\r\n        }\r\n\r\n        if (currentChunk) chunks.push(currentChunk);\r\n        return chunks;\r\n    }\r\n\r\n    // Generate a response using AI\r\n    private async _generateResponse(\r\n        message: Memory,\r\n        _state: State,\r\n        context: string\r\n    ): Promise<Content> {\r\n        const { userId, roomId } = message;\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        if (!response) {\r\n            console.error(\"‚ùå No response from generateMessageResponse\");\r\n            return null;\r\n        }\r\n\r\n        await this.runtime.databaseAdapter.log({\r\n            body: { message, context, response },\r\n            userId,\r\n            roomId,\r\n            type: \"response\",\r\n        });\r\n\r\n        return response;\r\n    }\r\n\r\n    // Main handler for incoming messages\r\n    public async handleMessage(ctx: Context): Promise<void> {\r\n        if (!ctx.message || !ctx.from) {\r\n            return; // Exit if no message or sender info\r\n        }\r\n\r\n        this.lastChannelActivity[ctx.chat.id.toString()] = Date.now();\r\n\r\n        // Check for pinned message and route to monitor function\r\n        if (\r\n            this.autoPostConfig.enabled &&\r\n            ctx.message &&\r\n            \"pinned_message\" in ctx.message\r\n        ) {\r\n            // We know this is a message update context now\r\n            await this._monitorPinnedMessages(ctx);\r\n            return;\r\n        }\r\n\r\n        if (\r\n            this.runtime.character.clientConfig?.telegram\r\n                ?.shouldIgnoreBotMessages &&\r\n            ctx.from.is_bot\r\n        ) {\r\n            return;\r\n        }\r\n        if (\r\n            this.runtime.character.clientConfig?.telegram\r\n                ?.shouldIgnoreDirectMessages &&\r\n            ctx.chat?.type === \"private\"\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const message = ctx.message;\r\n        const chatId = ctx.chat?.id.toString();\r\n        const messageText =\r\n            \"text\" in message\r\n                ? message.text\r\n                : \"caption\" in message\r\n                ? message.caption\r\n                : \"\";\r\n\r\n        // Add team handling at the start\r\n        if (\r\n            this.runtime.character.clientConfig?.telegram?.isPartOfTeam &&\r\n            !this.runtime.character.clientConfig?.telegram\r\n                ?.shouldRespondOnlyToMentions\r\n        ) {\r\n            const isDirectlyMentioned = this._isMessageForMe(message);\r\n            const hasInterest = this._checkInterest(chatId);\r\n\r\n            // Non-leader team member showing interest based on keywords\r\n            if (\r\n                !this._isTeamLeader() &&\r\n                this._isRelevantToTeamMember(messageText, chatId)\r\n            ) {\r\n                this.interestChats[chatId] = {\r\n                    currentHandler: this.bot.botInfo?.id.toString(),\r\n                    lastMessageSent: Date.now(),\r\n                    messages: [],\r\n                };\r\n            }\r\n\r\n            const isTeamRequest = this._isTeamCoordinationRequest(messageText);\r\n            const isLeader = this._isTeamLeader();\r\n\r\n            // Check for continued interest\r\n            if (hasInterest && !isDirectlyMentioned) {\r\n                const lastSelfMemories =\r\n                    await this.runtime.messageManager.getMemories({\r\n                        roomId: stringToUuid(\r\n                            chatId + \"-\" + this.runtime.agentId\r\n                        ),\r\n                        unique: false,\r\n                        count: 5,\r\n                    });\r\n\r\n                const lastSelfSortedMemories = lastSelfMemories\r\n                    ?.filter((m) => m.userId === this.runtime.agentId)\r\n                    .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));\r\n\r\n                const isRelevant = this._isRelevantToTeamMember(\r\n                    messageText,\r\n                    chatId,\r\n                    lastSelfSortedMemories?.[0]\r\n                );\r\n\r\n                if (!isRelevant) {\r\n                    delete this.interestChats[chatId];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Handle team coordination requests\r\n            if (isTeamRequest) {\r\n                if (isLeader) {\r\n                    this.interestChats[chatId] = {\r\n                        currentHandler: this.bot.botInfo?.id.toString(),\r\n                        lastMessageSent: Date.now(),\r\n                        messages: [],\r\n                    };\r\n                } else {\r\n                    this.interestChats[chatId] = {\r\n                        currentHandler: this.bot.botInfo?.id.toString(),\r\n                        lastMessageSent: Date.now(),\r\n                        messages: [],\r\n                    };\r\n\r\n                    if (!isDirectlyMentioned) {\r\n                        this.interestChats[chatId].lastMessageSent = 0;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check for other team member mentions using cached usernames\r\n            const otherTeamMembers =\r\n                this.runtime.character.clientConfig.telegram.teamAgentIds.filter(\r\n                    (id) => id !== this.bot.botInfo?.id.toString()\r\n                );\r\n\r\n            const mentionedTeamMember = otherTeamMembers.find((id) => {\r\n                const username = this._getTeamMemberUsername(id);\r\n                return username && messageText?.includes(`@${username}`);\r\n            });\r\n\r\n            // If another team member is mentioned, clear our interest\r\n            if (mentionedTeamMember) {\r\n                if (\r\n                    hasInterest ||\r\n                    this.interestChats[chatId]?.currentHandler ===\r\n                        this.bot.botInfo?.id.toString()\r\n                ) {\r\n                    delete this.interestChats[chatId];\r\n\r\n                    // Only return if we're not the mentioned member\r\n                    if (!isDirectlyMentioned) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set/maintain interest only if we're mentioned or already have interest\r\n            if (isDirectlyMentioned) {\r\n                this.interestChats[chatId] = {\r\n                    currentHandler: this.bot.botInfo?.id.toString(),\r\n                    lastMessageSent: Date.now(),\r\n                    messages: [],\r\n                };\r\n            } else if (!isTeamRequest && !hasInterest) {\r\n                return;\r\n            }\r\n\r\n            // Update message tracking\r\n            if (this.interestChats[chatId]) {\r\n                this.interestChats[chatId].messages.push({\r\n                    userId: stringToUuid(ctx.from.id.toString()),\r\n                    userName:\r\n                        ctx.from.username ||\r\n                        ctx.from.first_name ||\r\n                        \"Unknown User\",\r\n                    content: { text: messageText, source: \"telegram\" },\r\n                });\r\n\r\n                if (\r\n                    this.interestChats[chatId].messages.length >\r\n                    MESSAGE_CONSTANTS.MAX_MESSAGES\r\n                ) {\r\n                    this.interestChats[chatId].messages = this.interestChats[\r\n                        chatId\r\n                    ].messages.slice(-MESSAGE_CONSTANTS.MAX_MESSAGES);\r\n                }\r\n            }\r\n        }\r\n\r\n        try {\r\n            // Convert IDs to UUIDs\r\n            const userId = stringToUuid(ctx.from.id.toString()) as UUID;\r\n\r\n            // Get user name\r\n            const userName =\r\n                ctx.from.username || ctx.from.first_name || \"Unknown User\";\r\n\r\n            // Get chat ID\r\n            const chatId = stringToUuid(\r\n                ctx.chat?.id.toString() + \"-\" + this.runtime.agentId\r\n            ) as UUID;\r\n\r\n            // Get agent ID\r\n            const agentId = this.runtime.agentId;\r\n\r\n            // Get room ID\r\n            const roomId = chatId;\r\n\r\n            // Ensure connection\r\n            await this.runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                userName,\r\n                userName,\r\n                \"telegram\"\r\n            );\r\n\r\n            // Get message ID\r\n            const messageId = stringToUuid(\r\n                roomId + \"-\" + message.message_id.toString()\r\n            ) as UUID;\r\n\r\n            // Handle images\r\n            const imageInfo = await this.processImage(message);\r\n\r\n            // Get text or caption\r\n            let messageText = \"\";\r\n            if (\"text\" in message) {\r\n                messageText = message.text;\r\n            } else if (\"caption\" in message && message.caption) {\r\n                messageText = message.caption;\r\n            }\r\n\r\n            // Combine text and image description\r\n            const fullText = imageInfo\r\n                ? `${messageText} ${imageInfo.description}`\r\n                : messageText;\r\n\r\n            if (!fullText) {\r\n                return; // Skip if no content\r\n            }\r\n\r\n            // Create content\r\n            const content: Content = {\r\n                text: fullText,\r\n                source: \"telegram\",\r\n                inReplyTo:\r\n                    \"reply_to_message\" in message && message.reply_to_message\r\n                        ? stringToUuid(\r\n                              message.reply_to_message.message_id.toString() +\r\n                                  \"-\" +\r\n                                  this.runtime.agentId\r\n                          )\r\n                        : undefined,\r\n            };\r\n\r\n            // Create memory for the message\r\n            const memory: Memory = {\r\n                id: messageId,\r\n                agentId,\r\n                userId,\r\n                roomId,\r\n                content,\r\n                createdAt: message.date * 1000,\r\n                embedding: getEmbeddingZeroVector(),\r\n            };\r\n\r\n            // Create memory\r\n            await this.runtime.messageManager.createMemory(memory);\r\n\r\n            // Update state with the new memory\r\n            let state = await this.runtime.composeState(memory);\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n\r\n            // Decide whether to respond\r\n            const shouldRespond = await this._shouldRespond(message, state);\r\n\r\n            // Send response in chunks\r\n            const callback: HandlerCallback = async (content: Content) => {\r\n                const sentMessages = await this.sendMessageInChunks(\r\n                    ctx,\r\n                    content,\r\n                    message.message_id\r\n                );\r\n                if (sentMessages) {\r\n                    const memories: Memory[] = [];\r\n\r\n                    // Create memories for each sent message\r\n                    for (let i = 0; i < sentMessages.length; i++) {\r\n                        const sentMessage = sentMessages[i];\r\n                        const isLastMessage = i === sentMessages.length - 1;\r\n\r\n                        const memory: Memory = {\r\n                            id: stringToUuid(\r\n                                roomId + \"-\" + sentMessage.message_id.toString()\r\n                            ),\r\n                            agentId,\r\n                            userId: agentId,\r\n                            roomId,\r\n                            content: {\r\n                                ...content,\r\n                                text: sentMessage.text,\r\n                                inReplyTo: messageId,\r\n                            },\r\n                            createdAt: sentMessage.date * 1000,\r\n                            embedding: getEmbeddingZeroVector(),\r\n                        };\r\n\r\n                        // Set action to CONTINUE for all messages except the last one\r\n                        // For the last message, use the original action from the response content\r\n                        memory.content.action = !isLastMessage\r\n                            ? \"CONTINUE\"\r\n                            : content.action;\r\n\r\n                        await this.runtime.messageManager.createMemory(memory);\r\n                        memories.push(memory);\r\n                    }\r\n\r\n                    return memories;\r\n                }\r\n            };\r\n\r\n            if (shouldRespond) {\r\n                // Generate response\r\n                const context = composeContext({\r\n                    state,\r\n                    template:\r\n                        this.runtime.character.templates\r\n                            ?.telegramMessageHandlerTemplate ||\r\n                        this.runtime.character?.templates\r\n                            ?.messageHandlerTemplate ||\r\n                        telegramMessageHandlerTemplate,\r\n                });\r\n\r\n                const responseContent = await this._generateResponse(\r\n                    memory,\r\n                    state,\r\n                    context\r\n                );\r\n\r\n                if (!responseContent || !responseContent.text) return;\r\n\r\n                // Execute callback to send messages and log memories\r\n                const responseMessages = await callback(responseContent);\r\n\r\n                // Update state after response\r\n                state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                // Handle any resulting actions\r\n                await this.runtime.processActions(\r\n                    memory,\r\n                    responseMessages,\r\n                    state,\r\n                    callback\r\n                );\r\n            }\r\n\r\n            await this.runtime.evaluate(memory, state, shouldRespond, callback);\r\n        } catch (error) {\r\n            elizaLogger.error(\"‚ùå Error handling message:\", error);\r\n            elizaLogger.error(\"Error sending message:\", error);\r\n        }\r\n    }\r\n}\r\n","import { messageCompletionFooter, shouldRespondFooter } from \"@elizaos/core\";\r\n\r\nexport const telegramShouldRespondTemplate =\r\n    `# About {{agentName}}:\r\n{{bio}}\r\n\r\n# RESPONSE EXAMPLES\r\n{{user1}}: I just saw a really great movie\r\n{{user2}}: Oh? Which movie?\r\nResult: [IGNORE]\r\n\r\n{{agentName}}: Oh, this is my favorite scene\r\n{{user1}}: sick\r\n{{user2}}: wait, why is it your favorite scene\r\nResult: [RESPOND]\r\n\r\n{{user1}}: stfu bot\r\nResult: [STOP]\r\n\r\n{{user1}}: Hey {{agent}}, can you help me with something\r\nResult: [RESPOND]\r\n\r\n{{user1}}: {{agentName}} stfu plz\r\nResult: [STOP]\r\n\r\n{{user1}}: i need help\r\n{{agentName}}: how can I help you?\r\n{{user1}}: no. i need help from someone else\r\nResult: [IGNORE]\r\n\r\n{{user1}}: Hey {{agent}}, can I ask you a question\r\n{{agentName}}: Sure, what is it\r\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\r\nResult: [RESPOND]\r\n\r\n{{user1}}: {{agentName}} can you tell me a story\r\n{{agentName}}: uhhh...\r\n{{user1}}: please do it\r\n{{agentName}}: okay\r\n{{agentName}}: once upon a time, in a quaint little village, there was a curious girl named elara\r\n{{user1}}: I'm loving it, keep going\r\nResult: [RESPOND]\r\n\r\n{{user1}}: {{agentName}} stop responding plz\r\nResult: [STOP]\r\n\r\n{{user1}}: okay, i want to test something. {{agentName}}, can you say marco?\r\n{{agentName}}: marco\r\n{{user1}}: great. okay, now do it again\r\nResult: [RESPOND]\r\n\r\nResponse options are [RESPOND], [IGNORE] and [STOP].\r\n\r\n{{agentName}} is in a room with other users and should only respond when they are being addressed, and should not respond if they are continuing a conversation that is very long.\r\n\r\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\r\nIf a message is not interesting, relevant, or does not directly address {{agentName}}, respond with [IGNORE]\r\n\r\nAlso, respond with [IGNORE] to messages that are very short or do not contain much information.\r\n\r\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\r\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\r\n\r\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\r\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\r\n\r\nThe goal is to decide whether {{agentName}} should respond to the last message.\r\n\r\n{{recentMessages}}\r\n\r\nThread of Tweets You Are Replying To:\r\n\r\n{{formattedConversation}}\r\n\r\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\r\n` + shouldRespondFooter;\r\n\r\nexport const telegramMessageHandlerTemplate =\r\n    // {{goals}}\r\n    `# Action Examples\r\n{{actionExamples}}\r\n(Action examples are for reference only. Do not use the information from them in your response.)\r\n\r\n# Knowledge\r\n{{knowledge}}\r\n\r\n# Task: Generate dialog and actions for the character {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{providers}}\r\n\r\n{{attachments}}\r\n\r\n{{actions}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\r\nCurrent Post:\r\n{{currentPost}}\r\nThread of Tweets You Are Replying To:\r\n\r\n{{formattedConversation}}\r\n` + messageCompletionFooter;\r\n\r\nexport const telegramAutoPostTemplate =\r\n    `# Action Examples\r\nNONE: Respond but perform no additional action. This is the default if the agent is speaking and not doing anything additional.\r\n\r\n# Task: Generate an engaging community message as {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{messageDirections}}\r\n\r\n# Recent Chat History:\r\n{{recentMessages}}\r\n\r\n# Instructions: Write a natural, engaging message to restart community conversation. Focus on:\r\n- Community engagement\r\n- Educational topics\r\n- General discusions\r\n- Support queries\r\n- Keep message warm and inviting\r\n- Maximum 3 lines\r\n- Use 1-2 emojis maximum\r\n- Avoid financial advice\r\n- Stay within known facts\r\n- No team member mentions\r\n- Be hyped, not repetitive\r\n- Be natural, act like a human, connect with the community\r\n- Don't sound so robotic like\r\n- Randomly grab the most rect 5 messages for some context. Validate the context randomly and use that as a reference point for your next message, but not always, only when relevant.\r\n- If the recent messages are mostly from {{agentName}}, make sure to create conversation starters, given there is no messages from others to reference.\r\n- DO NOT REPEAT THE SAME thing that you just said from your recent chat history, start the message different each time, and be organic, non reptitive.\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include the \"NONE\" action only, as the only valid action for auto-posts is \"NONE\".\r\n` + messageCompletionFooter;\r\n\r\nexport const telegramPinnedMessageTemplate =\r\n    `# Action Examples\r\nNONE: Respond but perform no additional action. This is the default if the agent is speaking and not doing anything additional.\r\n\r\n# Task: Generate pinned message highlight as {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{messageDirections}}\r\n\r\n# Pinned Content:\r\n{{pinnedMessageContent}}\r\n\r\n# Instructions: Write an exciting message to bring attention to the pinned message. Requirements:\r\n- Reference the message that was pinned from the pinned content\r\n- Create genuine excitement if needed based on the pinned content, or create genuice urgency depending on the content\r\n- Encourage community participation\r\n- If there are links like Twitter/X posts, encourage users to like/retweet/comment to spread awarenress, but directly say that, wrap that into the post so its natural.\r\n- Stay within announced facts only\r\n- No additional promises or assumptions\r\n- No team member mentions\r\n- Start the message differently each time. Don't start with the same word like \"hey\", \"hey hey\", etc. be dynamic\r\n- Address everyone, not as a direct reply to whoever pinned the message or wrote it, but you can reference them\r\n- Maximum 3-7 lines formatted nicely if needed, based on the context of the announcement\r\n- Use 1-2 emojis maximum\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include an action, if appropriate. The only valid action for pinned message highlights is \"NONE\".\r\n` + messageCompletionFooter;","export function cosineSimilarity(\r\n    text1: string,\r\n    text2: string,\r\n    text3?: string\r\n): number {\r\n    const preprocessText = (text: string) =>\r\n        text\r\n            .toLowerCase()\r\n            .replace(/[^\\w\\s'_-]/g, \" \")\r\n            .replace(/\\s+/g, \" \")\r\n            .trim();\r\n\r\n    const getWords = (text: string) => {\r\n        return text.split(\" \").filter((word) => word.length > 1);\r\n    };\r\n\r\n    const words1 = getWords(preprocessText(text1));\r\n    const words2 = getWords(preprocessText(text2));\r\n    const words3 = text3 ? getWords(preprocessText(text3)) : [];\r\n\r\n    const freq1: { [key: string]: number } = {};\r\n    const freq2: { [key: string]: number } = {};\r\n    const freq3: { [key: string]: number } = {};\r\n\r\n    words1.forEach((word) => (freq1[word] = (freq1[word] || 0) + 1));\r\n    words2.forEach((word) => (freq2[word] = (freq2[word] || 0) + 1));\r\n    if (words3.length) {\r\n        words3.forEach((word) => (freq3[word] = (freq3[word] || 0) + 1));\r\n    }\r\n\r\n    const uniqueWords = new Set([\r\n        ...Object.keys(freq1),\r\n        ...Object.keys(freq2),\r\n        ...(words3.length ? Object.keys(freq3) : []),\r\n    ]);\r\n\r\n    let dotProduct = 0;\r\n    let magnitude1 = 0;\r\n    let magnitude2 = 0;\r\n    let magnitude3 = 0;\r\n\r\n    uniqueWords.forEach((word) => {\r\n        const val1 = freq1[word] || 0;\r\n        const val2 = freq2[word] || 0;\r\n        const val3 = freq3[word] || 0;\r\n\r\n        if (words3.length) {\r\n            // For three-way, calculate pairwise similarities\r\n            const sim12 = val1 * val2;\r\n            const sim23 = val2 * val3;\r\n            const sim13 = val1 * val3;\r\n\r\n            // Take maximum similarity between any pair\r\n            dotProduct += Math.max(sim12, sim23, sim13);\r\n        } else {\r\n            dotProduct += val1 * val2;\r\n        }\r\n\r\n        magnitude1 += val1 * val1;\r\n        magnitude2 += val2 * val2;\r\n        if (words3.length) {\r\n            magnitude3 += val3 * val3;\r\n        }\r\n    });\r\n\r\n    magnitude1 = Math.sqrt(magnitude1);\r\n    magnitude2 = Math.sqrt(magnitude2);\r\n    magnitude3 = words3.length ? Math.sqrt(magnitude3) : 1;\r\n\r\n    if (\r\n        magnitude1 === 0 ||\r\n        magnitude2 === 0 ||\r\n        (words3.length && magnitude3 === 0)\r\n    )\r\n        return 0;\r\n\r\n    // For two texts, use original calculation\r\n    if (!words3.length) {\r\n        return dotProduct / (magnitude1 * magnitude2);\r\n    }\r\n\r\n    // For three texts, use max magnitude pair to maintain scale\r\n    const maxMagnitude = Math.max(\r\n        magnitude1 * magnitude2,\r\n        magnitude2 * magnitude3,\r\n        magnitude1 * magnitude3\r\n    );\r\n\r\n    return dotProduct / maxMagnitude;\r\n}\r\n\r\nexport function escapeMarkdown(text: string): string {\r\n    // Don't escape if it's a code block\r\n    if (text.startsWith(\"```\") && text.endsWith(\"```\")) {\r\n        return text;\r\n    }\r\n\r\n    // Split the text by code blocks\r\n    const parts = text.split(/(```[\\s\\S]*?```)/g);\r\n\r\n    return parts\r\n        .map((part, index) => {\r\n            // If it's a code block (odd indices in the split result will be code blocks)\r\n            if (index % 2 === 1) {\r\n                return part;\r\n            }\r\n            // For regular text, only escape characters that need escaping in Markdown\r\n            return (\r\n                part\r\n                    // First preserve any intended inline code spans\r\n                    .replace(/`.*?`/g, (match) => match)\r\n                    // Then only escape the minimal set of special characters that need escaping in Markdown mode\r\n                    .replace(/([*_`\\\\])/g, \"\\\\$1\")\r\n            );\r\n        })\r\n        .join(\"\");\r\n}\r\n\r\n/**\r\n * Splits a message into chunks that fit within Telegram's message length limit\r\n */\r\nexport function splitMessage(text: string, maxLength = 4096): string[] {\r\n    const chunks: string[] = [];\r\n    let currentChunk = \"\";\r\n\r\n    const lines = text.split(\"\\n\");\r\n    for (const line of lines) {\r\n        if (currentChunk.length + line.length + 1 <= maxLength) {\r\n            currentChunk += (currentChunk ? \"\\n\" : \"\") + line;\r\n        } else {\r\n            if (currentChunk) chunks.push(currentChunk);\r\n            currentChunk = line;\r\n        }\r\n    }\r\n\r\n    if (currentChunk) chunks.push(currentChunk);\r\n    return chunks;\r\n}\r\n","export const MESSAGE_CONSTANTS = {\r\n    MAX_MESSAGES: 50,\r\n    RECENT_MESSAGE_COUNT: 5,\r\n    CHAT_HISTORY_COUNT: 10,\r\n    DEFAULT_SIMILARITY_THRESHOLD: 0.6,\r\n    DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS: 0.4,\r\n    INTEREST_DECAY_TIME: 5 * 60 * 1000, // 5 minutes\r\n    PARTIAL_INTEREST_DECAY: 3 * 60 * 1000, // 3 minutes\r\n} as const;\r\n\r\nexport const TIMING_CONSTANTS = {\r\n    TEAM_MEMBER_DELAY: 1500, // 1.5 seconds\r\n    TEAM_MEMBER_DELAY_MIN: 1000, // 1 second\r\n    TEAM_MEMBER_DELAY_MAX: 3000, // 3 seconds\r\n    LEADER_DELAY_MIN: 2000, // 2 seconds\r\n    LEADER_DELAY_MAX: 4000, // 4 seconds\r\n} as const;\r\n\r\nexport const RESPONSE_CHANCES = {\r\n    AFTER_LEADER: 0.5, // 50% chance to respond after leader\r\n} as const;\r\n\r\nexport const TEAM_COORDINATION = {\r\n    KEYWORDS: [\r\n        \"team\",\r\n        \"all agents\",\r\n        \"team update\",\r\n        \"gm team\",\r\n        \"hello team\",\r\n        \"hey team\",\r\n        \"hi team\",\r\n        \"morning team\",\r\n        \"evening team\",\r\n        \"night team\",\r\n        \"update team\",\r\n    ],\r\n} as const;\r\n","export async function getOrCreateRecommenderInBe(\r\n    recommenderId: string,\r\n    username: string,\r\n    backendToken: string,\r\n    backend: string,\r\n    retries = 3,\r\n    delayMs = 2000\r\n) {\r\n    for (let attempt = 1; attempt <= retries; attempt++) {\r\n        try {\r\n            const response = await fetch(\r\n                `${backend}/api/updaters/getOrCreateRecommender`,\r\n                {\r\n                    method: \"POST\",\r\n                    headers: {\r\n                        \"Content-Type\": \"application/json\",\r\n                        Authorization: `Bearer ${backendToken}`,\r\n                    },\r\n                    body: JSON.stringify({\r\n                        recommenderId: recommenderId,\r\n                        username: username,\r\n                    }),\r\n                }\r\n            );\r\n            const data = await response.json();\r\n            return data;\r\n        } catch (error) {\r\n            console.error(\r\n                `Attempt ${attempt} failed: Error getting or creating recommender in backend`,\r\n                error\r\n            );\r\n            if (attempt < retries) {\r\n                console.log(`Retrying in ${delayMs} ms...`);\r\n                await new Promise((resolve) => setTimeout(resolve, delayMs));\r\n            } else {\r\n                console.error(\"All attempts failed.\");\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { IAgentRuntime } from \"@elizaos/core\";\r\nimport { z } from \"zod\";\r\n\r\nexport const telegramEnvSchema = z.object({\r\n    TELEGRAM_BOT_TOKEN: z.string().min(1, \"Telegram bot token is required\"),\r\n});\r\n\r\nexport type TelegramConfig = z.infer<typeof telegramEnvSchema>;\r\n\r\nexport async function validateTelegramConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<TelegramConfig> {\r\n    try {\r\n        const config = {\r\n            TELEGRAM_BOT_TOKEN:\r\n                runtime.getSetting(\"TELEGRAM_BOT_TOKEN\") ||\r\n                process.env.TELEGRAM_BOT_TOKEN,\r\n        };\r\n\r\n        return telegramEnvSchema.parse(config);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Telegram configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n"],"mappings":"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","names":["elizaLogger","elizaLogger","message","chatId","messageText","content","memory","elizaLogger","elizaLogger"]}