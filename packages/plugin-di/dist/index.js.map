{"version":3,"sources":["../src/symbols.ts","../src/decorators/content.decorators.ts","../src/factories/plugin.ts","../src/factories/charactor.ts","../src/di.ts","../src/templates.ts","../src/actions/baseInjectableAction.ts","../src/evaluators/baseInjectableEvaluator.ts"],"sourcesContent":["/**\r\n * Factory Symbols used in the library\r\n */\r\nexport const FACTORIES = {\r\n    PluginFactory: Symbol.for(\"PluginFactory\"),\r\n};\r\n","import \"reflect-metadata\";\r\nimport { z } from \"zod\";\r\nimport type { ContentPropertyDescription } from \"../types\";\r\n\r\nconst CONTENT_METADATA_KEY = \"content:properties\";\r\n\r\nexport type ContentClass<T> = {\r\n    new (...args: unknown[]): T;\r\n    prototype: T;\r\n};\r\n\r\ninterface ContentPropertyConfig extends ContentPropertyDescription {\r\n    schema: z.ZodType;\r\n}\r\n\r\nexport function property(config: ContentPropertyConfig) {\r\n    return (target: object, propertyKey: string) => {\r\n        const properties =\r\n            Reflect.getMetadata(CONTENT_METADATA_KEY, target) || {};\r\n        properties[propertyKey] = config;\r\n        Reflect.defineMetadata(CONTENT_METADATA_KEY, properties, target);\r\n    };\r\n}\r\n\r\n/**\r\n * Create a Zod schema from a class decorated with @property\r\n *\r\n * @param cls\r\n * @returns\r\n */\r\nexport function createZodSchema<T>(cls: ContentClass<T>): z.ZodType<T> {\r\n    const properties: Record<string, ContentPropertyConfig> =\r\n        Reflect.getMetadata(CONTENT_METADATA_KEY, cls.prototype) || {};\r\n    const schemaProperties = Object.entries(properties).reduce(\r\n        (acc, [key, { schema }]) => {\r\n            acc[key] = schema;\r\n            return acc;\r\n        },\r\n        {} as Record<string, z.ZodType<T>>\r\n    );\r\n    return z.object(schemaProperties) as unknown as z.ZodType<T>;\r\n}\r\n\r\n/**\r\n * Load the description of each property from a class decorated with @property\r\n *\r\n * @param cls\r\n * @returns\r\n */\r\nexport function loadPropertyDescriptions<T>(\r\n    cls: ContentClass<T>\r\n): Record<string, ContentPropertyDescription> {\r\n    const properties: Record<string, ContentPropertyConfig> =\r\n        Reflect.getMetadata(CONTENT_METADATA_KEY, cls.prototype) || {};\r\n    return Object.entries(properties).reduce(\r\n        (acc, [key, { description, examples }]) => {\r\n            acc[key] = { description, examples };\r\n            return acc;\r\n        },\r\n        {} as Record<string, ContentPropertyDescription>\r\n    );\r\n}\r\n","import type { interfaces } from \"inversify\";\r\nimport {\r\n    elizaLogger,\r\n    type Plugin,\r\n} from \"@elizaos/core\";\r\nimport type { PluginFactory, PluginOptions } from \"../types\";\r\n\r\n/**\r\n * Get an instance from the container\r\n * @param ctx\r\n * @param item\r\n * @param type\r\n * @returns\r\n */\r\nasync function getInstanceFromContainer<T>(\r\n    ctx: interfaces.Context,\r\n    item: T | (new (...args: any[]) => T),\r\n    type: string\r\n): Promise<T | undefined> {\r\n    if (typeof item === \"function\") {\r\n        try {\r\n            return await ctx.container.getAsync(item);\r\n        } catch (e) {\r\n            elizaLogger.error(\r\n                `Error normalizing ${type}: ${(item as Function).name}`,\r\n                e.message\r\n            );\r\n            return undefined;\r\n        }\r\n    }\r\n    return item;\r\n}\r\n\r\n/**\r\n * Create a plugin factory\r\n */\r\nexport function createPlugin(ctx: interfaces.Context): PluginFactory {\r\n    return async (opts: PluginOptions): Promise<Plugin> => {\r\n        // Create a new plugin object\r\n        const plugin: Plugin = {\r\n            name: opts.name,\r\n            description: opts.description,\r\n        };\r\n\r\n        // Handle providers - if provided, map through them\r\n        // For class constructors (functions), get instance from container\r\n        // For regular providers, use as-is\r\n        if (typeof opts.providers !== \"undefined\") {\r\n            plugin.providers = (\r\n                await Promise.all(\r\n                    opts.providers.map((provider) =>\r\n                        getInstanceFromContainer(\r\n                            ctx,\r\n                            provider,\r\n                            \"provider\"\r\n                        )\r\n                    )\r\n                )\r\n            ).filter(Boolean); // Filter out undefined providers\r\n        }\r\n\r\n        // Handle actions - if provided, map through them\r\n        // For class constructors (functions), get instance from container\r\n        // For regular actions, use as-is\r\n        if (typeof opts.actions !== \"undefined\") {\r\n            plugin.actions = (\r\n                await Promise.all(\r\n                    opts.actions.map((action) =>\r\n                        getInstanceFromContainer(ctx, action, \"action\")\r\n                    )\r\n                )\r\n            ).filter(Boolean); // Filter out undefined actions\r\n        }\r\n\r\n        // Handle evaluators - if provided, map through them\r\n        // For class constructors (functions), get instance from container\r\n        // For regular evaluators, use as-is\r\n        if (typeof opts.evaluators !== \"undefined\") {\r\n            plugin.evaluators = (\r\n                await Promise.all(\r\n                    opts.evaluators.map((evaluator) =>\r\n                        getInstanceFromContainer(\r\n                            ctx,\r\n                            evaluator,\r\n                            \"evaluator\"\r\n                        )\r\n                    )\r\n                )\r\n            ).filter(Boolean); // Filter out undefined evaluators\r\n        }\r\n\r\n        // Handle services - if provided, assign directly\r\n        if (typeof opts.services !== \"undefined\") {\r\n            plugin.services = (\r\n                await Promise.all(\r\n                    opts.services.map((service) =>\r\n                        getInstanceFromContainer(ctx, service, \"service\")\r\n                    )\r\n                )\r\n            )\r\n        }\r\n\r\n        // Handle clients - if provided, assign directly\r\n        if (typeof opts.clients !== \"undefined\") {\r\n            plugin.clients = (\r\n                await Promise.all(\r\n                    opts.clients.map((client) =>\r\n                        getInstanceFromContainer(ctx, client, \"client\")\r\n                    )\r\n                )\r\n            )\r\n        }\r\n        return plugin;\r\n    };\r\n}\r\n","import { type Character, elizaLogger, type Plugin } from \"@elizaos/core\";\r\nimport { globalContainer } from \"../di\";\r\nimport type { PluginFactory } from \"../types\";\r\nimport { FACTORIES } from \"../symbols\";\r\n\r\n/**\r\n * Normalize a character by creating all plugins from the character's plugin list using the PluginFactory\r\n * @param character\r\n */\r\nexport async function normalizeCharacter(\r\n    character: Character\r\n): Promise<Character> {\r\n    // Use the PluginFactory to import the plugins within the same request for each character\r\n    const createPlugin = globalContainer.get<PluginFactory>(\r\n        FACTORIES.PluginFactory\r\n    );\r\n\r\n    const normalizePlugin = async (plugin: any) => {\r\n        if (\r\n            typeof plugin?.name === \"string\" &&\r\n            typeof plugin?.description === \"string\"\r\n        ) {\r\n            try {\r\n                const normalized = await createPlugin(plugin);\r\n                elizaLogger.info(\"Normalized plugin:\", normalized.name);\r\n                return normalized;\r\n            } catch (e) {\r\n                elizaLogger.error(\r\n                    `Error normalizing plugin: ${plugin.name}`,\r\n                    e.message\r\n                );\r\n            }\r\n        }\r\n        return plugin;\r\n    };\r\n\r\n    let plugins: Plugin[] = [];\r\n    if (character.plugins?.length > 0) {\r\n        const normalizedPlugins = await Promise.all(\r\n            character.plugins.map(normalizePlugin)\r\n        );\r\n        const validPlugins = normalizedPlugins.filter(\r\n            (plugin): plugin is Plugin => plugin !== undefined\r\n        );\r\n        if (validPlugins.length !== character.plugins.length) {\r\n            elizaLogger.warn(\r\n                `Some plugins failed to normalize: ${character.plugins.length - validPlugins.length} failed`\r\n            );\r\n        }\r\n        plugins = validPlugins;\r\n    }\r\n    return Object.assign({}, character, { plugins }) as Character;\r\n}\r\n","import type { Plugin } from \"@elizaos/core\";\r\nimport { Container, type interfaces } from \"inversify\";\r\nimport { FACTORIES } from \"./symbols\";\r\nimport { createPlugin } from \"./factories\";\r\nimport type { PluginOptions } from \"./types\";\r\n\r\nconst globalContainer = new Container();\r\n\r\n// ----- Bind to factory functions -----\r\n\r\nglobalContainer\r\n    .bind<interfaces.Factory<Promise<Plugin>>>(FACTORIES.PluginFactory)\r\n    .toFactory<Promise<Plugin>, [PluginOptions]>(createPlugin);\r\n\r\nexport { globalContainer };\r\n","import { z } from \"zod\";\r\nimport type { ContentPropertyDescription } from \"./types\";\r\n\r\n/**\r\n * build the content output template\r\n * @param properties The properties of the content\r\n * @param schema The Zod schema of the content\r\n */\r\nexport function buildContentOutputTemplate(\r\n    actionName: string,\r\n    actionDesc: string,\r\n    properties: Record<string, ContentPropertyDescription>,\r\n    schema: z.ZodType<any>\r\n): string {\r\n    let propDesc = \"\";\r\n    Object.entries(properties).forEach(([key, { description, examples }]) => {\r\n        propDesc += `- Field **\"${key}\"**: ${description}.`;\r\n        if (examples?.length > 0) {\r\n            propDesc += \" Examples or Rules for this field:\\n\";\r\n        } else {\r\n            propDesc += \"\\n\";\r\n        }\r\n        examples?.forEach((example, index) => {\r\n            propDesc += `    ${index + 1}. ${example}\\n`;\r\n        });\r\n    });\r\n    return `Perform the action: \"${actionName}\".\r\nAction description is \"${actionDesc}\".\r\n\r\n### TASK: Extract the following details about the requested action\r\n\r\n${propDesc}\r\n\r\nUse null for any values that cannot be determined.\r\n\r\nRespond with a JSON markdown block containing only the extracted values with this structure:\r\n\r\n\\`\\`\\`json\r\n${zodSchemaToJson(schema)}\r\n\\`\\`\\`\r\n\r\nHere are the recent user messages for context:\r\n{{recentMessages}}\r\n`;\r\n}\r\n\r\n/**\r\n * Convert a Zod schema to JSON\r\n * @param schema Zod schema\r\n * @returns JSON string\r\n */\r\nexport function zodSchemaToJson(schema: z.ZodType<any>): string {\r\n    if (schema instanceof z.ZodObject) {\r\n        const shape = schema.shape;\r\n        const properties = Object.entries(shape).map(([key, value]) => {\r\n            return `\"${key}\": ${zodTypeToJson(value as z.ZodType)}`;\r\n        });\r\n        return `{\\n${properties.join(\",\\n\")}\\n}`;\r\n    }\r\n    return \"\";\r\n}\r\n\r\n/**\r\n * Convert a Zod type to JSON\r\n * @param schema Zod type\r\n */\r\nfunction zodTypeToJson(schema: z.ZodType<any>): string {\r\n    if (schema instanceof z.ZodNullable || schema instanceof z.ZodOptional) {\r\n        return `${zodTypeToJson(schema._def.innerType)} | null`;\r\n    }\r\n    if (schema instanceof z.ZodUnion) {\r\n        return schema._def.options.map(zodTypeToJson).join(\" | \");\r\n    }\r\n    if (schema instanceof z.ZodString) {\r\n        return \"string\";\r\n    }\r\n    if (schema instanceof z.ZodNumber) {\r\n        return \"number\";\r\n    }\r\n    if (schema instanceof z.ZodBoolean) {\r\n        return \"boolean\";\r\n    }\r\n    if (schema instanceof z.ZodArray) {\r\n        return `${zodTypeToJson(schema._def.type)}[]`;\r\n    }\r\n    if (schema instanceof z.ZodObject) {\r\n        return zodSchemaToJson(schema);\r\n    }\r\n    return \"any\";\r\n}\r\n","import { injectable, unmanaged } from \"inversify\";\r\nimport type { z } from \"zod\";\r\nimport {\r\n    type ActionExample,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateObject,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    ModelClass,\r\n    type State,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    type ContentClass,\r\n    createZodSchema,\r\n    loadPropertyDescriptions,\r\n} from \"../decorators\";\r\nimport type { ActionOptions, InjectableAction } from \"../types\";\r\nimport { buildContentOutputTemplate } from \"../templates\";\r\n\r\n// type ActionResult = unknown;\r\n\r\n/**\r\n * Base abstract class for injectable actions\r\n */\r\n@injectable()\r\nexport abstract class BaseInjectableAction<T> implements InjectableAction<T> {\r\n    // -------- Properties --------\r\n    public name: string;\r\n    public similes: string[];\r\n    public description: string;\r\n    public examples: ActionExample[][];\r\n    public suppressInitialMessage: boolean;\r\n\r\n    /**\r\n     * The content class for the action\r\n     */\r\n    protected readonly contentClass: ContentClass<T>;\r\n    /**\r\n     * Optional template for the action, if not provided, it will be generated from the content class\r\n     */\r\n    protected readonly template: string;\r\n    /**\r\n     * Optional content schema for the action, if not provided, it will be generated from the content class\r\n     */\r\n    protected readonly contentSchema: z.ZodSchema<T>;\r\n\r\n    /**\r\n     * Constructor for the base injectable action\r\n     */\r\n    constructor(@unmanaged() opts: ActionOptions<T>) {\r\n        // Set the action properties\r\n        this.name = opts.name;\r\n        this.similes = opts.similes;\r\n        this.description = opts.description;\r\n        this.examples = opts.examples;\r\n        this.suppressInitialMessage = opts.suppressInitialMessage ?? false; // Default to false\r\n        // Set the content class, template and content schema\r\n        this.contentClass = opts.contentClass;\r\n        this.template = opts.template;\r\n        this.contentSchema = opts.contentSchema;\r\n\r\n        if (this.contentClass !== undefined) {\r\n            if (this.contentSchema === undefined) {\r\n                this.contentSchema = createZodSchema(this.contentClass);\r\n            }\r\n            if (this.template === undefined) {\r\n                const properties = loadPropertyDescriptions(this.contentClass);\r\n                this.template = buildContentOutputTemplate(\r\n                    this.name,\r\n                    this.description,\r\n                    properties,\r\n                    this.contentSchema\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // -------- Abstract methods to be implemented by the child class --------\r\n\r\n    /**\r\n     * Abstract method to execute the action\r\n     * @param content The content object\r\n     * @param callback The callback function to pass the result to Eliza runtime\r\n     */\r\n    abstract execute(\r\n        content: T | null,\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state?: State,\r\n        callback?: HandlerCallback\r\n    ): Promise<unknown | null>;\r\n\r\n    // -------- Implemented methods for Eliza runtime --------\r\n\r\n    /**\r\n     * Default implementation of the validate method\r\n     * You can override this method to add custom validation logic\r\n     *\r\n     * @param runtime The runtime object from Eliza framework\r\n     * @param message The message object from Eliza framework\r\n     * @param state The state object from Eliza framework\r\n     * @returns The validation result\r\n     */\r\n    async validate(\r\n        _runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        _state?: State\r\n    ): Promise<boolean> {\r\n        // Default implementation is to return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Default implementation of the preparation of action context\r\n     * You can override this method to add custom logic\r\n     *\r\n     * @param runtime The runtime object from Eliza framework\r\n     * @param message The message object from Eliza framework\r\n     * @param state The state object from Eliza framework\r\n     */\r\n    protected async prepareActionContext(\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state?: State\r\n    ): Promise<string> {\r\n        // Initialize or update state\r\n        let currentState = state;\r\n        if (!currentState) {\r\n            currentState = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            currentState = await runtime.updateRecentMessageState(currentState);\r\n        }\r\n\r\n        // Compose context\r\n        return composeContext({ state: currentState, template: this.template });\r\n    }\r\n\r\n    /**\r\n     * Default method for processing messages\r\n     * You can override this method to add custom logic\r\n     *\r\n     * @param runtime The runtime object from Eliza framework\r\n     * @param message The message object from Eliza framework\r\n     * @param state The state object from Eliza framework\r\n     * @returns The generated content from AI based on the message\r\n     */\r\n    protected async processMessages(\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ): Promise<T | null> {\r\n        const actionContext = await this.prepareActionContext(\r\n            runtime,\r\n            message,\r\n            state\r\n        );\r\n\r\n        if (!actionContext) {\r\n            elizaLogger.error(\"Failed to prepare action context\");\r\n            return null;\r\n        }\r\n\r\n        // Generate transfer content\r\n        const resourceDetails = await generateObject({\r\n            runtime,\r\n            context: actionContext,\r\n            modelClass: ModelClass.SMALL,\r\n            schema: this.contentSchema,\r\n        });\r\n\r\n        elizaLogger.debug(\"Response: \", resourceDetails.object);\r\n\r\n        // Validate content\r\n        const parsedObj = await this.contentSchema.safeParseAsync(\r\n            resourceDetails.object\r\n        );\r\n        if (!parsedObj.success) {\r\n            elizaLogger.error(\r\n                \"Failed to parse content: \",\r\n                JSON.stringify(parsedObj.error?.flatten())\r\n            );\r\n            return null;\r\n        }\r\n        return parsedObj.data;\r\n    }\r\n\r\n    /**\r\n     * Default Handler function type for processing messages\r\n     * You can override this method to add custom logic\r\n     *\r\n     * @param runtime The runtime object from Eliza framework\r\n     * @param message The message object from Eliza framework\r\n     * @param state The state object from Eliza framework\r\n     * @param options The options object from Eliza framework\r\n     * @param callback The callback function to pass the result to Eliza runtime\r\n     */\r\n    async handler(\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state?: State,\r\n        _options?: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ): Promise<unknown | null> {\r\n        let content: T;\r\n        try {\r\n            content = await this.processMessages(runtime, message, state);\r\n        } catch (err) {\r\n            elizaLogger.error(\"Error in processing messages:\", err.message);\r\n\r\n            if (callback) {\r\n                await callback?.({\r\n                    text: `Unable to process transfer request. Invalid content: ${err.message}`,\r\n                    content: {\r\n                        error: \"Invalid content\",\r\n                    },\r\n                });\r\n            }\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            return await this.execute(\r\n                content,\r\n                runtime,\r\n                message,\r\n                state,\r\n                callback\r\n            );\r\n        } catch (err) {\r\n            elizaLogger.error(\"Error in executing action:\", err.message);\r\n        }\r\n    }\r\n}\r\n","import { injectable, unmanaged } from \"inversify\";\r\nimport type {\r\n    IAgentRuntime,\r\n    EvaluationExample,\r\n    Memory,\r\n    State,\r\n    HandlerCallback,\r\n} from \"@elizaos/core\";\r\nimport type { EvaluatorOptions, InjectableEvaluator } from \"../types\";\r\n\r\n/**\r\n * Base abstract class for injectable actions\r\n */\r\n@injectable()\r\nexport abstract class BaseInjectableEvaluator implements InjectableEvaluator {\r\n    // -------- Properties --------\r\n    public alwaysRun: boolean;\r\n    public name: string;\r\n    public similes: string[];\r\n    public description: string;\r\n    public examples: EvaluationExample[];\r\n\r\n    /**\r\n     * Constructor for the base injectable action\r\n     */\r\n    constructor(@unmanaged() opts: EvaluatorOptions) {\r\n        // Set the action properties\r\n        this.name = opts.name;\r\n        this.similes = opts.similes;\r\n        this.description = opts.description;\r\n        this.examples = opts.examples;\r\n        this.alwaysRun = opts.alwaysRun ?? false; // Default to false\r\n    }\r\n\r\n    /**\r\n     * Default implementation of the validate method\r\n     * You can override this method to add custom validation logic\r\n     *\r\n     * @param runtime The runtime object from Eliza framework\r\n     * @param message The message object from Eliza framework\r\n     * @param state The state object from Eliza framework\r\n     * @returns The validation result\r\n     */\r\n    async validate(\r\n        _runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        _state?: State\r\n    ): Promise<boolean> {\r\n        // Default implementation is to return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handler for the evaluator\r\n     */\r\n    abstract handler(\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state?: State,\r\n        options?: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ): Promise<unknown>;\r\n}\r\n"],"mappings":";;;;;;;;AAAA;;;;AAGO,IAAMA,YAAY;EACrBC,eAAeC,OAAOC,IAAI,eAAA;AAC9B;;;ACLA,OAAO;AACP,SAASC,SAAS;AAGlB,IAAMC,uBAAuB;AAWtB,SAASC,SAASC,QAA6B;AAClD,SAAO,CAACC,QAAgBC,gBAAAA;AACpB,UAAMC,aACFC,QAAQC,YAAYP,sBAAsBG,MAAAA,KAAW,CAAC;AAC1DE,eAAWD,WAAAA,IAAeF;AAC1BI,YAAQE,eAAeR,sBAAsBK,YAAYF,MAAAA;EAC7D;AACJ;AAPgBF;AAeT,SAASQ,gBAAmBC,KAAoB;AACnD,QAAML,aACFC,QAAQC,YAAYP,sBAAsBU,IAAIC,SAAS,KAAK,CAAC;AACjE,QAAMC,mBAAmBC,OAAOC,QAAQT,UAAAA,EAAYU,OAChD,CAACC,KAAK,CAACC,KAAK,EAAEC,OAAM,CAAE,MAAC;AACnBF,QAAIC,GAAAA,IAAOC;AACX,WAAOF;EACX,GACA,CAAC,CAAA;AAEL,SAAOG,EAAEC,OAAOR,gBAAAA;AACpB;AAXgBH;AAmBT,SAASY,yBACZX,KAAoB;AAEpB,QAAML,aACFC,QAAQC,YAAYP,sBAAsBU,IAAIC,SAAS,KAAK,CAAC;AACjE,SAAOE,OAAOC,QAAQT,UAAAA,EAAYU,OAC9B,CAACC,KAAK,CAACC,KAAK,EAAEK,aAAaC,SAAQ,CAAE,MAAC;AAClCP,QAAIC,GAAAA,IAAO;MAAEK;MAAaC;IAAS;AACnC,WAAOP;EACX,GACA,CAAC,CAAA;AAET;AAZgBK;;;AChDhB,SACIG,mBAEG;AAUP,eAAeC,yBACXC,KACAC,MACAC,MAAY;AAEZ,MAAI,OAAOD,SAAS,YAAY;AAC5B,QAAI;AACA,aAAO,MAAMD,IAAIG,UAAUC,SAASH,IAAAA;IACxC,SAASI,GAAG;AACRC,kBAAYC,MACR,qBAAqBL,IAAAA,KAAUD,KAAkBO,IAAI,IACrDH,EAAEI,OAAO;AAEb,aAAOC;IACX;EACJ;AACA,SAAOT;AACX;AAjBeF;AAsBR,SAASY,aAAaX,KAAuB;AAChD,SAAO,OAAOY,SAAAA;AAEV,UAAMC,SAAiB;MACnBL,MAAMI,KAAKJ;MACXM,aAAaF,KAAKE;IACtB;AAKA,QAAI,OAAOF,KAAKG,cAAc,aAAa;AACvCF,aAAOE,aACH,MAAMC,QAAQC,IACVL,KAAKG,UAAUG,IAAI,CAACC,aAChBpB,yBACIC,KACAmB,UACA,UAAA,CAAA,CAAA,GAIdC,OAAOC,OAAAA;IACb;AAKA,QAAI,OAAOT,KAAKU,YAAY,aAAa;AACrCT,aAAOS,WACH,MAAMN,QAAQC,IACVL,KAAKU,QAAQJ,IAAI,CAACK,WACdxB,yBAAyBC,KAAKuB,QAAQ,QAAA,CAAA,CAAA,GAGhDH,OAAOC,OAAAA;IACb;AAKA,QAAI,OAAOT,KAAKY,eAAe,aAAa;AACxCX,aAAOW,cACH,MAAMR,QAAQC,IACVL,KAAKY,WAAWN,IAAI,CAACO,cACjB1B,yBACIC,KACAyB,WACA,WAAA,CAAA,CAAA,GAIdL,OAAOC,OAAAA;IACb;AAGA,QAAI,OAAOT,KAAKc,aAAa,aAAa;AACtCb,aAAOa,WACH,MAAMV,QAAQC,IACVL,KAAKc,SAASR,IAAI,CAACS,YACf5B,yBAAyBC,KAAK2B,SAAS,SAAA,CAAA,CAAA;IAIvD;AAGA,QAAI,OAAOf,KAAKgB,YAAY,aAAa;AACrCf,aAAOe,UACH,MAAMZ,QAAQC,IACVL,KAAKgB,QAAQV,IAAI,CAACW,WACd9B,yBAAyBC,KAAK6B,QAAQ,QAAA,CAAA,CAAA;IAItD;AACA,WAAOhB;EACX;AACJ;AA9EgBF;;;ACpChB,SAAyBmB,eAAAA,oBAAgC;;;ACCzD,SAASC,iBAAkC;AAK3C,IAAMC,kBAAkB,IAAIC,UAAAA;AAI5BD,gBACKE,KAA0CC,UAAUC,aAAa,EACjEC,UAA4CC,YAAAA;;;ADHjD,eAAsBC,mBAClBC,WAAoB;AAGpB,QAAMC,gBAAeC,gBAAgBC,IACjCC,UAAUC,aAAa;AAG3B,QAAMC,kBAAkB,8BAAOC,WAAAA;AAC3B,QACI,OAAOA,QAAQC,SAAS,YACxB,OAAOD,QAAQE,gBAAgB,UACjC;AACE,UAAI;AACA,cAAMC,aAAa,MAAMT,cAAaM,MAAAA;AACtCI,QAAAA,aAAYC,KAAK,sBAAsBF,WAAWF,IAAI;AACtD,eAAOE;MACX,SAASG,GAAG;AACRF,QAAAA,aAAYG,MACR,6BAA6BP,OAAOC,IAAI,IACxCK,EAAEE,OAAO;MAEjB;IACJ;AACA,WAAOR;EACX,GAjBwB;AAmBxB,MAAIS,UAAoB,CAAA;AACxB,MAAIhB,UAAUgB,SAASC,SAAS,GAAG;AAC/B,UAAMC,oBAAoB,MAAMC,QAAQC,IACpCpB,UAAUgB,QAAQK,IAAIf,eAAAA,CAAAA;AAE1B,UAAMgB,eAAeJ,kBAAkBK,OACnC,CAAChB,WAA6BA,WAAWiB,MAAAA;AAE7C,QAAIF,aAAaL,WAAWjB,UAAUgB,QAAQC,QAAQ;AAClDN,MAAAA,aAAYc,KACR,qCAAqCzB,UAAUgB,QAAQC,SAASK,aAAaL,MAAM,SAAS;IAEpG;AACAD,cAAUM;EACd;AACA,SAAOI,OAAOC,OAAO,CAAC,GAAG3B,WAAW;IAAEgB;EAAQ,CAAA;AAClD;AA3CsBjB;;;AETtB,SAAS6B,KAAAA,UAAS;AAQX,SAASC,2BACZC,YACAC,YACAC,YACAC,QAAsB;AAEtB,MAAIC,WAAW;AACfC,SAAOC,QAAQJ,UAAAA,EAAYK,QAAQ,CAAC,CAACC,KAAK,EAAEC,aAAaC,SAAQ,CAAE,MAAC;AAChEN,gBAAY,cAAcI,GAAAA,QAAWC,WAAAA;AACrC,QAAIC,UAAUC,SAAS,GAAG;AACtBP,kBAAY;IAChB,OAAO;AACHA,kBAAY;IAChB;AACAM,cAAUH,QAAQ,CAACK,SAASC,UAAAA;AACxBT,kBAAY,OAAOS,QAAQ,CAAA,KAAMD,OAAAA;;IACrC,CAAA;EACJ,CAAA;AACA,SAAO,wBAAwBZ,UAAAA;yBACVC,UAAAA;;;;EAIvBG,QAAAA;;;;;;;EAOAU,gBAAgBX,MAAAA,CAAAA;;;;;;AAMlB;AApCgBJ;AA2CT,SAASe,gBAAgBX,QAAsB;AAClD,MAAIA,kBAAkBY,GAAEC,WAAW;AAC/B,UAAMC,QAAQd,OAAOc;AACrB,UAAMf,aAAaG,OAAOC,QAAQW,KAAAA,EAAOC,IAAI,CAAC,CAACV,KAAKW,KAAAA,MAAM;AACtD,aAAO,IAAIX,GAAAA,MAASY,cAAcD,KAAAA,CAAAA;IACtC,CAAA;AACA,WAAO;EAAMjB,WAAWmB,KAAK,KAAA,CAAA;;EACjC;AACA,SAAO;AACX;AATgBP;AAehB,SAASM,cAAcjB,QAAsB;AACzC,MAAIA,kBAAkBY,GAAEO,eAAenB,kBAAkBY,GAAEQ,aAAa;AACpE,WAAO,GAAGH,cAAcjB,OAAOqB,KAAKC,SAAS,CAAA;EACjD;AACA,MAAItB,kBAAkBY,GAAEW,UAAU;AAC9B,WAAOvB,OAAOqB,KAAKG,QAAQT,IAAIE,aAAAA,EAAeC,KAAK,KAAA;EACvD;AACA,MAAIlB,kBAAkBY,GAAEa,WAAW;AAC/B,WAAO;EACX;AACA,MAAIzB,kBAAkBY,GAAEc,WAAW;AAC/B,WAAO;EACX;AACA,MAAI1B,kBAAkBY,GAAEe,YAAY;AAChC,WAAO;EACX;AACA,MAAI3B,kBAAkBY,GAAEgB,UAAU;AAC9B,WAAO,GAAGX,cAAcjB,OAAOqB,KAAKQ,IAAI,CAAA;EAC5C;AACA,MAAI7B,kBAAkBY,GAAEC,WAAW;AAC/B,WAAOF,gBAAgBX,MAAAA;EAC3B;AACA,SAAO;AACX;AAvBSiB;;;AClET,SAASa,YAAYC,iBAAiB;AAEtC,SAEIC,gBACAC,eAAAA,cACAC,gBAIAC,kBAEG;;;;;;;;;;;;;;;;;;AAeA,IAAeC,uBAAf,MAAeA;SAAAA;;;;EAEXC;EACAC;EACAC;EACAC;EACAC;;;;EAKYC;;;;EAIAC;;;;EAIAC;;;;EAKnBC,YAAyBC,MAAwB;AAE7C,SAAKT,OAAOS,KAAKT;AACjB,SAAKC,UAAUQ,KAAKR;AACpB,SAAKC,cAAcO,KAAKP;AACxB,SAAKC,WAAWM,KAAKN;AACrB,SAAKC,yBAAyBK,KAAKL,0BAA0B;AAE7D,SAAKC,eAAeI,KAAKJ;AACzB,SAAKC,WAAWG,KAAKH;AACrB,SAAKC,gBAAgBE,KAAKF;AAE1B,QAAI,KAAKF,iBAAiBK,QAAW;AACjC,UAAI,KAAKH,kBAAkBG,QAAW;AAClC,aAAKH,gBAAgBI,gBAAgB,KAAKN,YAAY;MAC1D;AACA,UAAI,KAAKC,aAAaI,QAAW;AAC7B,cAAME,aAAaC,yBAAyB,KAAKR,YAAY;AAC7D,aAAKC,WAAWQ,2BACZ,KAAKd,MACL,KAAKE,aACLU,YACA,KAAKL,aAAa;MAE1B;IACJ;EACJ;;;;;;;;;;;EA4BA,MAAMQ,SACFC,UACAC,UACAC,QACgB;AAEhB,WAAO;EACX;;;;;;;;;EAUA,MAAgBC,qBACZC,SACAC,SACAC,OACe;AAEf,QAAIC,eAAeD;AACnB,QAAI,CAACC,cAAc;AACfA,qBAAgB,MAAMH,QAAQI,aAAaH,OAAAA;IAC/C,OAAO;AACHE,qBAAe,MAAMH,QAAQK,yBAAyBF,YAAAA;IAC1D;AAGA,WAAOG,eAAe;MAAEJ,OAAOC;MAAcjB,UAAU,KAAKA;IAAS,CAAA;EACzE;;;;;;;;;;EAWA,MAAgBqB,gBACZP,SACAC,SACAC,OACiB;AACjB,UAAMM,gBAAgB,MAAM,KAAKT,qBAC7BC,SACAC,SACAC,KAAAA;AAGJ,QAAI,CAACM,eAAe;AAChBC,MAAAA,aAAYC,MAAM,kCAAA;AAClB,aAAO;IACX;AAGA,UAAMC,kBAAkB,MAAMC,eAAe;MACzCZ;MACAa,SAASL;MACTM,YAAYC,WAAWC;MACvBC,QAAQ,KAAK9B;IACjB,CAAA;AAEAsB,IAAAA,aAAYS,MAAM,cAAcP,gBAAgBQ,MAAM;AAGtD,UAAMC,YAAY,MAAM,KAAKjC,cAAckC,eACvCV,gBAAgBQ,MAAM;AAE1B,QAAI,CAACC,UAAUE,SAAS;AACpBb,MAAAA,aAAYC,MACR,6BACAa,KAAKC,UAAUJ,UAAUV,OAAOe,QAAAA,CAAAA,CAAAA;AAEpC,aAAO;IACX;AACA,WAAOL,UAAUM;EACrB;;;;;;;;;;;EAYA,MAAMC,QACF3B,SACAC,SACAC,OACA0B,UACAC,UACuB;AACvB,QAAIC;AACJ,QAAI;AACAA,gBAAU,MAAM,KAAKvB,gBAAgBP,SAASC,SAASC,KAAAA;IAC3D,SAAS6B,KAAK;AACVtB,MAAAA,aAAYC,MAAM,iCAAiCqB,IAAI9B,OAAO;AAE9D,UAAI4B,UAAU;AACV,cAAMA,WAAW;UACbG,MAAM,wDAAwDD,IAAI9B,OAAO;UACzE6B,SAAS;YACLpB,OAAO;UACX;QACJ,CAAA;MACJ;AACA,aAAO;IACX;AAEA,QAAI;AACA,aAAO,MAAM,KAAKuB,QACdH,SACA9B,SACAC,SACAC,OACA2B,QAAAA;IAER,SAASE,KAAK;AACVtB,MAAAA,aAAYC,MAAM,8BAA8BqB,IAAI9B,OAAO;IAC/D;EACJ;AACJ;;;;;;;;;;;AC1OA,SAASiC,cAAAA,aAAYC,aAAAA,kBAAiB;;;;;;;;;;;;;;;;;;AAc/B,IAAeC,0BAAf,MAAeA;SAAAA;;;;EAEXC;EACAC;EACAC;EACAC;EACAC;;;;EAKPC,YAAyBC,MAAwB;AAE7C,SAAKL,OAAOK,KAAKL;AACjB,SAAKC,UAAUI,KAAKJ;AACpB,SAAKC,cAAcG,KAAKH;AACxB,SAAKC,WAAWE,KAAKF;AACrB,SAAKJ,YAAYM,KAAKN,aAAa;EACvC;;;;;;;;;;EAWA,MAAMO,SACFC,UACAC,UACAC,QACgB;AAEhB,WAAO;EACX;AAYJ;;;;;;;;;","names":["FACTORIES","PluginFactory","Symbol","for","z","CONTENT_METADATA_KEY","property","config","target","propertyKey","properties","Reflect","getMetadata","defineMetadata","createZodSchema","cls","prototype","schemaProperties","Object","entries","reduce","acc","key","schema","z","object","loadPropertyDescriptions","description","examples","elizaLogger","getInstanceFromContainer","ctx","item","type","container","getAsync","e","elizaLogger","error","name","message","undefined","createPlugin","opts","plugin","description","providers","Promise","all","map","provider","filter","Boolean","actions","action","evaluators","evaluator","services","service","clients","client","elizaLogger","Container","globalContainer","Container","bind","FACTORIES","PluginFactory","toFactory","createPlugin","normalizeCharacter","character","createPlugin","globalContainer","get","FACTORIES","PluginFactory","normalizePlugin","plugin","name","description","normalized","elizaLogger","info","e","error","message","plugins","length","normalizedPlugins","Promise","all","map","validPlugins","filter","undefined","warn","Object","assign","z","buildContentOutputTemplate","actionName","actionDesc","properties","schema","propDesc","Object","entries","forEach","key","description","examples","length","example","index","zodSchemaToJson","z","ZodObject","shape","map","value","zodTypeToJson","join","ZodNullable","ZodOptional","_def","innerType","ZodUnion","options","ZodString","ZodNumber","ZodBoolean","ZodArray","type","injectable","unmanaged","composeContext","elizaLogger","generateObject","ModelClass","BaseInjectableAction","name","similes","description","examples","suppressInitialMessage","contentClass","template","contentSchema","constructor","opts","undefined","createZodSchema","properties","loadPropertyDescriptions","buildContentOutputTemplate","validate","_runtime","_message","_state","prepareActionContext","runtime","message","state","currentState","composeState","updateRecentMessageState","composeContext","processMessages","actionContext","elizaLogger","error","resourceDetails","generateObject","context","modelClass","ModelClass","SMALL","schema","debug","object","parsedObj","safeParseAsync","success","JSON","stringify","flatten","data","handler","_options","callback","content","err","text","execute","injectable","unmanaged","BaseInjectableEvaluator","alwaysRun","name","similes","description","examples","constructor","opts","validate","_runtime","_message","_state"]}