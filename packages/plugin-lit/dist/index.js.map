{"version":3,"sources":["../src/actions/helloLit/helloLitAction.ts","../src/actions/helloLit/helloLit.ts","../src/actions/tools/erc20transfer/policy.ts","../src/actions/tools/erc20transfer/ipfs.ts","../src/actions/tools/erc20transfer/tool.ts","../src/templates/index.ts","../src/actions/tools/erc20transfer/toolCall.ts","../src/actions/tools/ecdsaSign/policy.ts","../src/actions/tools/ecdsaSign/ipfs.ts","../src/actions/tools/ecdsaSign/tool.ts","../src/actions/tools/ecdsaSign/toolCall.ts","../src/actions/tools/uniswapSwap/policy.ts","../src/actions/tools/uniswapSwap/ipfs.ts","../src/actions/tools/uniswapSwap/tool.ts","../src/actions/tools/uniswapSwap/toolCall.ts","../src/index.ts"],"names":["ethers","z","LIT_NETWORK","LitJsSdk","LitActionResource","LIT_ABILITY","createSiweMessage","generateAuthSig","policySchema","encodePolicy","decodePolicy","__filename","fileURLToPath","__dirname","dirname","DEFAULT_CIDS","deployedCids","ipfsPath","join","existsSync","IPFS_CIDS","createNetworkTool","NETWORK_CONFIGS","composeContext","generateObjectDeprecated","ModelClass","BaseEthereumAddressSchema"],"mappings":"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","file":"index.js","sourcesContent":["const _litActionCode = async () => {\r\n  console.log(magicNumber);\r\n  try {\r\n    LitActions.setResponse({ response: JSON.stringify({ message: \"Hello from Lit Protocol!\" }) });\r\n  } catch (error) {\r\n    LitActions.setResponse({ response: error.message });\r\n  }\r\n};\r\n\r\nexport const litActionCode = `(${_litActionCode.toString()})();`;\r\n","import { ethers } from 'ethers'; // Import ethers\r\nimport {\r\n    Action,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    type State,\r\n    HandlerCallback,\r\n} from \"@elizaos/core\";\r\nimport LitJsSdk from '@lit-protocol/lit-node-client';\r\nimport { LIT_NETWORK, LIT_ABILITY } from '@lit-protocol/constants';\r\nimport {\r\n  LitActionResource,\r\n  createSiweMessage,\r\n  generateAuthSig,\r\n} from \"@lit-protocol/auth-helpers\";\r\nimport { litActionCode } from \"./helloLitAction\";\r\n\r\nexport const HELLO_LIT_ACTION: Action = {\r\n    name: \"hello\",\r\n    similes: [\"Hello World\", \"Basic Lit Action\"],\r\n    description: \"This interacts with Lit\",\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options?: any,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        try {\r\n            const litNodeClient = new LitJsSdk.LitNodeClient({\r\n                alertWhenUnauthorized: false,\r\n                litNetwork: LIT_NETWORK.DatilDev,\r\n                debug: false,\r\n            });\r\n\r\n            await litNodeClient.connect();\r\n            console.log(\"Connected to Lit Network\");\r\n\r\n            const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n            const ethersWallet = new ethers.Wallet(privateKey);\r\n            console.log(\"Wallet Address:\", ethersWallet.address);\r\n\r\n            const sessionSignatures = await litNodeClient.getSessionSigs({\r\n                chain: \"ethereum\",\r\n                expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\r\n                resourceAbilityRequests: [\r\n                    {\r\n                        resource: new LitActionResource(\"*\"),\r\n                        ability: LIT_ABILITY.LitActionExecution,\r\n                    },\r\n                ],\r\n                authNeededCallback: async ({\r\n                    uri,\r\n                    expiration,\r\n                    resourceAbilityRequests,\r\n                }) => {\r\n                    const toSign = await createSiweMessage({\r\n                        uri,\r\n                        expiration,\r\n                        resources: resourceAbilityRequests,\r\n                        walletAddress: ethersWallet.address,\r\n                        nonce: await litNodeClient.getLatestBlockhash(),\r\n                        litNodeClient,\r\n                    });\r\n    \r\n                    return await generateAuthSig({\r\n                        signer: ethersWallet,\r\n                        toSign,\r\n                    });\r\n                },\r\n            });\r\n            \r\n            // Execute the Lit Action\r\n            const response = await litNodeClient.executeJs({\r\n                sessionSigs: sessionSignatures,\r\n                code: litActionCode,\r\n                jsParams: {\r\n                    magicNumber: 43, // Example parameter\r\n                },\r\n            });\r\n\r\n            console.log(\"Lit Action Response:\", response);\r\n\r\n            // Use the callback (if provided) to send the response to the chat UI\r\n            if (callback) {\r\n                callback({\r\n                    text: `Lit Action executed successfully. Response: ${JSON.stringify(response)}`,\r\n                    content: {\r\n                        success: true,\r\n                        response: response,\r\n                    },\r\n                });\r\n            }\r\n\r\n            return true;\r\n\r\n        } catch (error) {\r\n            console.error(\"Error in lit action handler:\", error);\r\n\r\n            // Use the callback (if provided) to send the error message to the chat UI\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error executing Lit Action: ${error.message}`,\r\n                    content: {\r\n                        error: error.message,\r\n                    },\r\n                });\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"I'd like to deploy a lit action\" },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: { text: \"Deploying a basic Lit Action\", action: \"HELLO_LIT_ACTION\" },\r\n            },\r\n        ],\r\n    ],\r\n};\r\n","import { BaseEthereumAddressSchema } from '@lit-protocol/aw-tool';\r\nimport { z } from 'zod';\r\nimport { ethers } from 'ethers';\r\n\r\n/**\r\n * Schema for validating an ERC20 transfer policy.\r\n * @type {z.ZodObject}\r\n */\r\nconst policySchema = z.object({\r\n  type: z.literal('ERC20Transfer'), // Policy type must be 'ERC20Transfer'\r\n  version: z.string(), // Version of the policy\r\n  erc20Decimals: z.string().refine(\r\n    (val) => {\r\n      try {\r\n        const bn = ethers.BigNumber.from(val);\r\n        return !bn.isNegative() && bn.lte(255); // Ensure the amount is non-negative and does not exceed uint8\r\n      } catch {\r\n        return false; // Invalid format\r\n      }\r\n    },\r\n    {\r\n      message:\r\n        'Invalid amount format. Must be a non-negative integer and not exceed 255.',\r\n    }\r\n  ), // Number of decimals for the ERC20 token\r\n  maxAmount: z.string().refine(\r\n    (val) => {\r\n      try {\r\n        const bn = ethers.BigNumber.from(val);\r\n        return !bn.isNegative(); // Ensure the amount is non-negative\r\n      } catch {\r\n        return false; // Invalid format\r\n      }\r\n    },\r\n    { message: 'Invalid amount format. Must be a non-negative integer.' }\r\n  ),\r\n  allowedTokens: z.array(BaseEthereumAddressSchema), // Array of allowed token addresses\r\n  allowedRecipients: z.array(BaseEthereumAddressSchema), // Array of allowed recipient addresses\r\n});\r\n\r\n/**\r\n * Encodes an ERC20 transfer policy into a packed ABI-encoded string.\r\n * @param {ERC20TransferPolicyType} policy - The policy to encode.\r\n * @returns {string} ABI-encoded string representing the policy.\r\n * @throws {z.ZodError} If the policy does not match the schema.\r\n */\r\nfunction encodePolicy(policy: ERC20TransferPolicyType): string {\r\n  // Validate the policy against the schema\r\n  policySchema.parse(policy);\r\n\r\n  // Encode the policy using ABI encoding\r\n  return ethers.utils.defaultAbiCoder.encode(\r\n    [\r\n      'tuple(uint8 erc20Decimals, uint256 maxAmount, address[] allowedTokens, address[] allowedRecipients)',\r\n    ],\r\n    [\r\n      {\r\n        erc20Decimals: policy.erc20Decimals,\r\n        maxAmount: ethers.utils\r\n          .parseUnits(policy.maxAmount, policy.erc20Decimals)\r\n          .toString(),\r\n        allowedTokens: policy.allowedTokens,\r\n        allowedRecipients: policy.allowedRecipients,\r\n      },\r\n    ]\r\n  );\r\n}\r\n\r\n/**\r\n * Decodes an ABI-encoded string into an ERC20 transfer policy.\r\n * @param {string} encodedPolicy - The ABI-encoded policy string.\r\n * @returns {ERC20TransferPolicyType} The decoded policy object.\r\n * @throws {z.ZodError} If the decoded policy does not match the schema.\r\n */\r\nfunction decodePolicy(encodedPolicy: string): ERC20TransferPolicyType {\r\n  // Decode the ABI-encoded string\r\n  const decoded = ethers.utils.defaultAbiCoder.decode(\r\n    [\r\n      'tuple(uint8 erc20Decimals, uint256 maxAmount, address[] allowedTokens, address[] allowedRecipients)',\r\n    ],\r\n    encodedPolicy\r\n  )[0];\r\n\r\n  // Construct the policy object\r\n  const policy: ERC20TransferPolicyType = {\r\n    type: 'ERC20Transfer',\r\n    version: '1.0.0',\r\n    erc20Decimals: decoded.erc20Decimals.toString(),\r\n    maxAmount: decoded.maxAmount.toString(),\r\n    allowedTokens: decoded.allowedTokens,\r\n    allowedRecipients: decoded.allowedRecipients,\r\n  };\r\n\r\n  // Validate the decoded policy against the schema\r\n  return policySchema.parse(policy);\r\n}\r\n\r\n/**\r\n * Type representing an ERC20 transfer policy.\r\n * @typedef {z.infer<typeof policySchema>} ERC20TransferPolicyType\r\n */\r\nexport type ERC20TransferPolicyType = z.infer<typeof policySchema>;\r\n\r\n/**\r\n * Utility object for working with ERC20 transfer policies.\r\n * @type {object}\r\n * @property {ERC20TransferPolicyType} type - Type placeholder for the policy.\r\n * @property {string} version - Version of the policy schema.\r\n * @property {z.ZodObject} schema - Zod schema for validating policies.\r\n * @property {function} encode - Function to encode a policy into an ABI-encoded string.\r\n * @property {function} decode - Function to decode an ABI-encoded string into a policy.\r\n */\r\nexport const ERC20TransferPolicy = {\r\n  type: {} as ERC20TransferPolicyType, // Placeholder for the policy type\r\n  version: '1.0.0', // Version of the policy schema\r\n  schema: policySchema, // Zod schema for validation\r\n  encode: encodePolicy, // Function to encode a policy\r\n  decode: decodePolicy, // Function to decode a policy\r\n};\r\n","import { fileURLToPath } from 'url';\r\nimport { dirname, join } from 'path';\r\nimport { existsSync } from 'fs';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\n\r\n/**\r\n * Default IPFS CIDs for different environments.\r\n * These are the actual deployed CIDs from the Lit Action deployments.\r\n */\r\nconst DEFAULT_CIDS = {\r\n  'datil-dev': {\r\n    tool: 'QmUPnnuz8E3wKYG7bCxqnjjhV9anE9uMxHXY4fTv7Z5Y6A',\r\n    defaultPolicy: 'QmVHC5cTWE1nzBSzEASULdwfHo1QiYMEr5Ht83anxe6uWB',\r\n  },\r\n  'datil-test': {\r\n    tool: 'QmRcwjz5EpUaABPMwhgYwsDsy1noYNYkhr6nC8JqWUPEoy',\r\n    defaultPolicy: 'QmVHC5cTWE1nzBSzEASULdwfHo1QiYMEr5Ht83anxe6uWB',\r\n  },\r\n  datil: {\r\n    tool: 'QmQ1k3ZzmoPDukAphQ353WJ73XaNFnhmztr1v2hfTprW3V',\r\n    defaultPolicy: 'QmVHC5cTWE1nzBSzEASULdwfHo1QiYMEr5Ht83anxe6uWB',\r\n  },\r\n} as const;\r\n\r\nlet deployedCids = DEFAULT_CIDS;\r\n\r\nconst ipfsPath = join(__dirname, '../../../dist/ipfs.json');\r\n\r\nif (existsSync(ipfsPath)) {\r\n  try {\r\n    const ipfsModule = await import(ipfsPath, {\r\n      assert: { type: 'json' }\r\n    });\r\n    deployedCids = ipfsModule.default;\r\n  } catch (error) {\r\n    console.warn('Failed to load ipfs.json, using default CIDs:', error);\r\n  }\r\n} else {\r\n  console.warn(\r\n    'ipfs.json not found. Using default deployed CIDs.'\r\n  );\r\n}\r\n\r\nexport const IPFS_CIDS = deployedCids;\r\n","import { z } from 'zod';\r\nimport {\r\n  type AwTool,\r\n  type SupportedLitNetwork,\r\n  NETWORK_CONFIGS,\r\n  NetworkConfig,\r\n} from '@lit-protocol/aw-tool';\r\n\r\nimport { ERC20TransferPolicy, type ERC20TransferPolicyType } from './policy';\r\nimport { IPFS_CIDS } from './ipfs';\r\n\r\n/**\r\n * Parameters required for the ERC20 Send Lit Action.\r\n * @property {string} pkpEthAddress - The Ethereum address of the PKP.\r\n * @property {string} tokenIn - The ERC20 token contract address to send.\r\n * @property {string} recipientAddress - The Ethereum address to receive the tokens.\r\n * @property {string} amountIn - The amount of tokens to send as a string (will be parsed based on token decimals).\r\n * @property {string} chainId - The ID of the blockchain network.\r\n * @property {string} rpcUrl - The RPC URL of the blockchain network.\r\n */\r\ninterface ERC20TransferLitActionParameters {\r\n  pkpEthAddress: string;\r\n  tokenIn: string;\r\n  recipientAddress: string;\r\n  amountIn: string;\r\n  chainId: string;\r\n  rpcUrl: string;\r\n}\r\n\r\n/**\r\n * Zod schema for validating ERC20TransferLitActionParameters.\r\n * @type {z.ZodObject}\r\n */\r\nconst ERC20TransferLitActionSchema = z.object({\r\n  pkpEthAddress: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  tokenIn: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum contract address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  recipientAddress: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  amountIn: z\r\n    .string()\r\n    .regex(\r\n      /^\\d*\\.?\\d+$/,\r\n      'Must be a valid decimal number as a string (e.g. \"1.5\" or \"100\")'\r\n    ),\r\n  chainId: z\r\n    .string()\r\n    .regex(/^\\d+$/, 'Must be a valid chain ID number as a string'),\r\n  rpcUrl: z\r\n    .string()\r\n    .url()\r\n    .startsWith(\r\n      'https://',\r\n      'Must be a valid HTTPS URL for the blockchain RPC endpoint'\r\n    ),\r\n});\r\n\r\n/**\r\n * Descriptions of each parameter for the ERC20 Send Lit Action.\r\n * These descriptions are designed to be consumed by LLMs to understand the required parameters.\r\n * @type {Record<string, string>}\r\n */\r\nconst ERC20TransferLitActionParameterDescriptions = {\r\n  pkpEthAddress:\r\n    'The Ethereum address of the PKP that will be used to sign and send the transaction.',\r\n  tokenIn:\r\n    'The Ethereum contract address of the ERC20 token you want to send. Must be a valid Ethereum address starting with 0x.',\r\n  recipientAddress:\r\n    'The Ethereum wallet address of the recipient who will receive the tokens. Must be a valid Ethereum address starting with 0x.',\r\n  amountIn:\r\n    'The amount of tokens to send, specified as a string. This should be a decimal number (e.g. \"1.5\" or \"100\"). The amount will be automatically adjusted based on the token\\'s decimals.',\r\n  chainId:\r\n    'The ID of the blockchain network to send the tokens on (e.g. 1 for Ethereum mainnet, 84532 for Base Sepolia).',\r\n  rpcUrl:\r\n    'The RPC URL of the blockchain network to connect to (e.g. \"https://base-sepolia-rpc.publicnode.com\").',\r\n} as const;\r\n\r\n/**\r\n * Validates the provided parameters against the ERC20TransferLitActionSchema.\r\n * @param {unknown} params - The parameters to validate.\r\n * @returns {true | Array<{ param: string; error: string }>} - Returns `true` if valid, otherwise an array of errors.\r\n */\r\nconst validateERC20TransferParameters = (\r\n  params: unknown\r\n): true | Array<{ param: string; error: string }> => {\r\n  const result = ERC20TransferLitActionSchema.safeParse(params);\r\n  if (result.success) {\r\n    return true;\r\n  }\r\n\r\n  return result.error.issues.map((issue) => ({\r\n    param: issue.path[0] as string,\r\n    error: issue.message,\r\n  }));\r\n};\r\n\r\n/**\r\n * Creates a network-specific ERC20Transfer tool.\r\n * @param {SupportedLitNetwork} network - The Lit network to use.\r\n * @param {NetworkConfig} config - The configuration for the network.\r\n * @returns {AwTool<ERC20TransferLitActionParameters, ERC20TransferPolicyType>} - The configured AwTool instance.\r\n */\r\nconst createNetworkTool = (\r\n  network: SupportedLitNetwork,\r\n  config: NetworkConfig\r\n): AwTool<ERC20TransferLitActionParameters, ERC20TransferPolicyType> => ({\r\n  name: 'ERC20Transfer',\r\n  description: `A Lit Action that sends ERC-20 tokens.`,\r\n  ipfsCid: IPFS_CIDS[network].tool,\r\n  defaultPolicyIpfsCid: IPFS_CIDS[network].defaultPolicy,\r\n  parameters: {\r\n    type: {} as ERC20TransferLitActionParameters,\r\n    schema: ERC20TransferLitActionSchema,\r\n    descriptions: ERC20TransferLitActionParameterDescriptions,\r\n    validate: validateERC20TransferParameters,\r\n  },\r\n  policy: ERC20TransferPolicy,\r\n});\r\n\r\n/**\r\n * A collection of network-specific ERC20Transfer tools.\r\n * @type {Record<SupportedLitNetwork, AwTool<ERC20TransferLitActionParameters, ERC20TransferPolicyType>>}\r\n */\r\nexport const ERC20Transfer = Object.entries(NETWORK_CONFIGS).reduce(\r\n  (acc, [network, config]) => ({\r\n    ...acc,\r\n    [network]: createNetworkTool(network as SupportedLitNetwork, config),\r\n  }),\r\n  {} as Record<\r\n    SupportedLitNetwork,\r\n    AwTool<ERC20TransferLitActionParameters, ERC20TransferPolicyType>\r\n  >\r\n);\r\n","export const litWalletTransferTemplate = `\r\nYou are an AI assistant specialized in processing Lit Protocol wallet transfer requests. Your task is to extract specific information from user messages and format it into a structured JSON response.\r\n\r\nFirst, review the recent messages from the conversation:\r\n\r\n<recent_messages>\r\n{{recentMessages}}\r\n</recent_messages>\r\n\r\nYour goal is to extract the following information about the requested transfer:\r\n1. PKP Ethereum Address (must be a valid Ethereum address)\r\n2. RPC URL (must be a valid URL)\r\n3. Chain ID (must be a valid chain ID)\r\n4. Token Address (must be a valid Ethereum address or null for native token)\r\n5. Recipient Address (must be a valid Ethereum address)\r\n6. Amount to transfer (in tokens, without the symbol)\r\n\r\nBefore providing the final JSON output, show your reasoning process inside <analysis> tags. Follow these steps:\r\n\r\n1. Identify the relevant information from the user's message:\r\n   - Quote the part of the message mentioning the PKP Ethereum Address.\r\n   - Quote the part mentioning the RPC URL.\r\n   - Quote the part mentioning the Chain ID.\r\n   - Quote the part mentioning the Token Address.\r\n   - Quote the part mentioning the Recipient Address.\r\n   - Quote the part mentioning the Amount.\r\n\r\n2. Validate each piece of information:\r\n   - PKP Ethereum Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - RPC URL: Ensure it is a valid URL.\r\n   - Chain ID: Ensure it is a valid number.\r\n   - Token Address: Check that it starts with \"0x\" and count the number of characters (should be 42) or set to null for native token.\r\n   - Recipient Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - Amount: Attempt to convert the amount to a number to verify it's valid.\r\n\r\n3. If any information is missing or invalid, prepare an appropriate error message.\r\n\r\n4. If all information is valid, summarize your findings.\r\n\r\n5. Prepare the JSON structure based on your analysis.\r\n\r\nAfter your analysis, provide the final output in a JSON markdown block. All fields are required. The JSON should have this structure:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"pkpEthAddress\": string,\r\n    \"rpcUrl\": string,\r\n    \"chainId\": number,\r\n    \"tokenIn\": string | null,\r\n    \"recipientAddress\": string,\r\n    \"amountIn\": string\r\n}\r\n\\`\\`\\`\r\n\r\nNow, process the user's request and provide your response.\r\n`;\r\n\r\nexport const uniswapSwapTemplate = `\r\nYou are an AI assistant specialized in processing Uniswap swap requests using the Lit Protocol. Your task is to extract specific information from user messages and format it into a structured JSON response.\r\n\r\nFirst, review the recent messages from the conversation:\r\n\r\n<recent_messages>\r\n{{recentMessages}}\r\n</recent_messages>\r\n\r\nYour goal is to extract the following information about the requested swap:\r\n1. PKP Ethereum Address (must be a valid Ethereum address)\r\n2. RPC URL (must be a valid URL)\r\n3. Chain ID (must be a valid chain ID)\r\n4. Token In Address (must be a valid Ethereum address)\r\n5. Token Out Address (must be a valid Ethereum address)\r\n6. Amount In (in tokens, without the symbol)\r\n\r\nBefore providing the final JSON output, show your reasoning process inside <analysis> tags. Follow these steps:\r\n\r\n1. Identify the relevant information from the user's message:\r\n   - Quote the part of the message mentioning the PKP Ethereum Address.\r\n   - Quote the part mentioning the RPC URL.\r\n   - Quote the part mentioning the Chain ID.\r\n   - Quote the part mentioning the Token In Address.\r\n   - Quote the part mentioning the Token Out Address.\r\n   - Quote the part mentioning the Amount In.\r\n\r\n2. Validate each piece of information:\r\n   - PKP Ethereum Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - RPC URL: Ensure it is a valid URL.\r\n   - Chain ID: Ensure it is a valid number.\r\n   - Token In Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - Token Out Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - Amount In: Attempt to convert the amount to a number to verify it's valid.\r\n\r\n3. If any information is missing or invalid, prepare an appropriate error message.\r\n\r\n4. If all information is valid, summarize your findings.\r\n\r\n5. Prepare the JSON structure based on your analysis.\r\n\r\nAfter your analysis, provide the final output in a JSON markdown block. All fields are required. The JSON should have this structure:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"pkpEthAddress\": string,\r\n    \"rpcUrl\": string,\r\n    \"chainId\": number,\r\n    \"tokenIn\": string,\r\n    \"tokenOut\": string,\r\n    \"amountIn\": string\r\n}\r\n\\`\\`\\`\r\n\r\nNow, process the user's request and provide your response.\r\n`;\r\n\r\nexport const ecdsaSignTemplate = `\r\nYou are an AI assistant specialized in processing ECDSA signing requests using the Lit Protocol. Your task is to extract specific information from user messages and format it into a structured JSON response.\r\n\r\nFirst, review the recent messages from the conversation:\r\n\r\n<recent_messages>\r\n{{recentMessages}}\r\n</recent_messages>\r\n\r\nYour goal is to extract the following information about the requested signing:\r\n1. PKP Ethereum Address (must be a valid Ethereum address)\r\n2. Message (must be a valid string)\r\n\r\nBefore providing the final JSON output, show your reasoning process inside <analysis> tags. Follow these steps:\r\n\r\n1. Identify the relevant information from the user's message:\r\n   - Quote the part of the message mentioning the PKP Ethereum Address.\r\n   - Quote the part mentioning the Message.\r\n\r\n2. Validate each piece of information:\r\n   - PKP Ethereum Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - Message: Ensure it is a non-empty string.\r\n\r\n3. If any information is missing or invalid, prepare an appropriate error message.\r\n\r\n4. If all information is valid, summarize your findings.\r\n\r\n5. Prepare the JSON structure based on your analysis.\r\n\r\nAfter your analysis, provide the final output in a JSON markdown block. All fields are required. The JSON should have this structure:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"pkpEthAddress\": string,\r\n    \"message\": string\r\n}\r\n\\`\\`\\`\r\n\r\nNow, process the user's request and provide your response.\r\n`;\r\n","import { ethers } from 'ethers';\r\nimport {\r\n    Action,\r\n    composeContext,\r\n    generateObjectDeprecated,\r\n    HandlerCallback,\r\n    ModelClass,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    type State,\r\n} from \"@elizaos/core\";\r\nimport { LIT_NETWORK, LIT_ABILITY } from '@lit-protocol/constants';\r\nimport { ERC20Transfer } from \"./tool\";\r\nimport { litWalletTransferTemplate } from \"../../../templates\";\r\nimport { ERC20TransferPolicy } from './policy';\r\nimport { IPFS_CIDS } from './ipfs';\r\nimport LitJsSdk from '@lit-protocol/lit-node-client';\r\nimport {\r\n    LitActionResource,\r\n    createSiweMessage,\r\n    generateAuthSig,\r\n} from \"@lit-protocol/auth-helpers\";\r\n\r\nconst buildLitWalletTransferDetails = async (\r\n    state: State,\r\n    runtime: IAgentRuntime\r\n): Promise<{\r\n    pkpEthAddress: string;\r\n    rpcUrl: string;\r\n    chainId: string;\r\n    tokenIn: string;\r\n    recipientAddress: string;\r\n    amountIn: string;\r\n}> => {\r\n    const context = composeContext({\r\n        state,\r\n        template: litWalletTransferTemplate,\r\n    });\r\n\r\n    const transferDetails = (await generateObjectDeprecated({\r\n        runtime,\r\n        context,\r\n        modelClass: ModelClass.SMALL,\r\n    })) as {\r\n        pkpEthAddress: string;\r\n        rpcUrl: string;\r\n        chainId: number;\r\n        tokenIn: string;\r\n        recipientAddress: string;\r\n        amountIn: string;\r\n    };\r\n\r\n    return {\r\n        ...transferDetails,\r\n        chainId: transferDetails.chainId.toString()\r\n    };\r\n};\r\n\r\nexport const WALLET_TRANSFER_LIT_ACTION: Action = {\r\n    name: \"lit-wallet-transfer\",\r\n    similes: [\"Lit Wallet Transfer\", \"Lit Protocol Transfer\", \"Transfer tokens\"],\r\n    description: \"This interacts with Lit Protocol to execute a wallet transfer using the ERC20Transfer tool\",\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options?: any,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        try {\r\n            const transferDetails = await buildLitWalletTransferDetails(state, runtime);\r\n            \r\n            // Get the appropriate tool for the network\r\n            const tool = ERC20Transfer[LIT_NETWORK.DatilDev];\r\n            \r\n            // Validate the parameters\r\n            const validationResult = tool.parameters.validate(transferDetails);\r\n            if (validationResult !== true) {\r\n                const errors = validationResult.map(err => `${err.param}: ${err.error}`).join(', ');\r\n                throw new Error(`Invalid parameters: ${errors}`);\r\n            }\r\n\r\n            // Create and validate policy\r\n            const policy = {\r\n                type: \"ERC20Transfer\" as const,\r\n                version: ERC20TransferPolicy.version,\r\n                erc20Decimals: \"18\",\r\n                maxAmount: transferDetails.amountIn,\r\n                allowedTokens: [transferDetails.tokenIn],\r\n                allowedRecipients: [transferDetails.recipientAddress]\r\n            };\r\n\r\n            // Validate policy against schema\r\n            ERC20TransferPolicy.schema.parse(policy);\r\n\r\n            // Encode policy for execution\r\n            const encodedPolicy = ERC20TransferPolicy.encode(policy);\r\n\r\n            // Get IPFS CID for the network\r\n            const ipfsCid = IPFS_CIDS['datil-dev'].tool;\r\n\r\n            // Initialize Lit client\r\n            const litNodeClient = new LitJsSdk.LitNodeClient({\r\n                alertWhenUnauthorized: false,\r\n                litNetwork: LIT_NETWORK.DatilDev,\r\n                debug: false,\r\n            });\r\n            await litNodeClient.connect();\r\n\r\n            // Get wallet from private key\r\n            const wallet = new ethers.Wallet(runtime.getSetting(\"EVM_PRIVATE_KEY\"));\r\n\r\n            // Get session signatures\r\n            const sessionSigs = await litNodeClient.getSessionSigs({\r\n                chain: \"ethereum\",\r\n                expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\r\n                resourceAbilityRequests: [\r\n                    {\r\n                        resource: new LitActionResource(\"*\"),\r\n                        ability: LIT_ABILITY.LitActionExecution,\r\n                    },\r\n                ],\r\n                authNeededCallback: async ({ uri, expiration, resourceAbilityRequests }) => {\r\n                    const toSign = await createSiweMessage({\r\n                        uri,\r\n                        expiration,\r\n                        resources: resourceAbilityRequests,\r\n                        walletAddress: wallet.address,\r\n                        nonce: await litNodeClient.getLatestBlockhash(),\r\n                        litNodeClient,\r\n                    });\r\n\r\n                    return await generateAuthSig({\r\n                        signer: wallet,\r\n                        toSign,\r\n                    });\r\n                },\r\n            });\r\n            \r\n            // Execute the Lit Action\r\n            const response = await litNodeClient.executeJs({\r\n                sessionSigs,\r\n                ipfsId: ipfsCid,\r\n                jsParams: {\r\n                    params: {\r\n                        ...transferDetails,\r\n                        encodedPolicy\r\n                    }\r\n                },\r\n            });\r\n\r\n            console.log(\"ERC20Transfer Response:\", response);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `Token transfer executed successfully. Response: ${JSON.stringify(response)}`,\r\n                    content: {\r\n                        success: true,\r\n                        response: response,\r\n                    },\r\n                });\r\n            }\r\n\r\n            return true;\r\n\r\n        } catch (error) {\r\n            console.error(\"Error in ERC20Transfer handler:\", error);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error executing token transfer: ${error.message}`,\r\n                    content: {\r\n                        error: error.message,\r\n                    },\r\n                });\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"please attempt a lit wallet transfer pkp addy: 0xc8BB61FB32cbfDc0534136798099709d779086b4 rpc: https://base-sepolia-rpc.publicnode.com chain ID 84532 token address 0x00cdfea7e11187BEB4a0CE835fea1745b124B26e sending 1 token to 0xDFdC570ec0586D5c00735a2277c21Dcc254B3917\" },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: { text: \"Executing ERC20 token transfer\", action: \"WALLET_TRANSFER_LIT_ACTION\" },\r\n            },\r\n        ],\r\n    ],\r\n};\r\n","import { z } from 'zod';\r\nimport { ethers } from 'ethers';\r\n\r\n/**\r\n * Schema for validating a SignEcdsa policy.\r\n * Ensures the policy has the correct structure and valid values.\r\n */\r\nconst policySchema = z.object({\r\n  /** The type of policy, must be `SignEcdsa`. */\r\n  type: z.literal('SignEcdsa'),\r\n\r\n  /** The version of the policy. */\r\n  version: z.string(),\r\n\r\n  /** An array of allowed message prefixes. */\r\n  allowedPrefixes: z.array(z.string()),\r\n});\r\n\r\n/**\r\n * Encodes a SignEcdsa policy into a format suitable for on-chain storage.\r\n * @param policy - The SignEcdsa policy to encode.\r\n * @returns The encoded policy as a hex string.\r\n * @throws If the policy does not conform to the schema.\r\n */\r\nfunction encodePolicy(policy: SignEcdsaPolicyType): string {\r\n  // Validate the policy against the schema\r\n  policySchema.parse(policy);\r\n\r\n  // Encode the policy using ABI encoding\r\n  return ethers.utils.defaultAbiCoder.encode(\r\n    ['tuple(string[] allowedPrefixes)'],\r\n    [\r\n      {\r\n        allowedPrefixes: policy.allowedPrefixes,\r\n      },\r\n    ]\r\n  );\r\n}\r\n\r\n/**\r\n * Decodes a SignEcdsa policy from its on-chain encoded format.\r\n * @param encodedPolicy - The encoded policy as a hex string.\r\n * @returns The decoded SignEcdsa policy.\r\n * @throws If the encoded policy is invalid or does not conform to the schema.\r\n */\r\nfunction decodePolicy(encodedPolicy: string): SignEcdsaPolicyType {\r\n  // Decode the policy using ABI decoding\r\n  const decoded = ethers.utils.defaultAbiCoder.decode(\r\n    ['tuple(string[] allowedPrefixes)'],\r\n    encodedPolicy\r\n  )[0];\r\n\r\n  // Construct the policy object\r\n  const policy: SignEcdsaPolicyType = {\r\n    type: 'SignEcdsa',\r\n    version: '1.0.0',\r\n    allowedPrefixes: decoded.allowedPrefixes,\r\n  };\r\n\r\n  // Validate the decoded policy against the schema\r\n  return policySchema.parse(policy);\r\n}\r\n\r\n/**\r\n * Represents the type of a SignEcdsa policy, inferred from the schema.\r\n */\r\nexport type SignEcdsaPolicyType = z.infer<typeof policySchema>;\r\n\r\n/**\r\n * Utility object for working with SignEcdsa policies.\r\n * Includes the schema, encoding, and decoding functions.\r\n */\r\nexport const SignEcdsaPolicy = {\r\n  /** The type of the policy. */\r\n  type: {} as SignEcdsaPolicyType,\r\n\r\n  /** The version of the policy. */\r\n  version: '1.0.0',\r\n\r\n  /** The schema for validating SignEcdsa policies. */\r\n  schema: policySchema,\r\n\r\n  /** Encodes a SignEcdsa policy into a format suitable for on-chain storage. */\r\n  encode: encodePolicy,\r\n\r\n  /** Decodes a SignEcdsa policy from its on-chain encoded format. */\r\n  decode: decodePolicy,\r\n};\r\n","import { fileURLToPath } from 'url';\r\nimport { dirname, join } from 'path';\r\nimport { existsSync } from 'fs';\r\n\r\n// Define __dirname using import.meta.url\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\n\r\n/**\r\n * Default development CIDs for different environments.\r\n * @type {Object.<string, NetworkCids>}\r\n * @property {NetworkCids} datil-dev - CIDs for the development environment.\r\n * @property {NetworkCids} datil-test - CIDs for the test environment.\r\n * @property {NetworkCids} datil - CIDs for the production environment.\r\n */\r\nconst DEFAULT_CIDS = {\r\n  'datil-dev': {\r\n    tool: 'QmZJovPgBBBmuLKRtdVwdV47opNSmLiV2AZCNTtWzeog1Q',\r\n    defaultPolicy: 'QmPaViiSPUVViC2VkTn3PiRWpkqxnh44BxNY8TcHsuTpJi',\r\n  },\r\n  'datil-test': {\r\n    tool: 'QmZbVUwomfUfCa38ia69LrSfH1k8JNK3BHeSUKm5tGMWgv',\r\n    defaultPolicy: 'QmPaViiSPUVViC2VkTn3PiRWpkqxnh44BxNY8TcHsuTpJi',\r\n  },\r\n  datil: {\r\n    tool: 'QmPjxnXWSPYGYR2gZyiZHpRE7dMAeb7K181R4Cfvkw5KM8',\r\n    defaultPolicy: 'QmPaViiSPUVViC2VkTn3PiRWpkqxnh44BxNY8TcHsuTpJi',\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Tries to read the IPFS CIDs from the build output.\r\n * Falls back to default development CIDs if the file is not found or cannot be read.\r\n * @type {Record<keyof typeof DEFAULT_CIDS, NetworkCids>}\r\n */\r\nlet deployedCids = DEFAULT_CIDS;\r\n\r\nconst ipfsPath = join(__dirname, '../../../dist/ipfs.json');\r\nif (existsSync(ipfsPath)) {\r\n  try {\r\n    // Use dynamic import to load the JSON file\r\n    const ipfsModule = await import(ipfsPath, {\r\n      assert: { type: 'json' }\r\n    });\r\n    deployedCids = ipfsModule.default;\r\n  } catch (error) {\r\n    console.warn('Failed to load ipfs.json, using default CIDs:', error);\r\n  }\r\n} else {\r\n  console.warn(\r\n    'ipfs.json not found. Using default CIDs. You should run `npx nx deploy:lit-action` to update the ipfs.json files.'\r\n  );\r\n}\r\n\r\n/**\r\n * IPFS CIDs for each network's Lit Action.\r\n * @type {Record<keyof typeof DEFAULT_CIDS, NetworkCids>}\r\n */\r\nexport const IPFS_CIDS = deployedCids;\r\n","import { z } from 'zod';\r\nimport {\r\n  type AwTool,\r\n  type SupportedLitNetwork,\r\n  NETWORK_CONFIGS,\r\n  NetworkConfig,\r\n} from '@lit-protocol/aw-tool';\r\n\r\nimport { SignEcdsaPolicy, type SignEcdsaPolicyType } from './policy';\r\nimport { IPFS_CIDS } from './ipfs';\r\n\r\n/**\r\n * Parameters required for the Signing ECDSA Lit Action.\r\n * @property {string} pkpEthAddress - The Ethereum address of the PKP.\r\n * @property message - The message to sign.\r\n */\r\nexport interface SignEcdsaLitActionParameters {\r\n  pkpEthAddress: string;\r\n  message: string;\r\n}\r\n\r\n/**\r\n * Zod schema for validating `SignEcdsaLitActionParameters`.\r\n * Ensures that the message is a valid string.\r\n */\r\nconst SignEcdsaLitActionSchema = z.object({\r\n  pkpEthAddress: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  message: z.string(),\r\n});\r\n\r\n/**\r\n * Descriptions of each parameter for the Signing ECDSA Lit Action.\r\n * These descriptions are designed to be consumed by LLMs (Language Learning Models) to understand the required parameters.\r\n */\r\nconst SignEcdsaLitActionParameterDescriptions = {\r\n  pkpEthAddress:\r\n    'The Ethereum address of the PKP that will be used to sign the message.',\r\n  message: 'The message you want to sign.',\r\n} as const;\r\n\r\n/**\r\n * Validates the parameters for the Signing ECDSA Lit Action.\r\n * @param params - The parameters to validate.\r\n * @returns `true` if the parameters are valid, or an array of errors if invalid.\r\n */\r\nconst validateSignEcdsaParameters = (\r\n  params: unknown\r\n): true | Array<{ param: string; error: string }> => {\r\n  const result = SignEcdsaLitActionSchema.safeParse(params);\r\n  if (result.success) {\r\n    return true;\r\n  }\r\n\r\n  // Map validation errors to a more user-friendly format\r\n  return result.error.issues.map((issue) => ({\r\n    param: issue.path[0] as string,\r\n    error: issue.message,\r\n  }));\r\n};\r\n\r\n/**\r\n * Creates a network-specific SignEcdsa tool.\r\n * @param network - The supported Lit network (e.g., `datil-dev`, `datil-test`, `datil`).\r\n * @param config - The network configuration.\r\n * @returns A configured `AwTool` instance for the Signing ECDSA Lit Action.\r\n */\r\nconst createNetworkTool = (\r\n  network: SupportedLitNetwork,\r\n  config: NetworkConfig\r\n): AwTool<SignEcdsaLitActionParameters, SignEcdsaPolicyType> => ({\r\n  name: 'SignEcdsa',\r\n  description: `A Lit Action that signs a message with an allowlist of message prefixes.`,\r\n  ipfsCid: IPFS_CIDS[network].tool,\r\n  defaultPolicyIpfsCid: IPFS_CIDS[network].defaultPolicy,\r\n  parameters: {\r\n    type: {} as SignEcdsaLitActionParameters,\r\n    schema: SignEcdsaLitActionSchema,\r\n    descriptions: SignEcdsaLitActionParameterDescriptions,\r\n    validate: validateSignEcdsaParameters,\r\n  },\r\n  policy: SignEcdsaPolicy,\r\n});\r\n\r\n/**\r\n * Exports network-specific SignEcdsa tools.\r\n * Each tool is configured for a specific Lit network (e.g., `datil-dev`, `datil-test`, `datil`).\r\n */\r\nexport const SignEcdsa = Object.entries(NETWORK_CONFIGS).reduce(\r\n  (acc, [network, config]) => ({\r\n    ...acc,\r\n    [network]: createNetworkTool(network as SupportedLitNetwork, config),\r\n  }),\r\n  {} as Record<\r\n    SupportedLitNetwork,\r\n    AwTool<SignEcdsaLitActionParameters, SignEcdsaPolicyType>\r\n  >\r\n);\r\n","import { ethers } from 'ethers';\r\nimport {\r\n  Action,\r\n  composeContext,\r\n  generateObjectDeprecated,\r\n  HandlerCallback,\r\n  ModelClass,\r\n  type IAgentRuntime,\r\n  type Memory,\r\n  type State,\r\n} from \"@elizaos/core\";\r\nimport { LIT_NETWORK, LIT_ABILITY } from '@lit-protocol/constants';\r\nimport { SignEcdsa, SignEcdsaLitActionParameters } from \"./tool\"; // Import the SignEcdsa tool\r\nimport { ecdsaSignTemplate } from \"../../../templates\"; // Assuming you have a template for ECDSA signing\r\nimport { SignEcdsaPolicy } from './policy';\r\nimport { IPFS_CIDS } from './ipfs';\r\nimport LitJsSdk from '@lit-protocol/lit-node-client';\r\nimport {\r\n  LitActionResource,\r\n  createSiweMessage,\r\n  generateAuthSig,\r\n} from \"@lit-protocol/auth-helpers\";\r\n\r\n/**\r\n * Builds the details required for an ECDSA signing Lit Action.\r\n * @param {State} state - The current state of the agent.\r\n * @param {IAgentRuntime} runtime - The runtime instance of the agent.\r\n * @returns {Promise<SignEcdsaLitActionParameters>} - The parameters for the ECDSA signing.\r\n */\r\nconst buildEcdsaSignDetails = async (\r\n  state: State,\r\n  runtime: IAgentRuntime\r\n): Promise<SignEcdsaLitActionParameters> => {\r\n  const context = composeContext({\r\n    state,\r\n    template: ecdsaSignTemplate, // Use the ECDSA signing template\r\n  });\r\n\r\n  const signDetails = (await generateObjectDeprecated({\r\n    runtime,\r\n    context,\r\n    modelClass: ModelClass.SMALL,\r\n  })) as SignEcdsaLitActionParameters;\r\n\r\n  return signDetails;\r\n};\r\n\r\n/**\r\n * Action for executing an ECDSA signing using the Lit Protocol.\r\n */\r\nexport const ECDSA_SIGN_LIT_ACTION: Action = {\r\n  name: \"ecdsa-sign\",\r\n  similes: [\"ECDSA Sign\", \"Sign Message\", \"Execute ECDSA Sign\"],\r\n  description: \"This interacts with Lit Protocol to sign a message using the SignEcdsa tool.\",\r\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n    const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n    return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n  },\r\n  handler: async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State,\r\n    options?: any,\r\n    callback?: HandlerCallback\r\n  ) => {\r\n    try {\r\n      const signDetails = await buildEcdsaSignDetails(state, runtime);\r\n\r\n      // Get the appropriate tool for the network\r\n      const tool = SignEcdsa[LIT_NETWORK.DatilDev]; // Assuming you're using the DatilDev network\r\n\r\n      // Validate the parameters\r\n      const validationResult = tool.parameters.validate(signDetails);\r\n      if (validationResult !== true) {\r\n        const errors = validationResult.map(err => `${err.param}: ${err.error}`).join(', ');\r\n        throw new Error(`Invalid parameters: ${errors}`);\r\n      }\r\n\r\n      // Create and validate policy\r\n      const policy = {\r\n        type: \"SignEcdsa\" as const,\r\n        version: SignEcdsaPolicy.version,\r\n        allowedMessages: [signDetails.message], // Allow only the specific message to be signed\r\n      };\r\n\r\n      // Validate policy against schema\r\n      SignEcdsaPolicy.schema.parse(policy);\r\n\r\n      // Encode policy for execution\r\n      const encodedPolicy = SignEcdsaPolicy.encode(policy);\r\n\r\n      // Get IPFS CID for the network\r\n      const ipfsCid = IPFS_CIDS['datil-dev'].tool;\r\n\r\n      // Initialize Lit client\r\n      const litNodeClient = new LitJsSdk.LitNodeClient({\r\n        alertWhenUnauthorized: false,\r\n        litNetwork: LIT_NETWORK.DatilDev,\r\n        debug: false,\r\n      });\r\n      await litNodeClient.connect();\r\n\r\n      // Get wallet from private key\r\n      const wallet = new ethers.Wallet(runtime.getSetting(\"EVM_PRIVATE_KEY\"));\r\n\r\n      // Get session signatures\r\n      const sessionSigs = await litNodeClient.getSessionSigs({\r\n        chain: \"ethereum\",\r\n        expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\r\n        resourceAbilityRequests: [\r\n          {\r\n            resource: new LitActionResource(\"*\"),\r\n            ability: LIT_ABILITY.LitActionExecution,\r\n          },\r\n        ],\r\n        authNeededCallback: async ({ uri, expiration, resourceAbilityRequests }) => {\r\n          const toSign = await createSiweMessage({\r\n            uri,\r\n            expiration,\r\n            resources: resourceAbilityRequests,\r\n            walletAddress: wallet.address,\r\n            nonce: await litNodeClient.getLatestBlockhash(),\r\n            litNodeClient,\r\n          });\r\n\r\n          return await generateAuthSig({\r\n            signer: wallet,\r\n            toSign,\r\n          });\r\n        },\r\n      });\r\n\r\n      // Execute the Lit Action\r\n      const response = await litNodeClient.executeJs({\r\n        sessionSigs,\r\n        ipfsId: ipfsCid,\r\n        jsParams: {\r\n          params: {\r\n            ...signDetails,\r\n            encodedPolicy,\r\n          },\r\n        },\r\n      });\r\n\r\n      console.log(\"ECDSA Sign Response:\", response);\r\n\r\n      if (callback) {\r\n        callback({\r\n          text: `Message signed successfully. Response: ${JSON.stringify(response)}`,\r\n          content: {\r\n            success: true,\r\n            response: response,\r\n          },\r\n        });\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(\"Error in ECDSA Sign handler:\", error);\r\n\r\n      if (callback) {\r\n        callback({\r\n          text: `Error signing message: ${error.message}`,\r\n          content: {\r\n            error: error.message,\r\n          },\r\n        });\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  },\r\n  examples: [\r\n    [\r\n      {\r\n        user: \"{{user1}}\",\r\n        content: { text: \"please sign the message 'Hello, world!' with PKP address 0xc8BB61FB32cbfDc0534136798099709d779086b4\" },\r\n      },\r\n      {\r\n        user: \"{{user2}}\",\r\n        content: { text: \"Executing ECDSA sign\", action: \"ECDSA_SIGN_LIT_ACTION\" },\r\n      },\r\n    ],\r\n  ],\r\n};\r\n","import { BaseEthereumAddressSchema } from '@lit-protocol/aw-tool';\r\nimport { z } from 'zod';\r\nimport { ethers } from 'ethers';\r\n\r\n/**\r\n * Zod schema for validating a UniswapSwap policy.\r\n * @type {z.ZodObject}\r\n */\r\nconst policySchema = z.object({\r\n  type: z.literal('UniswapSwap'), // Policy type must be 'UniswapSwap'\r\n  version: z.string(), // Version of the policy\r\n  maxAmount: z.string().refine(\r\n    (val) => {\r\n      try {\r\n        const bn = ethers.BigNumber.from(val);\r\n        return !bn.isNegative(); // Ensure the amount is non-negative\r\n      } catch {\r\n        return false; // Invalid format\r\n      }\r\n    },\r\n    { message: 'Invalid amount format. Must be a non-negative integer.' }\r\n  ),\r\n  allowedTokens: z.array(BaseEthereumAddressSchema), // Array of allowed token addresses\r\n});\r\n\r\n/**\r\n * Encodes a UniswapSwap policy into a packed ABI-encoded string.\r\n * @param {UniswapSwapPolicyType} policy - The policy to encode.\r\n * @returns {string} ABI-encoded string representing the policy.\r\n * @throws {z.ZodError} If the policy does not match the schema.\r\n */\r\nfunction encodePolicy(policy: UniswapSwapPolicyType): string {\r\n  // Validate the policy against the schema\r\n  policySchema.parse(policy);\r\n\r\n  // Encode the policy using ABI encoding\r\n  return ethers.utils.defaultAbiCoder.encode(\r\n    ['tuple(uint256 maxAmount, address[] allowedTokens)'],\r\n    [\r\n      {\r\n        maxAmount: policy.maxAmount,\r\n        allowedTokens: policy.allowedTokens,\r\n      },\r\n    ]\r\n  );\r\n}\r\n\r\n/**\r\n * Decodes an ABI-encoded string into a UniswapSwap policy.\r\n * @param {string} encodedPolicy - The ABI-encoded policy string.\r\n * @returns {UniswapSwapPolicyType} The decoded policy object.\r\n * @throws {z.ZodError} If the decoded policy does not match the schema.\r\n */\r\nfunction decodePolicy(encodedPolicy: string): UniswapSwapPolicyType {\r\n  // Decode the ABI-encoded string\r\n  const decoded = ethers.utils.defaultAbiCoder.decode(\r\n    ['tuple(uint256 maxAmount, address[] allowedTokens)'],\r\n    encodedPolicy\r\n  )[0];\r\n\r\n  // Construct the policy object\r\n  const policy: UniswapSwapPolicyType = {\r\n    type: 'UniswapSwap',\r\n    version: '1.0.0',\r\n    maxAmount: decoded.maxAmount.toString(),\r\n    allowedTokens: decoded.allowedTokens,\r\n  };\r\n\r\n  // Validate the decoded policy against the schema\r\n  return policySchema.parse(policy);\r\n}\r\n\r\n/**\r\n * Type representing a UniswapSwap policy.\r\n * @typedef {z.infer<typeof policySchema>} UniswapSwapPolicyType\r\n */\r\nexport type UniswapSwapPolicyType = z.infer<typeof policySchema>;\r\n\r\n/**\r\n * Utility object for working with UniswapSwap policies.\r\n * @type {object}\r\n * @property {UniswapSwapPolicyType} type - Type placeholder for the policy.\r\n * @property {string} version - Version of the policy schema.\r\n * @property {z.ZodObject} schema - Zod schema for validating policies.\r\n * @property {function} encode - Function to encode a policy into an ABI-encoded string.\r\n * @property {function} decode - Function to decode an ABI-encoded string into a policy.\r\n */\r\nexport const UniswapSwapPolicy = {\r\n  type: {} as UniswapSwapPolicyType, // Placeholder for the policy type\r\n  version: '1.0.0', // Version of the policy schema\r\n  schema: policySchema, // Zod schema for validation\r\n  encode: encodePolicy, // Function to encode a policy\r\n  decode: decodePolicy, // Function to decode a policy\r\n};\r\n","import { fileURLToPath } from 'url';\r\nimport { dirname, join } from 'path';\r\nimport { existsSync } from 'fs';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\n\r\n/**\r\n * Default development CIDs for different environments.\r\n * @type {Object.<string, NetworkCids>}\r\n * @property {NetworkCids} datil-dev - CIDs for the development environment.\r\n * @property {NetworkCids} datil-test - CIDs for the test environment.\r\n * @property {NetworkCids} datil - CIDs for the production environment.\r\n */\r\nconst DEFAULT_CIDS = {\r\n  'datil-dev': {\r\n    tool: 'QmQPUjXmFiAe363TYAiv3DPciyTDSFLym2S9FR1d78ZRWs',\r\n    defaultPolicy: 'Qmc6RAbV3WAqfNLvkAxp4hYjd4TDim4PwjWyhGbM9X7nbR',\r\n  },\r\n  'datil-test': {\r\n    tool: 'QmaLAZCJEk5B4BW962pjENxCDHvwGtPptCamhckk9GJxJe',\r\n    defaultPolicy: 'Qmc6RAbV3WAqfNLvkAxp4hYjd4TDim4PwjWyhGbM9X7nbR',\r\n  },\r\n  datil: {\r\n    tool: 'QmStLtPzAvyUAQXbkUorZUJ7mgst6tU4xhJoFYHMZp9etH',\r\n    defaultPolicy: 'Qmc6RAbV3WAqfNLvkAxp4hYjd4TDim4PwjWyhGbM9X7nbR',\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Tries to read the IPFS CIDs from the build output.\r\n * Falls back to default development CIDs if the file is not found or cannot be read.\r\n * @type {Record<keyof typeof DEFAULT_CIDS, NetworkCids>}\r\n */\r\nlet deployedCids = DEFAULT_CIDS;\r\n\r\nconst ipfsPath = join(__dirname, '../../../dist/ipfs.json');\r\nif (existsSync(ipfsPath)) {\r\n  try {\r\n    const ipfsModule = await import(ipfsPath, {\r\n      assert: { type: 'json' }\r\n    });\r\n    deployedCids = ipfsModule.default;\r\n  } catch (error) {\r\n    console.warn('Failed to load ipfs.json, using default CIDs:', error);\r\n  }\r\n} else {\r\n  console.warn(\r\n    'ipfs.json not found. Using default CIDs. You should run `npx nx deploy:lit-action` to update the ipfs.json files.'\r\n  );\r\n}\r\n\r\n/**\r\n * IPFS CIDs for each network's Lit Action.\r\n * @type {Record<keyof typeof DEFAULT_CIDS, NetworkCids>}\r\n */\r\nexport const IPFS_CIDS = deployedCids;\r\n","import { z } from 'zod';\r\nimport {\r\n  type AwTool,\r\n  type SupportedLitNetwork,\r\n  NETWORK_CONFIGS,\r\n  NetworkConfig,\r\n} from '@lit-protocol/aw-tool';\r\n\r\nimport { UniswapSwapPolicy, type UniswapSwapPolicyType } from './policy';\r\nimport { IPFS_CIDS } from './ipfs';\r\n\r\n/**\r\n * Parameters required for the Swap Uniswap Lit Action.\r\n * @property {string} tokenIn - The ERC20 token contract address to send.\r\n * @property {string} tokenOut - The ERC20 token contract address to receive.\r\n * @property {string} amountIn - The amount of tokens to send as a string (will be parsed based on token decimals).\r\n * @property {string} chainId - The ID of the blockchain network.\r\n * @property {string} rpcUrl - The RPC URL of the blockchain network.\r\n */\r\nexport interface UniswapSwapLitActionParameters {\r\n  pkpEthAddress: string;\r\n  tokenIn: string;\r\n  tokenOut: string;\r\n  amountIn: string;\r\n  chainId: string;\r\n  rpcUrl: string;\r\n}\r\n\r\n/**\r\n * Zod schema for validating UniswapSwapLitActionParameters.\r\n * @type {z.ZodObject}\r\n */\r\nconst UniswapSwapLitActionSchema = z.object({\r\n  pkpEthAddress: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  tokenIn: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum contract address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  tokenOut: z\r\n    .string()\r\n    .regex(\r\n      /^0x[a-fA-F0-9]{40}$/,\r\n      'Must be a valid Ethereum contract address (0x followed by 40 hexadecimal characters)'\r\n    ),\r\n  amountIn: z\r\n    .string()\r\n    .regex(\r\n      /^\\d*\\.?\\d+$/,\r\n      'Must be a valid decimal number as a string (e.g. \"1.5\" or \"100\")'\r\n    ),\r\n  chainId: z\r\n    .string()\r\n    .regex(/^\\d+$/, 'Must be a valid chain ID number as a string'),\r\n  rpcUrl: z\r\n    .string()\r\n    .url()\r\n    .startsWith(\r\n      'https://',\r\n      'Must be a valid HTTPS URL for the blockchain RPC endpoint'\r\n    ),\r\n});\r\n\r\n/**\r\n * Descriptions of each parameter for the Swap Uniswap Lit Action.\r\n * These descriptions are designed to be consumed by LLMs to understand the required parameters.\r\n * @type {Record<string, string>}\r\n */\r\nconst UniswapSwapLitActionParameterDescriptions = {\r\n  pkpEthAddress:\r\n    'The Ethereum address of the PKP that will be used to sign the transaction.',\r\n  tokenIn:\r\n    'The Ethereum contract address of the ERC20 token you want to send. Must be a valid Ethereum address starting with 0x.',\r\n  tokenOut:\r\n    'The Ethereum contract address of the ERC20 token you want to receive. Must be a valid Ethereum address starting with 0x.',\r\n  amountIn:\r\n    'The amount of tokens to send, specified as a string. This should be a decimal number (e.g. \"1.5\" or \"100\"). The amount will be automatically adjusted based on the token\\'s decimals.',\r\n  chainId:\r\n    'The ID of the blockchain network to send the tokens on (e.g. 1 for Ethereum mainnet, 84532 for Base Sepolia).',\r\n  rpcUrl:\r\n    'The RPC URL of the blockchain network to connect to (e.g. \"https://base-sepolia-rpc.publicnode.com\").',\r\n} as const;\r\n\r\n/**\r\n * Validates the provided parameters against the UniswapSwapLitActionSchema.\r\n * @param {unknown} params - The parameters to validate.\r\n * @returns {true | Array<{ param: string; error: string }>} - Returns `true` if valid, otherwise an array of errors.\r\n */\r\nconst validateUniswapSwapParameters = (\r\n  params: unknown\r\n): true | Array<{ param: string; error: string }> => {\r\n  const result = UniswapSwapLitActionSchema.safeParse(params);\r\n  if (result.success) {\r\n    return true;\r\n  }\r\n\r\n  return result.error.issues.map((issue) => ({\r\n    param: issue.path[0] as string,\r\n    error: issue.message,\r\n  }));\r\n};\r\n\r\n/**\r\n * Creates a network-specific UniswapSwap tool.\r\n * @param {SupportedLitNetwork} network - The Lit network to use.\r\n * @param {NetworkConfig} config - The configuration for the network.\r\n * @returns {AwTool<UniswapSwapLitActionParameters, UniswapSwapPolicyType>} - The configured AwTool instance.\r\n */\r\nconst createNetworkTool = (\r\n  network: SupportedLitNetwork,\r\n  config: NetworkConfig\r\n): AwTool<UniswapSwapLitActionParameters, UniswapSwapPolicyType> => ({\r\n  name: 'UniswapSwap',\r\n  description: `A Lit Action that swaps tokens on Uniswap.`,\r\n  ipfsCid: IPFS_CIDS[network].tool,\r\n  defaultPolicyIpfsCid: IPFS_CIDS[network].defaultPolicy,\r\n  parameters: {\r\n    type: {} as UniswapSwapLitActionParameters,\r\n    schema: UniswapSwapLitActionSchema,\r\n    descriptions: UniswapSwapLitActionParameterDescriptions,\r\n    validate: validateUniswapSwapParameters,\r\n  },\r\n  policy: UniswapSwapPolicy,\r\n});\r\n\r\n/**\r\n * A collection of network-specific UniswapSwap tools.\r\n * @type {Record<SupportedLitNetwork, AwTool<UniswapSwapLitActionParameters, UniswapSwapPolicyType>>}\r\n */\r\nexport const UniswapSwap = Object.entries(NETWORK_CONFIGS).reduce(\r\n  (acc, [network, config]) => ({\r\n    ...acc,\r\n    [network]: createNetworkTool(network as SupportedLitNetwork, config),\r\n  }),\r\n  {} as Record<\r\n    SupportedLitNetwork,\r\n    AwTool<UniswapSwapLitActionParameters, UniswapSwapPolicyType>\r\n  >\r\n);\r\n","import { ethers } from 'ethers';\r\nimport {\r\n  Action,\r\n  composeContext,\r\n  generateObjectDeprecated,\r\n  HandlerCallback,\r\n  ModelClass,\r\n  type IAgentRuntime,\r\n  type Memory,\r\n  type State,\r\n} from \"@elizaos/core\";\r\nimport { LIT_NETWORK, LIT_ABILITY } from '@lit-protocol/constants';\r\nimport { UniswapSwap, UniswapSwapLitActionParameters } from \"./tool\"; // Import the UniswapSwap tool\r\nimport { uniswapSwapTemplate } from \"../../../templates\"; // Assuming you have a template for Uniswap swaps\r\nimport { UniswapSwapPolicy } from './policy';\r\nimport { IPFS_CIDS } from './ipfs';\r\nimport LitJsSdk from '@lit-protocol/lit-node-client';\r\nimport {\r\n  LitActionResource,\r\n  createSiweMessage,\r\n  generateAuthSig,\r\n} from \"@lit-protocol/auth-helpers\";\r\n\r\n/**\r\n * Builds the details required for a Uniswap swap Lit Action.\r\n * @param {State} state - The current state of the agent.\r\n * @param {IAgentRuntime} runtime - The runtime instance of the agent.\r\n * @returns {Promise<UniswapSwapLitActionParameters>} - The parameters for the Uniswap swap.\r\n */\r\nconst buildUniswapSwapDetails = async (\r\n  state: State,\r\n  runtime: IAgentRuntime\r\n): Promise<UniswapSwapLitActionParameters> => {\r\n  const context = composeContext({\r\n    state,\r\n    template: uniswapSwapTemplate, // Use the Uniswap swap template\r\n  });\r\n\r\n  const swapDetails = (await generateObjectDeprecated({\r\n    runtime,\r\n    context,\r\n    modelClass: ModelClass.SMALL,\r\n  })) as UniswapSwapLitActionParameters;\r\n\r\n  return swapDetails;\r\n};\r\n\r\n/**\r\n * Action for executing a Uniswap swap using the Lit Protocol.\r\n */\r\nexport const UNISWAP_SWAP_LIT_ACTION: Action = {\r\n  name: \"uniswap-swap\",\r\n  similes: [\"Uniswap Swap\", \"Swap Tokens\", \"Execute Uniswap Swap\"],\r\n  description: \"This interacts with Lit Protocol to execute a Uniswap swap using the UniswapSwap tool.\",\r\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n    const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n    return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n  },\r\n  handler: async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State,\r\n    options?: any,\r\n    callback?: HandlerCallback\r\n  ) => {\r\n    try {\r\n      const swapDetails = await buildUniswapSwapDetails(state, runtime);\r\n\r\n      // Get the appropriate tool for the network\r\n      const tool = UniswapSwap[LIT_NETWORK.DatilDev]; // Assuming you're using the DatilDev network\r\n\r\n      // Validate the parameters\r\n      const validationResult = tool.parameters.validate(swapDetails);\r\n      if (validationResult !== true) {\r\n        const errors = validationResult.map(err => `${err.param}: ${err.error}`).join(', ');\r\n        throw new Error(`Invalid parameters: ${errors}`);\r\n      }\r\n\r\n      // Create and validate policy\r\n      const policy = {\r\n        type: \"UniswapSwap\" as const,\r\n        version: UniswapSwapPolicy.version,\r\n        tokenIn: swapDetails.tokenIn,\r\n        tokenOut: swapDetails.tokenOut,\r\n        amountIn: swapDetails.amountIn,\r\n        maxSlippage: \"0.5\", // Example slippage tolerance (0.5%)\r\n      };\r\n\r\n      // Validate policy against schema\r\n      UniswapSwapPolicy.schema.parse(policy);\r\n\r\n      // Encode policy for execution\r\n      const encodedPolicy = UniswapSwapPolicy.encode(policy);\r\n\r\n      // Get IPFS CID for the network\r\n      const ipfsCid = IPFS_CIDS['datil-dev'].tool;\r\n\r\n      // Initialize Lit client\r\n      const litNodeClient = new LitJsSdk.LitNodeClient({\r\n        alertWhenUnauthorized: false,\r\n        litNetwork: LIT_NETWORK.DatilDev,\r\n        debug: false,\r\n      });\r\n      await litNodeClient.connect();\r\n\r\n      // Get wallet from private key\r\n      const wallet = new ethers.Wallet(runtime.getSetting(\"EVM_PRIVATE_KEY\"));\r\n\r\n      // Get session signatures\r\n      const sessionSigs = await litNodeClient.getSessionSigs({\r\n        chain: \"ethereum\",\r\n        expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes\r\n        resourceAbilityRequests: [\r\n          {\r\n            resource: new LitActionResource(\"*\"),\r\n            ability: LIT_ABILITY.LitActionExecution,\r\n          },\r\n        ],\r\n        authNeededCallback: async ({ uri, expiration, resourceAbilityRequests }) => {\r\n          const toSign = await createSiweMessage({\r\n            uri,\r\n            expiration,\r\n            resources: resourceAbilityRequests,\r\n            walletAddress: wallet.address,\r\n            nonce: await litNodeClient.getLatestBlockhash(),\r\n            litNodeClient,\r\n          });\r\n\r\n          return await generateAuthSig({\r\n            signer: wallet,\r\n            toSign,\r\n          });\r\n        },\r\n      });\r\n\r\n      // Execute the Lit Action\r\n      const response = await litNodeClient.executeJs({\r\n        sessionSigs,\r\n        ipfsId: ipfsCid,\r\n        jsParams: {\r\n          params: {\r\n            ...swapDetails,\r\n            encodedPolicy,\r\n          },\r\n        },\r\n      });\r\n\r\n      console.log(\"UniswapSwap Response:\", response);\r\n\r\n      if (callback) {\r\n        callback({\r\n          text: `Uniswap swap executed successfully. Response: ${JSON.stringify(response)}`,\r\n          content: {\r\n            success: true,\r\n            response: response,\r\n          },\r\n        });\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(\"Error in UniswapSwap handler:\", error);\r\n\r\n      if (callback) {\r\n        callback({\r\n          text: `Error executing Uniswap swap: ${error.message}`,\r\n          content: {\r\n            error: error.message,\r\n          },\r\n        });\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  },\r\n  examples: [\r\n    [\r\n      {\r\n        user: \"{{user1}}\",\r\n        content: { text: \"please attempt a Uniswap swap pkp addy: 0xc8BB61FB32cbfDc0534136798099709d779086b4 rpc: https://base-sepolia-rpc.publicnode.com chain ID 84532 tokenIn address 0x00cdfea7e11187BEB4a0CE835fea1745b124B26e tokenOut address 0xDFdC570ec0586D5c00735a2277c21Dcc254B3917 amountIn 1\" },\r\n      },\r\n      {\r\n        user: \"{{user2}}\",\r\n        content: { text: \"Executing Uniswap swap\", action: \"UNISWAP_SWAP_LIT_ACTION\" },\r\n      },\r\n    ],\r\n  ],\r\n};\r\n","export * from \"./actions/helloLit/helloLit\";\r\nexport * from \"./actions/tools/erc20transfer/toolCall\";\r\nexport * from \"./actions/tools/ecdsaSign/toolCall\";\r\nexport * from \"./actions/tools/uniswapSwap/toolCall\";\r\n\r\nimport type { Plugin } from \"@elizaos/core\";\r\nimport { HELLO_LIT_ACTION } from \"./actions/helloLit/helloLit\";\r\nimport { WALLET_TRANSFER_LIT_ACTION } from \"./actions/tools/erc20transfer/toolCall\";\r\nimport { ECDSA_SIGN_LIT_ACTION } from \"./actions/tools/ecdsaSign/toolCall\";\r\nimport { UNISWAP_SWAP_LIT_ACTION } from \"./actions/tools/uniswapSwap/toolCall\";\r\n\r\nexport const litPlugin: Plugin = {\r\n    name: \"lit\",\r\n    description: \"Lit Protocol integration plugin\",\r\n    providers: [],\r\n    evaluators: [],\r\n    services: [],\r\n    actions: [WALLET_TRANSFER_LIT_ACTION, HELLO_LIT_ACTION, \r\n              ECDSA_SIGN_LIT_ACTION, UNISWAP_SWAP_LIT_ACTION],\r\n};\r\n\r\nexport default litPlugin;\r\n"]}