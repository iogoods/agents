{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { MongoClient } from 'mongodb';\r\nimport {\r\n    DatabaseAdapter,\r\n    RAGKnowledgeItem,\r\n    IDatabaseCacheAdapter,\r\n    Account,\r\n    Actor,\r\n    GoalStatus,\r\n    Participant,\r\n    type Goal,\r\n    type Memory,\r\n    type Relationship,\r\n    type UUID, elizaLogger,\r\n} from \"@elizaos/core\";\r\nimport { v4 } from \"uuid\";\r\n\r\ninterface KnowledgeDocument {\r\n    id: UUID;\r\n    agentId: UUID;\r\n    content: string | {\r\n        text: string;\r\n        metadata?: {\r\n            isShared?: boolean;\r\n            isMain?: boolean;\r\n            isChunk?: boolean;\r\n            originalId?: string;\r\n            chunkIndex?: number;\r\n        };\r\n    };\r\n    embedding: number[] | null;\r\n    createdAt: Date | number;\r\n    isMain: boolean;\r\n    originalId: string | null;\r\n    chunkIndex: number | null;\r\n    isShared: boolean;\r\n}\r\n\r\nexport class MongoDBDatabaseAdapter\r\n    extends DatabaseAdapter<MongoClient>\r\n    implements IDatabaseCacheAdapter\r\n{\r\n    private database: any;\r\n    private databaseName: string;\r\n    private hasVectorSearch: boolean;\r\n    private isConnected: boolean = false;\r\n    private isVectorSearchIndexComputable: boolean;\r\n    public db: MongoClient;\r\n\r\n    constructor(client: MongoClient, databaseName: string) {\r\n        super();\r\n        this.db = client;\r\n        this.databaseName = databaseName;\r\n        this.hasVectorSearch = false;\r\n        this.isConnected = false;\r\n        this.isVectorSearchIndexComputable = true;\r\n    }\r\n\r\n    private async initializeCollections(): Promise<void> {\r\n        const collections = [\r\n            'memories',\r\n            'participants',\r\n            'cache',\r\n            'knowledge',\r\n            'rooms',\r\n            'accounts',\r\n            'goals',\r\n            'logs',\r\n            'relationships'\r\n        ];\r\n\r\n        for (const collectionName of collections) {\r\n            try {\r\n                await this.database.createCollection(collectionName);\r\n                console.log(`Collection ${collectionName} created or already exists`);\r\n            } catch (error) {\r\n                if ((error as any).code !== 48) { // 48 is \"collection already exists\"\r\n                    console.error(`Error creating collection ${collectionName}:`, error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async initializeStandardIndexes(): Promise<void> {\r\n        const collectionsWithIndexes = [\r\n            {\r\n                collectionName: 'memories',\r\n                indexes: [\r\n                    { key: { type: 1, roomId: 1, agentId: 1, createdAt: -1 } },\r\n                    { key: { content: \"text\" }, options: { weights: { content: 10 } } }\r\n                ]\r\n            },\r\n            {\r\n                collectionName: 'participants',\r\n                indexes: [\r\n                    { key: { userId: 1, roomId: 1 }, options: { unique: true } }\r\n                ]\r\n            },\r\n            {\r\n                collectionName: 'cache',\r\n                indexes: [\r\n                    { key: { expiresAt: 1 }, options: { expireAfterSeconds: 0 } }\r\n                ]\r\n            },\r\n            {\r\n                collectionName: 'knowledge',\r\n                indexes: [\r\n                    { key: { agentId: 1 } },\r\n                    { key: { isShared: 1 } },\r\n                    { key: { id: 1 }, options: { unique: true } },\r\n                    { key: { \"content.text\": \"text\" } }\r\n                ]\r\n            }\r\n        ];\r\n\r\n        await Promise.all(collectionsWithIndexes.map(async ({ collectionName, indexes }) => {\r\n            const collection = this.database.collection(collectionName);\r\n            const existingIndexes = await collection.listIndexes().toArray();\r\n\r\n            for (const index of indexes) {\r\n                const indexExists = existingIndexes.some(existingIndex =>\r\n                    JSON.stringify(existingIndex.key) === JSON.stringify(index.key)\r\n                );\r\n\r\n                if (!indexExists) {\r\n                    console.log(`Creating index for ${collectionName}:`, index.key);\r\n                    await collection.createIndex(index.key, index.options || {});\r\n                } else {\r\n                    console.log(`Index already exists for ${collectionName}:`, index.key);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n\r\n    private async initializeVectorSearch(): Promise<void> {\r\n        try {\r\n            // Check if vector search is supported\r\n            const dbStatus = await this.database.admin().serverStatus();\r\n            const vectorSearchSupported = dbStatus.vectorSearch?.supported === true;\r\n\r\n            if (vectorSearchSupported && this.isVectorSearchIndexComputable) {\r\n                const vectorSearchConfig = {\r\n                    name: \"vector_index\",\r\n                    definition: {\r\n                        vectorSearchConfig: {\r\n                            dimensions: 1536,\r\n                            similarity: \"cosine\",\r\n                            numLists: 100,\r\n                            efConstruction: 128\r\n                        }\r\n                    }\r\n                };\r\n\r\n                try {\r\n                    // Create vector search indexes for both collections\r\n                    for (const collection of ['memories', 'knowledge']) {\r\n                        await this.database.collection(collection).createIndex(\r\n                            { embedding: \"vectorSearch\" },\r\n                            vectorSearchConfig\r\n                        );\r\n                    }\r\n\r\n                    this.hasVectorSearch = true;\r\n                    console.log(\"Vector search capabilities are available and enabled\");\r\n\r\n                    // Check sharding status\r\n                    const dbInfo = await this.database.admin().command({ listDatabases: 1, nameOnly: true });\r\n                    const memoriesStats = await this.database.collection('memories').stats();\r\n\r\n                    if (dbInfo?.sharded && memoriesStats?.sharded) {\r\n                        this.isVectorSearchIndexComputable = false;\r\n                        this.hasVectorSearch = false;\r\n                        await this.createStandardEmbeddingIndexes();\r\n                    }\r\n                } catch (error) {\r\n                    console.log(\"Vector search initialization failed, falling back to standard search\", error);\r\n                    this.isVectorSearchIndexComputable = false;\r\n                    this.hasVectorSearch = false;\r\n                    await this.createStandardEmbeddingIndexes();\r\n                }\r\n            } else {\r\n                console.log(\"Vector search not supported, using standard search\");\r\n                this.isVectorSearchIndexComputable = false;\r\n                this.hasVectorSearch = false;\r\n                await this.createStandardEmbeddingIndexes();\r\n            }\r\n        } catch (error) {\r\n            console.log(\"Error checking vector search capability, defaulting to standard search\", error);\r\n            this.isVectorSearchIndexComputable = false;\r\n            this.hasVectorSearch = false;\r\n            await this.createStandardEmbeddingIndexes();\r\n        }\r\n    }\r\n\r\n    private async createStandardEmbeddingIndexes(): Promise<void> {\r\n        try {\r\n            for (const collection of ['memories', 'knowledge']) {\r\n                await this.database.collection(collection).createIndex({ embedding: 1 });\r\n            }\r\n            console.log(\"Standard embedding indexes created successfully\");\r\n        } catch (error) {\r\n            console.error(\"Failed to create standard embedding indexes:\", error);\r\n        }\r\n    }\r\n\r\n    async init() {\r\n        if (this.isConnected) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            await this.db.connect();\r\n            this.database = this.db.db(this.databaseName);\r\n\r\n            await this.initializeCollections();\r\n            await this.initializeStandardIndexes();\r\n            await this.initializeVectorSearch();\r\n\r\n            try {\r\n                // Enable sharding for better performance\r\n                await this.database.command({\r\n                    enableSharding: this.database.databaseName\r\n                });\r\n                await this.database.command({\r\n                    shardCollection: `${this.database.databaseName}.memories`,\r\n                    key: { roomId: \"hashed\" }\r\n                });\r\n            } catch (error) {\r\n                console.log(\"Sharding may already be enabled or insufficient permissions\", error);\r\n            }\r\n\r\n            this.isConnected = true;\r\n\r\n        } catch (error) {\r\n            this.isConnected = false;\r\n            this.isVectorSearchIndexComputable = false;\r\n            console.error(\"Failed to initialize MongoDB connection:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async close() {\r\n        if (this.isConnected) {\r\n            await this.db.close();\r\n            this.isConnected = false;\r\n        }\r\n    }\r\n\r\n    private async ensureConnection() {\r\n        if (!this.isConnected) {\r\n            await this.init();\r\n        }\r\n    }\r\n\r\n    // Updated database operation methods with connection checks\r\n    async getRoom(roomId: UUID): Promise<UUID | null> {\r\n        await this.ensureConnection();\r\n        const room = await this.database.collection('rooms').findOne({ id: roomId });\r\n        return room ? room.id : null;\r\n    }\r\n\r\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\r\n        await this.ensureConnection();\r\n        return await this.database.collection('participants')\r\n            .find({ userId })\r\n            .toArray();\r\n    }\r\n\r\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\r\n        await this.ensureConnection();\r\n        const participants = await this.database.collection('participants')\r\n            .find({ roomId })\r\n            .toArray();\r\n        return participants.map(p => p.userId);\r\n    }\r\n\r\n    async getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\r\n        await this.ensureConnection();\r\n        const participant = await this.database.collection('participants')\r\n            .findOne({ roomId, userId });\r\n        return participant?.userState ?? null;\r\n    }\r\n\r\n    async setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null\r\n    ): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('participants').updateOne(\r\n            { roomId, userId },\r\n            { $set: { userState: state } }\r\n        );\r\n    }\r\n\r\n    async getAccountById(userId: UUID): Promise<Account | null> {\r\n        await this.ensureConnection();\r\n        const account = await this.database.collection('accounts').findOne({ id: userId });\r\n        if (!account) return null;\r\n        return {\r\n            ...account,\r\n            details: typeof account.details === 'string' ?\r\n                JSON.parse(account.details) : account.details\r\n        };\r\n    }\r\n\r\n    async createAccount(account: Account): Promise<boolean> {\r\n        await this.ensureConnection();\r\n        try {\r\n            await this.database.collection('accounts').insertOne({\r\n                ...account,\r\n                id: account.id ?? v4(),\r\n                details: JSON.stringify(account.details),\r\n                createdAt: new Date()\r\n            });\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error creating account:\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\r\n        await this.ensureConnection();\r\n        const actors = await this.database.collection('participants')\r\n            .aggregate([\r\n                { $match: { roomId: params.roomId } },\r\n                {\r\n                    $lookup: {\r\n                        from: 'accounts',\r\n                        localField: 'userId',\r\n                        foreignField: 'id',\r\n                        as: 'account'\r\n                    }\r\n                },\r\n                { $unwind: '$account' },\r\n                {\r\n                    $project: {\r\n                        id: '$account.id',\r\n                        name: '$account.name',\r\n                        username: '$account.username',\r\n                        details: '$account.details'\r\n                    }\r\n                }\r\n            ]).toArray();\r\n\r\n        return actors\r\n            .map(actor => ({\r\n                ...actor,\r\n                details: typeof actor.details === 'string' ?\r\n                    JSON.parse(actor.details) : actor.details\r\n            }))\r\n            .filter((actor): actor is Actor => actor !== null);\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: {\r\n        agentId: UUID;\r\n        roomIds: UUID[];\r\n        tableName: string;\r\n    }): Promise<Memory[]> {\r\n        await this.ensureConnection();\r\n        if (!params.tableName) {\r\n            params.tableName = \"messages\";\r\n        }\r\n\r\n        const memories = await this.database.collection('memories')\r\n            .find({\r\n                type: params.tableName,\r\n                agentId: params.agentId,\r\n                roomId: { $in: params.roomIds }\r\n            })\r\n            .toArray();\r\n\r\n        return memories.map(memory => ({\r\n            ...memory,\r\n            content: typeof memory.content === 'string' ?\r\n                JSON.parse(memory.content) : memory.content\r\n        }));\r\n    }\r\n\r\n    async getMemoryById(memoryId: UUID): Promise<Memory | null> {\r\n        await this.ensureConnection();\r\n        const memory = await this.database.collection('memories').findOne({ id: memoryId });\r\n        if (!memory) return null;\r\n\r\n        return {\r\n            ...memory,\r\n            content: typeof memory.content === 'string' ?\r\n                JSON.parse(memory.content) : memory.content\r\n        };\r\n    }\r\n\r\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\r\n\r\n        await this.ensureConnection();\r\n        try {\r\n            let isUnique = true;\r\n\r\n            if (memory.embedding) {\r\n                const similarMemories = await this.searchMemories(\r\n                    {\r\n                        tableName,\r\n                        roomId: memory.roomId,\r\n                        agentId: memory.agentId,\r\n                        embedding: memory.embedding,\r\n                        match_threshold: 0.95,\r\n                        match_count: 1,\r\n                        unique: isUnique\r\n                    }\r\n                )\r\n                // const similarMemories = await this.searchMemoriesByEmbedding(\r\n                //     memory.embedding,\r\n                //     {\r\n                //         tableName,\r\n                //         agentId: memory.agentId,\r\n                //         roomId: memory.roomId,\r\n                //         match_threshold: 0.95,\r\n                //         count: 1\r\n                //     }\r\n                // );\r\n                isUnique = similarMemories.length === 0;\r\n            }\r\n\r\n\r\n            const content = JSON.stringify(memory.content);\r\n            const createdAt = memory.createdAt ?? Date.now();\r\n\r\n            await this.database.collection('memories').insertOne({\r\n                id: memory.id ?? v4(),\r\n                type: tableName,\r\n                content,\r\n                embedding: memory.embedding ? Array.from(memory.embedding) : null,\r\n                userId: memory.userId,\r\n                roomId: memory.roomId,\r\n                agentId: memory.agentId,\r\n                unique: isUnique,\r\n                createdAt: new Date(createdAt)\r\n            });\r\n        }catch (e) {\r\n            elizaLogger.error(e);\r\n        }\r\n    }\r\n\r\n    private async searchMemoriesFallback(params: {\r\n        embedding: number[];\r\n        query: any;\r\n        limit?: number;\r\n    }): Promise<Memory[]> {\r\n        await this.ensureConnection();\r\n        // Implement a basic similarity search using standard MongoDB operations\r\n        const memories = await this.database.collection('memories')\r\n            .find(params.query)\r\n            .limit(params.limit || 10)\r\n            .toArray();\r\n\r\n        // Sort by cosine similarity computed in application\r\n        return memories\r\n            .map(memory => ({\r\n                ...memory,\r\n                similarity: this.cosineSimilarity(params.embedding, memory.embedding)\r\n            }))\r\n            .sort((a, b) => b.similarity - a.similarity)\r\n            .map(memory => ({\r\n                ...memory,\r\n                createdAt: typeof memory.createdAt === \"string\" ?\r\n                    Date.parse(memory.createdAt) : memory.createdAt,\r\n                content: typeof memory.content === 'string' ?\r\n                    JSON.parse(memory.content) : memory.content\r\n            }));\r\n    }\r\n\r\n    private cosineSimilarity(a: Float32Array | number[], b: Float32Array | number[]): number {\r\n        const aArr = Array.from(a);\r\n        const bArr = Array.from(b);\r\n        const dotProduct = aArr.reduce((sum, val, i) => sum + val * bArr[i], 0);\r\n        const magnitudeA = Math.sqrt(aArr.reduce((sum, val) => sum + val * val, 0));\r\n        const magnitudeB = Math.sqrt(bArr.reduce((sum, val) => sum + val * val, 0));\r\n        return dotProduct / (magnitudeA * magnitudeB);\r\n    }\r\n\r\n    async searchMemories(params: {\r\n        tableName: string;\r\n        roomId: UUID;\r\n        agentId?: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]> {\r\n        await this.ensureConnection();\r\n        const query = {\r\n            type: params.tableName,\r\n            roomId: params.roomId,\r\n            ...(params.unique && { unique: true }),\r\n            ...(params.agentId && { agentId: params.agentId })\r\n        };\r\n\r\n        if (this.hasVectorSearch) {\r\n            const pipeline = [\r\n                {\r\n                    $search: {\r\n                        vectorSearch: {\r\n                            queryVector: new Float32Array(params.embedding),\r\n                            path: \"embedding\",\r\n                            numCandidates: params.match_count * 2,\r\n                            limit: params.match_count,\r\n                            index: \"vector_index\",\r\n                        }\r\n                    }\r\n                },\r\n                { $match: query }\r\n            ];\r\n\r\n            try {\r\n                const memories = await this.database.collection('memories')\r\n                    .aggregate(pipeline)\r\n                    .toArray();\r\n\r\n                return memories.map(memory => ({\r\n                    ...memory,\r\n                    createdAt: typeof memory.createdAt === \"string\" ?\r\n                        Date.parse(memory.createdAt) : memory.createdAt,\r\n                    content: typeof memory.content === 'string' ?\r\n                        JSON.parse(memory.content) : memory.content\r\n                }));\r\n            } catch (error) {\r\n                console.log(\"Vector search failed, falling back to standard search\", error);\r\n                return this.searchMemoriesFallback({\r\n                    embedding: params.embedding,\r\n                    query,\r\n                    limit: params.match_count\r\n                });\r\n            }\r\n        }\r\n\r\n        return this.searchMemoriesFallback({\r\n            embedding: params.embedding,\r\n            query,\r\n            limit: params.match_count\r\n        });\r\n    }\r\n\r\n\r\n\r\n    async searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        params: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId?: UUID;\r\n            agentId: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        }\r\n    ): Promise<Memory[]> {\r\n        await this.ensureConnection();\r\n        const pipeline = [\r\n            {\r\n                $search: {\r\n                    vectorSearch: {\r\n                        queryVector: Array.from(embedding),\r\n                        path: \"embedding\",\r\n                        numCandidates: (params.count ?? 10) * 2,\r\n                        limit: params.count,\r\n                        index: \"vector_index\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                $match: {\r\n                    type: params.tableName,\r\n                    agentId: params.agentId,\r\n                    ...(params.unique && { unique: true }),\r\n                    ...(params.roomId && { roomId: params.roomId })\r\n                }\r\n            }\r\n        ];\r\n\r\n        const memories = await this.database.collection('memories')\r\n            .aggregate(pipeline)\r\n            .toArray();\r\n\r\n        return memories.map(memory => ({\r\n            ...memory,\r\n            createdAt: typeof memory.createdAt === \"string\" ?\r\n                Date.parse(memory.createdAt) : memory.createdAt,\r\n            content: typeof memory.content === 'string' ?\r\n                JSON.parse(memory.content) : memory.content\r\n        }));\r\n    }\r\n\r\n    async getCachedEmbeddings(opts: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\r\n        await this.ensureConnection();\r\n        const BATCH_SIZE = 1000; // Process in chunks of 1000 documents\r\n        let results: { embedding: number[]; levenshtein_score: number }[] = [];\r\n\r\n        try {\r\n            // Get total count for progress tracking\r\n            const totalCount = await this.database.collection('memories').countDocuments({\r\n                type: opts.query_table_name,\r\n                [`content.${opts.query_field_name}.${opts.query_field_sub_name}`]: { $exists: true }\r\n            });\r\n\r\n            let processed = 0;\r\n\r\n            while (processed < totalCount) {\r\n                // Fetch batch of documents\r\n                const memories = await this.database.collection('memories')\r\n                    .find({\r\n                        type: opts.query_table_name,\r\n                        [`content.${opts.query_field_name}.${opts.query_field_sub_name}`]: { $exists: true }\r\n                    })\r\n                    .skip(processed)\r\n                    .limit(BATCH_SIZE)\r\n                    .toArray();\r\n\r\n                // Process batch\r\n                const batchResults = memories\r\n                    .map(memory => {\r\n                        try {\r\n                            const content = memory.content[opts.query_field_name][opts.query_field_sub_name];\r\n                            if (!content || typeof content !== 'string') {\r\n                                return null;\r\n                            }\r\n\r\n                            return {\r\n                                embedding: Array.from(memory.embedding),\r\n                                levenshtein_score: this.calculateLevenshteinDistanceOptimized(\r\n                                    content.toLowerCase(),\r\n                                    opts.query_input.toLowerCase()\r\n                                )\r\n                            };\r\n                        } catch (error) {\r\n                            console.warn(`Error processing memory document: ${error}`);\r\n                            return null;\r\n                        }\r\n                    })\r\n                    .filter((result): result is { embedding: number[]; levenshtein_score: number } =>\r\n                        result !== null);\r\n\r\n                // Merge batch results\r\n                results = this.mergeAndSortResults(results, batchResults, opts.query_match_count);\r\n                processed += memories.length;\r\n\r\n                // Log progress for long operations\r\n                if (totalCount > BATCH_SIZE) {\r\n                    console.log(`Processed ${processed}/${totalCount} documents`);\r\n                }\r\n            }\r\n\r\n            return results;\r\n\r\n        } catch (error) {\r\n            console.error(\"Error in getCachedEmbeddings:\", error);\r\n            if (results.length > 0) {\r\n                console.log(\"Returning partial results\");\r\n                return results;\r\n            }\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Optimized Levenshtein distance calculation with early termination\r\n     * and matrix reuse for better performance\r\n     */\r\n    private calculateLevenshteinDistanceOptimized(str1: string, str2: string): number {\r\n        // Early termination for identical strings\r\n        if (str1 === str2) return 0;\r\n\r\n        // Early termination for empty strings\r\n        if (str1.length === 0) return str2.length;\r\n        if (str2.length === 0) return str1.length;\r\n\r\n        // Use shorter string as inner loop for better performance\r\n        if (str1.length > str2.length) {\r\n            [str1, str2] = [str2, str1];\r\n        }\r\n\r\n        // Reuse matrix to avoid garbage collection\r\n        const matrix = this.getLevenshteinMatrix(str1.length + 1, str2.length + 1);\r\n\r\n        // Initialize first row and column\r\n        for (let i = 0; i <= str1.length; i++) matrix[i][0] = i;\r\n        for (let j = 0; j <= str2.length; j++) matrix[0][j] = j;\r\n\r\n        // Calculate minimum edit distance\r\n        for (let i = 1; i <= str1.length; i++) {\r\n            for (let j = 1; j <= str2.length; j++) {\r\n                if (str1[i-1] === str2[j-1]) {\r\n                    matrix[i][j] = matrix[i-1][j-1];\r\n                } else {\r\n                    matrix[i][j] = Math.min(\r\n                        matrix[i-1][j-1] + 1,  // substitution\r\n                        matrix[i][j-1] + 1,    // insertion\r\n                        matrix[i-1][j] + 1     // deletion\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return matrix[str1.length][str2.length];\r\n    }\r\n\r\n// Cache for reusing Levenshtein distance matrix\r\n    private levenshteinMatrix: number[][] = [];\r\n    private maxMatrixSize = 0;\r\n\r\n    private getLevenshteinMatrix(rows: number, cols: number): number[][] {\r\n        const size = rows * cols;\r\n        if (size > this.maxMatrixSize) {\r\n            this.levenshteinMatrix = Array(rows).fill(null)\r\n                .map(() => Array(cols).fill(0));\r\n            this.maxMatrixSize = size;\r\n        }\r\n        return this.levenshteinMatrix;\r\n    }\r\n\r\n    /**\r\n     * Efficiently merge and sort two arrays of results while maintaining top K items\r\n     */\r\n    private mergeAndSortResults(\r\n        existing: { embedding: number[]; levenshtein_score: number }[],\r\n        newResults: { embedding: number[]; levenshtein_score: number }[],\r\n        limit: number\r\n    ): { embedding: number[]; levenshtein_score: number }[] {\r\n        const merged = [...existing, ...newResults];\r\n\r\n        // Use quick select algorithm if array is large\r\n        if (merged.length > 1000) {\r\n            return this.quickSelectTopK(merged, limit);\r\n        }\r\n\r\n        // Use simple sort for smaller arrays\r\n        return merged\r\n            .sort((a, b) => a.levenshtein_score - b.levenshtein_score)\r\n            .slice(0, limit);\r\n    }\r\n\r\n    /**\r\n     * Quick select algorithm to efficiently find top K items\r\n     */\r\n    private quickSelectTopK(\r\n        arr: { embedding: number[]; levenshtein_score: number }[],\r\n        k: number\r\n    ): { embedding: number[]; levenshtein_score: number }[] {\r\n        if (arr.length <= k) return arr.sort((a, b) => a.levenshtein_score - b.levenshtein_score);\r\n\r\n        const pivot = arr[Math.floor(Math.random() * arr.length)].levenshtein_score;\r\n        const left = arr.filter(x => x.levenshtein_score < pivot);\r\n        const equal = arr.filter(x => x.levenshtein_score === pivot);\r\n        const right = arr.filter(x => x.levenshtein_score > pivot);\r\n\r\n        if (k <= left.length) {\r\n            return this.quickSelectTopK(left, k);\r\n        }\r\n        if (k <= left.length + equal.length) {\r\n            return [...left, ...equal.slice(0, k - left.length)]\r\n                .sort((a, b) => a.levenshtein_score - b.levenshtein_score);\r\n        }\r\n        return [...left, ...equal, ...this.quickSelectTopK(right, k - left.length - equal.length)]\r\n            .sort((a, b) => a.levenshtein_score - b.levenshtein_score);\r\n    }\r\n\r\n    async updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('goals').updateOne(\r\n            { id: params.goalId },\r\n            { $set: { status: params.status } }\r\n        );\r\n    }\r\n\r\n    async log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('logs').insertOne({\r\n            id: v4(),\r\n            body: JSON.stringify(params.body),\r\n            userId: params.userId,\r\n            roomId: params.roomId,\r\n            type: params.type,\r\n            createdAt: new Date()\r\n        });\r\n    }\r\n\r\n    async getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n        await this.ensureConnection();\r\n        if (!params.tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n        if (!params.roomId) {\r\n            throw new Error(\"roomId is required\");\r\n        }\r\n\r\n        const query: any = {\r\n            type: params.tableName,\r\n            agentId: params.agentId,\r\n            roomId: params.roomId\r\n        };\r\n\r\n        if (params.unique) {\r\n            query.unique = true;\r\n        }\r\n\r\n        if (params.start || params.end) {\r\n            query.createdAt = {};\r\n            if (params.start) query.createdAt.$gte = new Date(params.start);\r\n            if (params.end) query.createdAt.$lte = new Date(params.end);\r\n        }\r\n\r\n        const memories = await this.database.collection('memories')\r\n            .find(query)\r\n            .sort({ createdAt: -1 })\r\n            .limit(params.count || 0)\r\n            .toArray();\r\n\r\n        return memories.map(memory => ({\r\n            ...memory,\r\n            createdAt: new Date(memory.createdAt).getTime(),\r\n            content: typeof memory.content === 'string' ?\r\n                JSON.parse(memory.content) : memory.content\r\n        }));\r\n    }\r\n\r\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('memories').deleteOne({\r\n            id: memoryId,\r\n            type: tableName\r\n        });\r\n    }\r\n\r\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('memories').deleteMany({\r\n            roomId,\r\n            type: tableName\r\n        });\r\n    }\r\n\r\n    async countMemories(\r\n        roomId: UUID,\r\n        unique = true,\r\n        tableName = \"\"\r\n    ): Promise<number> {\r\n        await this.ensureConnection();\r\n        if (!tableName) {\r\n            throw new Error(\"tableName is required\");\r\n        }\r\n\r\n        const query: any = {\r\n            type: tableName,\r\n            roomId\r\n        };\r\n\r\n        if (unique) {\r\n            query.unique = true;\r\n        }\r\n\r\n        return await this.database.collection('memories').countDocuments(query);\r\n    }\r\n\r\n    async getGoals(params: {\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]> {\r\n        await this.ensureConnection();\r\n        const query: any = { roomId: params.roomId };\r\n\r\n        if (params.userId) {\r\n            query.userId = params.userId;\r\n        }\r\n\r\n        if (params.onlyInProgress) {\r\n            query.status = 'IN_PROGRESS';\r\n        }\r\n\r\n        const goals = await this.database.collection('goals')\r\n            .find(query)\r\n            .limit(params.count || 0)\r\n            .toArray();\r\n\r\n        return goals.map(goal => ({\r\n            ...goal,\r\n            objectives: typeof goal.objectives === 'string' ?\r\n                JSON.parse(goal.objectives) : goal.objectives\r\n        }));\r\n    }\r\n\r\n    async updateGoal(goal: Goal): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('goals').updateOne(\r\n            { id: goal.id },\r\n            {\r\n                $set: {\r\n                    name: goal.name,\r\n                    status: goal.status,\r\n                    objectives: JSON.stringify(goal.objectives)\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    async createGoal(goal: Goal): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('goals').insertOne({\r\n            ...goal,\r\n            id: goal.id ?? v4(),\r\n            objectives: JSON.stringify(goal.objectives),\r\n            createdAt: new Date()\r\n        });\r\n    }\r\n\r\n    async removeGoal(goalId: UUID): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('goals').deleteOne({ id: goalId });\r\n    }\r\n\r\n    async removeAllGoals(roomId: UUID): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('goals').deleteMany({ roomId });\r\n    }\r\n\r\n    async createRoom(roomId?: UUID): Promise<UUID> {\r\n        await this.ensureConnection();\r\n        const newRoomId = roomId || v4() as UUID;\r\n        try {\r\n            await this.database.collection('rooms').insertOne({\r\n                id: newRoomId,\r\n                createdAt: new Date()\r\n            });\r\n            return newRoomId;\r\n        } catch (error) {\r\n            console.error(\"Error creating room:\", error);\r\n            throw error; // Throw error instead of silently continuing\r\n        }\r\n    }\r\n\r\n    async removeRoom(roomId: UUID): Promise<void> {\r\n        await this.ensureConnection();\r\n        try {\r\n            await this.database.collection('rooms').deleteOne({ id: roomId });\r\n        } catch (error) {\r\n            console.error(\"Error removing room:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\r\n        await this.ensureConnection();\r\n        const rooms = await this.database.collection('participants')\r\n            .find({ userId })\r\n            .project({ roomId: 1 })\r\n            .toArray();\r\n        return rooms.map(r => r.roomId);\r\n    }\r\n\r\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\r\n        await this.ensureConnection();\r\n        const rooms = await this.database.collection('participants')\r\n            .distinct('roomId', { userId: { $in: userIds } });\r\n        return rooms;\r\n    }\r\n\r\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        await this.ensureConnection();\r\n        try {\r\n            await this.database.collection('participants').insertOne({\r\n                id: v4(),\r\n                userId,\r\n                roomId,\r\n                createdAt: new Date()\r\n            });\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error adding participant\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\r\n        await this.ensureConnection();\r\n        try {\r\n            await this.database.collection('participants').deleteOne({\r\n                userId,\r\n                roomId\r\n            });\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error removing participant\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async createRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<boolean> {\r\n        await this.ensureConnection();\r\n        if (!params.userA || !params.userB) {\r\n            throw new Error(\"userA and userB are required\");\r\n        }\r\n\r\n        try {\r\n            await this.database.collection('relationships').insertOne({\r\n                id: v4(),\r\n                userA: params.userA,\r\n                userB: params.userB,\r\n                userId: params.userA,\r\n                createdAt: new Date()\r\n            });\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error creating relationship\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null> {\r\n        await this.ensureConnection();\r\n        return await this.database.collection('relationships').findOne({\r\n            $or: [\r\n                { userA: params.userA, userB: params.userB },\r\n                { userA: params.userB, userB: params.userA }\r\n            ]\r\n        });\r\n    }\r\n\r\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\r\n        await this.ensureConnection();\r\n        return await this.database.collection('relationships')\r\n            .find({\r\n                $or: [\r\n                    { userA: params.userId },\r\n                    { userB: params.userId }\r\n                ]\r\n            })\r\n            .toArray();\r\n    }\r\n\r\n    async getCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<string | undefined> {\r\n        await this.ensureConnection();\r\n        const cached = await this.database.collection('cache')\r\n            .findOne({\r\n                key: params.key,\r\n                agentId: params.agentId,\r\n                expiresAt: { $gt: new Date() }\r\n            });\r\n        return cached?.value;\r\n    }\r\n\r\n    async setCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n        value: string;\r\n    }): Promise<boolean> {\r\n        await this.ensureConnection();\r\n        try {\r\n            await this.database.collection('cache').updateOne(\r\n                { key: params.key, agentId: params.agentId },\r\n                {\r\n                    $set: {\r\n                        value: params.value,\r\n                        createdAt: new Date(),\r\n                        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours expiry\r\n                    }\r\n                },\r\n                { upsert: true }\r\n            );\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error setting cache\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async deleteCache(params: {\r\n        key: string;\r\n        agentId: UUID;\r\n    }): Promise<boolean> {\r\n        await this.ensureConnection();\r\n        try {\r\n            await this.database.collection('cache').deleteOne({\r\n                key: params.key,\r\n                agentId: params.agentId\r\n            });\r\n            return true;\r\n        } catch (error) {\r\n            console.log(\"Error removing cache\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        await this.ensureConnection();\r\n\r\n        const query: any = {\r\n            $or: [\r\n                { agentId: params.agentId },\r\n                { isShared: true }\r\n            ]\r\n        };\r\n\r\n        if (params.id) {\r\n            query.id = params.id;\r\n        }\r\n\r\n        const knowledge = await this.database.collection('knowledge')\r\n            .find(query)\r\n            .limit(params.limit || 0)\r\n            .toArray();\r\n\r\n        return knowledge.map(item => ({\r\n            id: item.id,\r\n            agentId: item.agentId,\r\n            content: typeof item.content === 'string' ? JSON.parse(item.content) : item.content,\r\n            embedding: item.embedding ? new Float32Array(item.embedding) : undefined,\r\n            createdAt: typeof item.createdAt === \"string\" ? Date.parse(item.createdAt) : item.createdAt\r\n        }));\r\n    }\r\n\r\n    async searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]> {\r\n        await this.ensureConnection();\r\n\r\n        const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\r\n        const cachedResult = await this.getCache({\r\n            key: cacheKey,\r\n            agentId: params.agentId\r\n        });\r\n\r\n        if (cachedResult) {\r\n            return JSON.parse(cachedResult);\r\n        }\r\n\r\n        try {\r\n            let results: KnowledgeDocument[];\r\n\r\n            if (this.hasVectorSearch) {\r\n                try {\r\n                    results = await this.vectorSearchKnowledge(params);\r\n                } catch (error) {\r\n                    console.log(\"Vector search failed, falling back to standard search\", error);\r\n                    results = await this.fallbackSearchKnowledge(params);\r\n                }\r\n            } else {\r\n                results = await this.fallbackSearchKnowledge(params);\r\n            }\r\n\r\n            const mappedResults = results.map(item => ({\r\n                id: item.id,\r\n                agentId: item.agentId, // This will always be UUID\r\n                content: typeof item.content === 'string' ? JSON.parse(item.content) : item.content,\r\n                embedding: item.embedding ? new Float32Array(item.embedding) : undefined,\r\n                createdAt: typeof item.createdAt === \"string\" ? Date.parse(item.createdAt) : item.createdAt,\r\n                similarity: (item as any).combinedScore || 0\r\n            })) as RAGKnowledgeItem[];\r\n\r\n            await this.setCache({\r\n                key: cacheKey,\r\n                agentId: params.agentId,\r\n                value: JSON.stringify(mappedResults)\r\n            });\r\n\r\n            return mappedResults;\r\n        } catch (error) {\r\n            console.error(\"Error in searchKnowledge:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async vectorSearchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<KnowledgeDocument[]> {\r\n        const pipeline = [\r\n            {\r\n                $search: {\r\n                    vectorSearch: {\r\n                        queryVector: Array.from(params.embedding),\r\n                        path: \"embedding\",\r\n                        numCandidates: params.match_count * 2,\r\n                        limit: params.match_count * 2,\r\n                        index: \"vector_index\"\r\n                    }\r\n                }\r\n            },\r\n            ...this.getKnowledgeSearchPipeline(params)\r\n        ];\r\n\r\n        return await this.database.collection('knowledge')\r\n            .aggregate(pipeline)\r\n            .toArray();\r\n    }\r\n\r\n    private async fallbackSearchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<KnowledgeDocument[]> {\r\n        const pipeline = [\r\n            {\r\n                $match: {\r\n                    $or: [\r\n                        { agentId: params.agentId },\r\n                        { isShared: true, agentId: null }\r\n                    ]\r\n                }\r\n            },\r\n            ...this.getKnowledgeSearchPipeline(params)\r\n        ];\r\n\r\n        return await this.database.collection('knowledge')\r\n            .aggregate(pipeline)\r\n            .toArray();\r\n    }\r\n\r\n    private getKnowledgeSearchPipeline(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        searchText?: string;\r\n    }): object[] {\r\n        return [\r\n            {\r\n                $addFields: {\r\n                    vectorScore: this.hasVectorSearch ?\r\n                        { $meta: \"vectorSearchScore\" } :\r\n                        {\r\n                            $let: {\r\n                                vars: {\r\n                                    embedding: { $ifNull: [\"$embedding\", []] }\r\n                                },\r\n                                in: {\r\n                                    $cond: [\r\n                                        { $eq: [{ $size: \"$$embedding\" }, 0] },\r\n                                        0,\r\n                                        {\r\n                                            $divide: [\r\n                                                1,\r\n                                                { $add: [1, { $function: {\r\n                                                            body: this.cosineSimilarity.toString(),\r\n                                                            args: [params.embedding, \"$$embedding\"],\r\n                                                            lang: \"js\"\r\n                                                        }}] }\r\n                                            ]\r\n                                        }\r\n                                    ]\r\n                                }\r\n                            }\r\n                        },\r\n                    keywordScore: this.calculateKeywordScore(params.searchText)\r\n                }\r\n            },\r\n            {\r\n                $addFields: {\r\n                    combinedScore: { $multiply: [\"$vectorScore\", \"$keywordScore\"] }\r\n                }\r\n            },\r\n            {\r\n                $match: {\r\n                    $or: [\r\n                        { vectorScore: { $gte: params.match_threshold } },\r\n                        {\r\n                            $and: [\r\n                                { keywordScore: { $gt: 1.0 } },\r\n                                { vectorScore: { $gte: 0.3 } }\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            },\r\n            { $sort: { combinedScore: -1 } }\r\n        ];\r\n    }\r\n\r\n    private calculateKeywordScore(searchText?: string): object {\r\n        return {\r\n            $multiply: [\r\n                {\r\n                    $cond: [\r\n                        searchText ? {\r\n                            $regexMatch: {\r\n                                input: { $toLower: \"$content.text\" },\r\n                                regex: new RegExp(searchText.toLowerCase())\r\n                            }\r\n                        } : false,\r\n                        3.0,\r\n                        1.0\r\n                    ]\r\n                },\r\n                {\r\n                    $cond: [\r\n                        { $eq: [\"$content.metadata.isChunk\", true] },\r\n                        1.5,\r\n                        {\r\n                            $cond: [\r\n                                { $eq: [\"$content.metadata.isMain\", true] },\r\n                                1.2,\r\n                                1.0\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        };\r\n    }\r\n\r\n    // Update error handling in createKnowledge\r\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const metadata = knowledge.content.metadata || {};\r\n            const isShared = metadata.isShared || false;\r\n\r\n            const doc = {\r\n                id: knowledge.id,\r\n                agentId: knowledge.agentId,\r\n                content: typeof knowledge.content === 'string' ?\r\n                    knowledge.content :\r\n                    JSON.stringify(knowledge.content),\r\n                embedding: knowledge.embedding ? Array.from(knowledge.embedding) : null,\r\n                createdAt: knowledge.createdAt || Date.now(),\r\n                isMain: metadata.isMain || false,\r\n                originalId: metadata.originalId || null,\r\n                chunkIndex: metadata.chunkIndex || null,\r\n                isShared\r\n            };\r\n\r\n            await this.database.collection('knowledge').updateOne(\r\n                { id: knowledge.id },\r\n                { $setOnInsert: doc },\r\n                { upsert: true }\r\n            );\r\n        } catch (err) {\r\n            if (err instanceof Error) {\r\n                const error = err as Error & { code?: number };\r\n                const isShared = knowledge.content.metadata?.isShared;\r\n\r\n                if (isShared && error.code === 11000) {\r\n                    console.info(`Shared knowledge ${knowledge.id} already exists, skipping`);\r\n                    return;\r\n                }\r\n\r\n                console.error(`Error creating knowledge ${knowledge.id}:`, error);\r\n                throw error;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async removeKnowledge(id: UUID): Promise<void> {\r\n        await this.ensureConnection();\r\n        await this.database.collection('knowledge').deleteOne({ id });\r\n    }\r\n\r\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\r\n        await this.ensureConnection();\r\n        const query = shared ?\r\n            { $or: [{ agentId }, { isShared: true }] } :\r\n            { agentId };\r\n\r\n        try {\r\n            await this.database.collection('knowledge').deleteMany(query);\r\n        } catch (error) {\r\n            console.error(`Error clearing knowledge for agent ${agentId}:`, error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getMemoriesByIds(memoryIds: UUID[], tableName?: string): Promise<Memory[]> {\r\n        await this.ensureConnection();\r\n        const collection = tableName || 'memories';\r\n\r\n        try {\r\n            const memories = await this.database.collection(collection)\r\n                .find({ id: { $in: memoryIds } })\r\n                .toArray();\r\n\r\n            return memories.map(memory => ({\r\n                id: memory.id,\r\n                roomId: memory.roomId,\r\n                agentId: memory.agentId,\r\n                type: memory.type,\r\n                content: memory.content,\r\n                embedding: memory.embedding,\r\n                createdAt: memory.createdAt instanceof Date ? memory.createdAt.getTime() : memory.createdAt,\r\n                metadata: memory.metadata || {}\r\n            }));\r\n        } catch (error) {\r\n            elizaLogger.error('Failed to get memories by IDs:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n}\r\n\r\n"],"mappings":"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","names":[]}