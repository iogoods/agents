{"version":3,"sources":["../src/actions/bridge.ts","../src/providers/wallet.ts","../src/templates/index.ts","../src/actions/swap.ts","../src/actions/transfer.ts","../src/types/index.ts","../src/index.ts"],"sourcesContent":["import type { IAgentRuntime, Memory, State, HandlerCallback } from \"@elizaos/core\";\r\nimport {\r\n    composeContext,\r\n    generateObjectDeprecated,\r\n    ModelClass,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    createConfig,\r\n    executeRoute,\r\n    type ExtendedChain,\r\n    getRoutes,\r\n} from \"@lifi/sdk\";\r\n\r\nimport { initWalletProvider, type WalletProvider } from \"../providers/wallet\";\r\nimport { bridgeTemplate } from \"../templates\";\r\nimport type { BridgeParams, Transaction } from \"../types\";\r\nimport { parseEther } from \"viem\";\r\n\r\nexport { bridgeTemplate };\r\n\r\nexport class BridgeAction {\r\n    private config;\r\n\r\n    constructor(private walletProvider: WalletProvider) {\r\n        this.config = createConfig({\r\n            integrator: \"eliza\",\r\n            chains: Object.values(this.walletProvider.chains).map((config) => ({\r\n                id: config.id,\r\n                name: config.name,\r\n                key: config.name.toLowerCase(),\r\n                chainType: \"EVM\",\r\n                nativeToken: {\r\n                    ...config.nativeCurrency,\r\n                    chainId: config.id,\r\n                    address: \"0x0000000000000000000000000000000000000000\",\r\n                    coinKey: config.nativeCurrency.symbol,\r\n                },\r\n                metamask: {\r\n                    chainId: `0x${config.id.toString(16)}`,\r\n                    chainName: config.name,\r\n                    nativeCurrency: config.nativeCurrency,\r\n                    rpcUrls: [config.rpcUrls.default.http[0]],\r\n                    blockExplorerUrls: [config.blockExplorers.default.url],\r\n                },\r\n                diamondAddress: \"0x0000000000000000000000000000000000000000\",\r\n                coin: config.nativeCurrency.symbol,\r\n                mainnet: true,\r\n            })) as ExtendedChain[],\r\n        });\r\n    }\r\n\r\n    async bridge(params: BridgeParams): Promise<Transaction> {\r\n        const walletClient = this.walletProvider.getWalletClient(\r\n            params.fromChain\r\n        );\r\n        const [fromAddress] = await walletClient.getAddresses();\r\n\r\n        const routes = await getRoutes({\r\n            fromChainId: this.walletProvider.getChainConfigs(params.fromChain)\r\n                .id,\r\n            toChainId: this.walletProvider.getChainConfigs(params.toChain).id,\r\n            fromTokenAddress: params.fromToken,\r\n            toTokenAddress: params.toToken,\r\n            fromAmount: parseEther(params.amount).toString(),\r\n            fromAddress: fromAddress,\r\n            toAddress: params.toAddress || fromAddress,\r\n        });\r\n\r\n        if (!routes.routes.length) throw new Error(\"No routes found\");\r\n\r\n        const execution = await executeRoute(routes.routes[0], this.config);\r\n        const process = execution.steps[0]?.execution?.process[0];\r\n\r\n        if (!process?.status || process.status === \"FAILED\") {\r\n            throw new Error(\"Transaction failed\");\r\n        }\r\n\r\n        return {\r\n            hash: process.txHash as `0x${string}`,\r\n            from: fromAddress,\r\n            to: routes.routes[0].steps[0].estimate\r\n                .approvalAddress as `0x${string}`,\r\n            value: BigInt(params.amount),\r\n            chainId: this.walletProvider.getChainConfigs(params.fromChain).id,\r\n        };\r\n    }\r\n}\r\n\r\nexport const bridgeAction = {\r\n    name: \"bridge\",\r\n    description: \"Bridge tokens between different chains\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        state: State,\r\n        _options: Record<string, unknown>,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        console.log(\"Bridge action handler called\");\r\n        const walletProvider = await initWalletProvider(runtime);\r\n        const action = new BridgeAction(walletProvider);\r\n\r\n        // Compose bridge context\r\n        const bridgeContext = composeContext({\r\n            state,\r\n            template: bridgeTemplate,\r\n        });\r\n        const content = await generateObjectDeprecated({\r\n            runtime,\r\n            context: bridgeContext,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        const bridgeOptions: BridgeParams = {\r\n            fromChain: content.fromChain,\r\n            toChain: content.toChain,\r\n            fromToken: content.token,\r\n            toToken: content.token,\r\n            toAddress: content.toAddress,\r\n            amount: content.amount,\r\n        };\r\n\r\n        try {\r\n            const bridgeResp = await action.bridge(bridgeOptions);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Successfully bridge ${bridgeOptions.amount} ${bridgeOptions.fromToken} tokens from ${bridgeOptions.fromChain} to ${bridgeOptions.toChain}\\nTransaction Hash: ${bridgeResp.hash}`,\r\n                    content: {\r\n                        success: true,\r\n                        hash: bridgeResp.hash,\r\n                        recipient: bridgeResp.to,\r\n                        chain: bridgeOptions.fromChain,\r\n                    },\r\n                });\r\n            }\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error in bridge handler:\", error.message);\r\n            if (callback) {\r\n                callback({ text: `Error: ${error.message}` });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    template: bridgeTemplate,\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"user\",\r\n                content: {\r\n                    text: \"Bridge 1 ETH from Ethereum to Base\",\r\n                    action: \"CROSS_CHAIN_TRANSFER\",\r\n                },\r\n            },\r\n        ],\r\n    ],\r\n    similes: [\"CROSS_CHAIN_TRANSFER\", \"CHAIN_BRIDGE\", \"MOVE_CROSS_CHAIN\"],\r\n}; // TODO: add more examples / similies\r\n","import {\r\n    createPublicClient,\r\n    createTestClient,\r\n    createWalletClient,\r\n    formatUnits,\r\n    http,\r\n    publicActions,\r\n    walletActions,\r\n} from \"viem\";\r\nimport { privateKeyToAccount } from \"viem/accounts\";\r\nimport {\r\n    type IAgentRuntime,\r\n    type Provider,\r\n    type Memory,\r\n    type State,\r\n    type ICacheManager,\r\n    elizaLogger,\r\n} from \"@elizaos/core\";\r\nimport type {\r\n    Address,\r\n    WalletClient,\r\n    PublicClient,\r\n    Chain,\r\n    HttpTransport,\r\n    Account,\r\n    PrivateKeyAccount,\r\n    TestClient,\r\n} from \"viem\";\r\nimport * as viemChains from \"viem/chains\";\r\nimport { DeriveKeyProvider, TEEMode } from \"@elizaos/plugin-tee\";\r\nimport NodeCache from \"node-cache\";\r\nimport * as path from \"node:path\";\r\n\r\nimport type { SupportedChain } from \"../types\";\r\n\r\nexport class WalletProvider {\r\n    private cache: NodeCache;\r\n    private cacheKey = \"evm/wallet\";\r\n    private currentChain: SupportedChain = \"mainnet\";\r\n    private CACHE_EXPIRY_SEC = 5;\r\n    chains: Record<string, Chain> = { ...viemChains };\r\n    account: PrivateKeyAccount;\r\n\r\n    constructor(\r\n        accountOrPrivateKey: PrivateKeyAccount | `0x${string}`,\r\n        private cacheManager: ICacheManager,\r\n        chains?: Record<string, Chain>\r\n    ) {\r\n        this.setAccount(accountOrPrivateKey);\r\n        this.setChains(chains);\r\n\r\n        if (chains && Object.keys(chains).length > 0) {\r\n            this.setCurrentChain(Object.keys(chains)[0] as SupportedChain);\r\n        }\r\n\r\n        this.cache = new NodeCache({ stdTTL: this.CACHE_EXPIRY_SEC });\r\n    }\r\n\r\n    getAddress(): Address {\r\n        return this.account.address;\r\n    }\r\n\r\n    getCurrentChain(): Chain {\r\n        return this.chains[this.currentChain];\r\n    }\r\n\r\n    getPublicClient(\r\n        chainName: SupportedChain\r\n    ): PublicClient<HttpTransport, Chain, Account | undefined> {\r\n        const transport = this.createHttpTransport(chainName);\r\n\r\n        const publicClient = createPublicClient({\r\n            chain: this.chains[chainName],\r\n            transport,\r\n        });\r\n        return publicClient;\r\n    }\r\n\r\n    getWalletClient(chainName: SupportedChain): WalletClient {\r\n        const transport = this.createHttpTransport(chainName);\r\n\r\n        const walletClient = createWalletClient({\r\n            chain: this.chains[chainName],\r\n            transport,\r\n            account: this.account,\r\n        });\r\n\r\n        return walletClient;\r\n    }\r\n\r\n    getTestClient(): TestClient {\r\n        return createTestClient({\r\n            chain: viemChains.hardhat,\r\n            mode: \"hardhat\",\r\n            transport: http(),\r\n        })\r\n            .extend(publicActions)\r\n            .extend(walletActions);\r\n    }\r\n\r\n    getChainConfigs(chainName: SupportedChain): Chain {\r\n        const chain = viemChains[chainName];\r\n\r\n        if (!chain?.id) {\r\n            throw new Error(\"Invalid chain name\");\r\n        }\r\n\r\n        return chain;\r\n    }\r\n\r\n    async getWalletBalance(): Promise<string | null> {\r\n        const cacheKey = `walletBalance_${this.currentChain}`;\r\n        const cachedData = await this.getCachedData<string>(cacheKey);\r\n        if (cachedData) {\r\n            elizaLogger.log(\r\n                `Returning cached wallet balance for chain: ${this.currentChain}`\r\n            );\r\n            return cachedData;\r\n        }\r\n\r\n        try {\r\n            const client = this.getPublicClient(this.currentChain);\r\n            const balance = await client.getBalance({\r\n                address: this.account.address,\r\n            });\r\n            const balanceFormatted = formatUnits(balance, 18);\r\n            this.setCachedData<string>(cacheKey, balanceFormatted);\r\n            elizaLogger.log(\r\n                \"Wallet balance cached for chain: \",\r\n                this.currentChain\r\n            );\r\n            return balanceFormatted;\r\n        } catch (error) {\r\n            console.error(\"Error getting wallet balance:\", error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    async getWalletBalanceForChain(\r\n        chainName: SupportedChain\r\n    ): Promise<string | null> {\r\n        try {\r\n            const client = this.getPublicClient(chainName);\r\n            const balance = await client.getBalance({\r\n                address: this.account.address,\r\n            });\r\n            return formatUnits(balance, 18);\r\n        } catch (error) {\r\n            console.error(\"Error getting wallet balance:\", error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    addChain(chain: Record<string, Chain>) {\r\n        this.setChains(chain);\r\n    }\r\n\r\n    switchChain(chainName: SupportedChain, customRpcUrl?: string) {\r\n        if (!this.chains[chainName]) {\r\n            const chain = WalletProvider.genChainFromName(\r\n                chainName,\r\n                customRpcUrl\r\n            );\r\n            this.addChain({ [chainName]: chain });\r\n        }\r\n        this.setCurrentChain(chainName);\r\n    }\r\n\r\n    private async readFromCache<T>(key: string): Promise<T | null> {\r\n        const cached = await this.cacheManager.get<T>(\r\n            path.join(this.cacheKey, key)\r\n        );\r\n        return cached;\r\n    }\r\n\r\n    private async writeToCache<T>(key: string, data: T): Promise<void> {\r\n        await this.cacheManager.set(path.join(this.cacheKey, key), data, {\r\n            expires: Date.now() + this.CACHE_EXPIRY_SEC * 1000,\r\n        });\r\n    }\r\n\r\n    private async getCachedData<T>(key: string): Promise<T | null> {\r\n        // Check in-memory cache first\r\n        const cachedData = this.cache.get<T>(key);\r\n        if (cachedData) {\r\n            return cachedData;\r\n        }\r\n\r\n        // Check file-based cache\r\n        const fileCachedData = await this.readFromCache<T>(key);\r\n        if (fileCachedData) {\r\n            // Populate in-memory cache\r\n            this.cache.set(key, fileCachedData);\r\n            return fileCachedData;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private async setCachedData<T>(cacheKey: string, data: T): Promise<void> {\r\n        // Set in-memory cache\r\n        this.cache.set(cacheKey, data);\r\n\r\n        // Write to file-based cache\r\n        await this.writeToCache(cacheKey, data);\r\n    }\r\n\r\n    private setAccount = (\r\n        accountOrPrivateKey: PrivateKeyAccount | `0x${string}`\r\n    ) => {\r\n        if (typeof accountOrPrivateKey === \"string\") {\r\n            this.account = privateKeyToAccount(accountOrPrivateKey);\r\n        } else {\r\n            this.account = accountOrPrivateKey;\r\n        }\r\n    };\r\n\r\n    private setChains = (chains?: Record<string, Chain>) => {\r\n        if (!chains) {\r\n            return;\r\n        }\r\n        for (const chain of Object.keys(chains)) {\r\n            this.chains[chain] = chains[chain];\r\n        }\r\n    };\r\n\r\n    private setCurrentChain = (chain: SupportedChain) => {\r\n        this.currentChain = chain;\r\n    };\r\n\r\n    private createHttpTransport = (chainName: SupportedChain) => {\r\n        const chain = this.chains[chainName];\r\n\r\n        if (chain.rpcUrls.custom) {\r\n            return http(chain.rpcUrls.custom.http[0]);\r\n        }\r\n        return http(chain.rpcUrls.default.http[0]);\r\n    };\r\n\r\n    static genChainFromName(\r\n        chainName: string,\r\n        customRpcUrl?: string | null\r\n    ): Chain {\r\n        const baseChain = viemChains[chainName];\r\n\r\n        if (!baseChain?.id) {\r\n            throw new Error(\"Invalid chain name\");\r\n        }\r\n\r\n        const viemChain: Chain = customRpcUrl\r\n            ? {\r\n                  ...baseChain,\r\n                  rpcUrls: {\r\n                      ...baseChain.rpcUrls,\r\n                      custom: {\r\n                          http: [customRpcUrl],\r\n                      },\r\n                  },\r\n              }\r\n            : baseChain;\r\n\r\n        return viemChain;\r\n    }\r\n}\r\n\r\nconst genChainsFromRuntime = (\r\n    runtime: IAgentRuntime\r\n): Record<string, Chain> => {\r\n    const chainNames =\r\n        (runtime.character.settings.chains?.evm as SupportedChain[]) || [];\r\n    const chains: Record<string, Chain> = {};\r\n\r\n    for (const chainName of chainNames) {\r\n        const rpcUrl = runtime.getSetting(\r\n            `ETHEREUM_PROVIDER_${chainName.toUpperCase()}`\r\n        );\r\n        const chain = WalletProvider.genChainFromName(chainName, rpcUrl);\r\n        chains[chainName] = chain;\r\n    }\r\n\r\n    const mainnet_rpcurl = runtime.getSetting(\"EVM_PROVIDER_URL\");\r\n    if (mainnet_rpcurl) {\r\n        const chain = WalletProvider.genChainFromName(\r\n            \"mainnet\",\r\n            mainnet_rpcurl\r\n        );\r\n        chains[\"mainnet\"] = chain;\r\n    }\r\n\r\n    return chains;\r\n};\r\n\r\nexport const initWalletProvider = async (runtime: IAgentRuntime) => {\r\n    const teeMode = runtime.getSetting(\"TEE_MODE\") || TEEMode.OFF;\r\n\r\n    const chains = genChainsFromRuntime(runtime);\r\n\r\n    if (teeMode !== TEEMode.OFF) {\r\n        const walletSecretSalt = runtime.getSetting(\"WALLET_SECRET_SALT\");\r\n        if (!walletSecretSalt) {\r\n            throw new Error(\r\n                \"WALLET_SECRET_SALT required when TEE_MODE is enabled\"\r\n            );\r\n        }\r\n\r\n        const deriveKeyProvider = new DeriveKeyProvider(teeMode);\r\n        const deriveKeyResult = await deriveKeyProvider.deriveEcdsaKeypair(\r\n            walletSecretSalt,\r\n            \"evm\",\r\n            runtime.agentId\r\n        );\r\n        return new WalletProvider(\r\n            deriveKeyResult.keypair,\r\n            runtime.cacheManager,\r\n            chains\r\n        );\r\n    } else {\r\n        const privateKey = runtime.getSetting(\r\n            \"EVM_PRIVATE_KEY\"\r\n        ) as `0x${string}`;\r\n        if (!privateKey) {\r\n            throw new Error(\"EVM_PRIVATE_KEY is missing\");\r\n        }\r\n        return new WalletProvider(privateKey, runtime.cacheManager, chains);\r\n    }\r\n};\r\n\r\nexport const evmWalletProvider: Provider = {\r\n    async get(\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        state?: State\r\n    ): Promise<string | null> {\r\n        try {\r\n            const walletProvider = await initWalletProvider(runtime);\r\n            const address = walletProvider.getAddress();\r\n            const balance = await walletProvider.getWalletBalance();\r\n            const chain = walletProvider.getCurrentChain();\r\n            const agentName = state?.agentName || \"The agent\";\r\n            return `${agentName}'s EVM Wallet Address: ${address}\\nBalance: ${balance} ${chain.nativeCurrency.symbol}\\nChain ID: ${chain.id}, Name: ${chain.name}`;\r\n        } catch (error) {\r\n            console.error(\"Error in EVM wallet provider:\", error);\r\n            return null;\r\n        }\r\n    },\r\n};\r\n","export const transferTemplate = `You are an AI assistant specialized in processing cryptocurrency transfer requests. Your task is to extract specific information from user messages and format it into a structured JSON response.\r\n\r\nFirst, review the recent messages from the conversation:\r\n\r\n<recent_messages>\r\n{{recentMessages}}\r\n</recent_messages>\r\n\r\nHere's a list of supported chains:\r\n<supported_chains>\r\n{{supportedChains}}\r\n</supported_chains>\r\n\r\nYour goal is to extract the following information about the requested transfer:\r\n1. Chain to execute on (must be one of the supported chains)\r\n2. Amount to transfer (in ETH, without the coin symbol)\r\n3. Recipient address (must be a valid Ethereum address)\r\n4. Token symbol or address (if not a native token transfer)\r\n\r\nBefore providing the final JSON output, show your reasoning process inside <analysis> tags. Follow these steps:\r\n\r\n1. Identify the relevant information from the user's message:\r\n   - Quote the part of the message mentioning the chain.\r\n   - Quote the part mentioning the amount.\r\n   - Quote the part mentioning the recipient address.\r\n   - Quote the part mentioning the token (if any).\r\n\r\n2. Validate each piece of information:\r\n   - Chain: List all supported chains and check if the mentioned chain is in the list.\r\n   - Amount: Attempt to convert the amount to a number to verify it's valid.\r\n   - Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\r\n   - Token: Note whether it's a native transfer or if a specific token is mentioned.\r\n\r\n3. If any information is missing or invalid, prepare an appropriate error message.\r\n\r\n4. If all information is valid, summarize your findings.\r\n\r\n5. Prepare the JSON structure based on your analysis.\r\n\r\nAfter your analysis, provide the final output in a JSON markdown block. All fields except 'token' are required. The JSON should have this structure:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"fromChain\": string,\r\n    \"amount\": string,\r\n    \"toAddress\": string,\r\n    \"token\": string | null\r\n}\r\n\\`\\`\\`\r\n\r\nRemember:\r\n- The chain name must be a string and must exactly match one of the supported chains.\r\n- The amount should be a string representing the number without any currency symbol.\r\n- The recipient address must be a valid Ethereum address starting with \"0x\".\r\n- If no specific token is mentioned (i.e., it's a native token transfer), set the \"token\" field to null.\r\n\r\nNow, process the user's request and provide your response.\r\n`;\r\n\r\nexport const bridgeTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested token bridge:\r\n- Token symbol or address to bridge\r\n- Source chain\r\n- Destination chain\r\n- Amount to bridge: Must be a string representing the amount in ether (only number without coin symbol, e.g., \"0.1\")\r\n- Destination address (if specified)\r\n\r\nRespond with a JSON markdown block containing only the extracted values:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"token\": string | null,\r\n    \"fromChain\": \"ethereum\" | \"abstract\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"fraxtal\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | \"alienx\" | \"gravity\" | null,\r\n    \"toChain\": \"ethereum\" | \"abstract\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"fraxtal\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | \"alienx\" | \"gravity\" |  null,\r\n    \"amount\": string | null,\r\n    \"toAddress\": string | null\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nexport const swapTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested token swap:\r\n- Input token symbol or address (the token being sold)\r\n- Output token symbol or address (the token being bought)\r\n- Amount to swap: Must be a string representing the amount in ether (only number without coin symbol, e.g., \"0.1\")\r\n- Chain to execute on\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"inputToken\": string | null,\r\n    \"outputToken\": string | null,\r\n    \"amount\": string | null,\r\n    \"chain\": \"ethereum\" | \"abstract\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | \"alienx\" | null,\r\n    \"slippage\": number | null\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nexport const proposeTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested proposal:\r\n- Targets\r\n- Values\r\n- Calldatas\r\n- Description\r\n- Governor address\r\n- Chain to execute on\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"targets\": string[] | null,\r\n    \"values\": string[] | null,\r\n    \"calldatas\": string[] | null,\r\n    \"description\": string | null,\r\n    \"governor\": string | null\r\n    \"chain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nexport const voteTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested vote:\r\n- Proposal ID\r\n- Support (1 for yes, 2 for no, 3 for abstain)\r\n- Governor address\r\n- Chain to execute on\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"proposalId\": string | null,\r\n    \"support\": number | null,\r\n    \"governor\": string | null\r\n    \"chain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nexport const queueProposalTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested proposal:\r\n- Targets\r\n- Values\r\n- Calldatas\r\n- Description\r\n- Governor address\r\n- Chain to execute on\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"targets\": string[] | null,\r\n    \"values\": string[] | null,\r\n    \"calldatas\": string[] | null,\r\n    \"description\": string | null,\r\n    \"governor\": string | null\r\n    \"chain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nexport const executeProposalTemplate = `Given the recent messages and wallet information below:\r\n\r\n{{recentMessages}}\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested proposal:\r\n- Targets\r\n- Values\r\n- Calldatas\r\n- Description\r\n- Governor address\r\n- Chain to execute on\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\r\n\r\n\\`\\`\\`json\r\n{\r\n    \"targets\": string[] | null,\r\n    \"values\": string[] | null,\r\n    \"calldatas\": string[] | null,\r\n    \"description\": string | null,\r\n    \"governor\": string | null\r\n    \"chain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\r\n}\r\n\\`\\`\\`\r\n`;\r\n","import type { IAgentRuntime, Memory, State } from \"@elizaos/core\";\r\nimport {\r\n    composeContext,\r\n    generateObjectDeprecated,\r\n    ModelClass,\r\n    elizaLogger,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    createConfig,\r\n    executeRoute,\r\n    type ExtendedChain,\r\n    getRoutes,\r\n    type Route,\r\n} from \"@lifi/sdk\";\r\n\r\nimport { initWalletProvider, type WalletProvider } from \"../providers/wallet\";\r\nimport { swapTemplate } from \"../templates\";\r\nimport type { SwapParams, SwapQuote, Transaction } from \"../types\";\r\nimport {\r\n    type Address,\r\n    type ByteArray,\r\n    encodeFunctionData,\r\n    type Hex,\r\n    parseAbi,\r\n    parseUnits,\r\n} from \"viem\";\r\nimport type { BebopRoute } from \"../types/index\";\r\n\r\nexport { swapTemplate };\r\n\r\nexport class SwapAction {\r\n    private lifiConfig;\r\n    private bebopChainsMap;\r\n\r\n    constructor(private walletProvider: WalletProvider) {\r\n        this.walletProvider = walletProvider;\r\n        const lifiChains: ExtendedChain[] = [];\r\n        for (const config of Object.values(this.walletProvider.chains)) {\r\n            try {\r\n                lifiChains.push({\r\n                    id: config.id,\r\n                    name: config.name,\r\n                    key: config.name.toLowerCase(),\r\n                    chainType: \"EVM\" as const,\r\n                    nativeToken: {\r\n                        ...config.nativeCurrency,\r\n                        chainId: config.id,\r\n                        address: \"0x0000000000000000000000000000000000000000\",\r\n                        coinKey: config.nativeCurrency.symbol,\r\n                        priceUSD: \"0\",\r\n                        logoURI: \"\",\r\n                        symbol: config.nativeCurrency.symbol,\r\n                        decimals: config.nativeCurrency.decimals,\r\n                        name: config.nativeCurrency.name,\r\n                    },\r\n                    rpcUrls: {\r\n                        public: { http: [config.rpcUrls.default.http[0]] },\r\n                    },\r\n                    blockExplorerUrls: [config.blockExplorers.default.url],\r\n                    metamask: {\r\n                        chainId: `0x${config.id.toString(16)}`,\r\n                        chainName: config.name,\r\n                        nativeCurrency: config.nativeCurrency,\r\n                        rpcUrls: [config.rpcUrls.default.http[0]],\r\n                        blockExplorerUrls: [config.blockExplorers.default.url],\r\n                    },\r\n                    coin: config.nativeCurrency.symbol,\r\n                    mainnet: true,\r\n                    diamondAddress:\r\n                        \"0x0000000000000000000000000000000000000000\",\r\n                } as ExtendedChain);\r\n            } catch {\r\n                // Skip chains with missing config in viem\r\n            }\r\n        }\r\n        this.lifiConfig = createConfig({\r\n            integrator: \"eliza\",\r\n            chains: lifiChains,\r\n        });\r\n        this.bebopChainsMap = {\r\n            mainnet: \"ethereum\",\r\n        };\r\n    }\r\n\r\n    async swap(params: SwapParams): Promise<Transaction> {\r\n        const walletClient = this.walletProvider.getWalletClient(params.chain);\r\n        const [fromAddress] = await walletClient.getAddresses();\r\n\r\n        // Getting quotes from different aggregators and sorting them by minAmount (amount after slippage)\r\n        const sortedQuotes: SwapQuote[] = await this.getSortedQuotes(\r\n            fromAddress,\r\n            params\r\n        );\r\n\r\n        // Trying to execute the best quote by amount, fallback to the next one if it fails\r\n        for (const quote of sortedQuotes) {\r\n            let res;\r\n            switch (quote.aggregator) {\r\n                case \"lifi\":\r\n                    res = await this.executeLifiQuote(quote);\r\n                    break;\r\n                case \"bebop\":\r\n                    res = await this.executeBebopQuote(quote, params);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"No aggregator found\");\r\n            }\r\n            if (res !== undefined) return res;\r\n        }\r\n        throw new Error(\"Execution failed\");\r\n    }\r\n\r\n    private async getSortedQuotes(\r\n        fromAddress: Address,\r\n        params: SwapParams\r\n    ): Promise<SwapQuote[]> {\r\n        const decimalsAbi = parseAbi([\r\n            \"function decimals() view returns (uint8)\",\r\n        ]);\r\n        const decimals = await this.walletProvider\r\n            .getPublicClient(params.chain)\r\n            .readContract({\r\n                address: params.fromToken,\r\n                abi: decimalsAbi,\r\n                functionName: \"decimals\",\r\n            });\r\n        const quotes: SwapQuote[] | undefined = await Promise.all([\r\n            this.getLifiQuote(fromAddress, params, decimals),\r\n            this.getBebopQuote(fromAddress, params, decimals),\r\n        ]);\r\n        const sortedQuotes: SwapQuote[] = quotes.filter(\r\n            (quote) => quote !== undefined\r\n        ) as SwapQuote[];\r\n        sortedQuotes.sort((a, b) =>\r\n            BigInt(a.minOutputAmount) > BigInt(b.minOutputAmount) ? -1 : 1\r\n        );\r\n        if (sortedQuotes.length === 0) throw new Error(\"No routes found\");\r\n        return sortedQuotes;\r\n    }\r\n\r\n    private async getLifiQuote(\r\n        fromAddress: Address,\r\n        params: SwapParams,\r\n        fromTokenDecimals: number\r\n    ): Promise<SwapQuote | undefined> {\r\n        try {\r\n            const routes = await getRoutes({\r\n                fromChainId: this.walletProvider.getChainConfigs(params.chain)\r\n                    .id,\r\n                toChainId: this.walletProvider.getChainConfigs(params.chain).id,\r\n                fromTokenAddress: params.fromToken,\r\n                toTokenAddress: params.toToken,\r\n                fromAmount: parseUnits(\r\n                    params.amount,\r\n                    fromTokenDecimals\r\n                ).toString(),\r\n                fromAddress: fromAddress,\r\n                options: {\r\n                    slippage: params.slippage / 100 || 0.005,\r\n                    order: \"RECOMMENDED\",\r\n                },\r\n            });\r\n            if (!routes.routes.length) throw new Error(\"No routes found\");\r\n            return {\r\n                aggregator: \"lifi\",\r\n                minOutputAmount: routes.routes[0].steps[0].estimate.toAmountMin,\r\n                swapData: routes.routes[0],\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in getLifiQuote:\", error.message);\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    private async getBebopQuote(\r\n        fromAddress: Address,\r\n        params: SwapParams,\r\n        fromTokenDecimals: number\r\n    ): Promise<SwapQuote | undefined> {\r\n        try {\r\n            const url = `https://api.bebop.xyz/router/${this.bebopChainsMap[params.chain] ?? params.chain}/v1/quote`;\r\n            const reqParams = new URLSearchParams({\r\n                sell_tokens: params.fromToken,\r\n                buy_tokens: params.toToken,\r\n                sell_amounts: parseUnits(\r\n                    params.amount,\r\n                    fromTokenDecimals\r\n                ).toString(),\r\n                taker_address: fromAddress,\r\n                approval_type: \"Standard\",\r\n                skip_validation: \"true\",\r\n                gasless: \"false\",\r\n                source: \"eliza\",\r\n            });\r\n            const response = await fetch(`${url}?${reqParams.toString()}`, {\r\n                method: \"GET\",\r\n                headers: { accept: \"application/json\" },\r\n            });\r\n            if (!response.ok) {\r\n                throw Error(response.statusText);\r\n            }\r\n            const data = await response.json();\r\n            const route: BebopRoute = {\r\n                data: data.routes[0].quote.tx.data,\r\n                sellAmount: parseUnits(\r\n                    params.amount,\r\n                    fromTokenDecimals\r\n                ).toString(),\r\n                approvalTarget: data.routes[0].quote\r\n                    .approvalTarget as `0x${string}`,\r\n                from: data.routes[0].quote.tx.from as `0x${string}`,\r\n                value: data.routes[0].quote.tx.value.toString(),\r\n                to: data.routes[0].quote.tx.to as `0x${string}`,\r\n                gas: data.routes[0].quote.tx.gas.toString(),\r\n                gasPrice: data.routes[0].quote.tx.gasPrice.toString(),\r\n            };\r\n            return {\r\n                aggregator: \"bebop\",\r\n                minOutputAmount:\r\n                    data.routes[0].quote.buyTokens[\r\n                        params.toToken\r\n                    ].minimumAmount.toString(),\r\n                swapData: route,\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in getBebopQuote:\", error.message);\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    private async executeLifiQuote(\r\n        quote: SwapQuote\r\n    ): Promise<Transaction | undefined> {\r\n        try {\r\n            const route: Route = quote.swapData as Route;\r\n            const execution = await executeRoute(\r\n                quote.swapData as Route,\r\n                this.lifiConfig\r\n            );\r\n            const process = execution.steps[0]?.execution?.process[0];\r\n\r\n            if (!process?.status || process.status === \"FAILED\") {\r\n                throw new Error(\"Transaction failed\");\r\n            }\r\n            return {\r\n                hash: process.txHash as `0x${string}`,\r\n                from: route.fromAddress! as `0x${string}`,\r\n                to: route.steps[0].estimate.approvalAddress as `0x${string}`,\r\n                value: 0n,\r\n                data: process.data as `0x${string}`,\r\n                chainId: route.fromChainId,\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(`Failed to execute lifi quote: ${error}`);\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    private async executeBebopQuote(\r\n        quote: SwapQuote,\r\n        params: SwapParams\r\n    ): Promise<Transaction | undefined> {\r\n        try {\r\n            const bebopRoute: BebopRoute = quote.swapData as BebopRoute;\r\n            const allowanceAbi = parseAbi([\r\n                \"function allowance(address,address) view returns (uint256)\",\r\n            ]);\r\n            const allowance: bigint = await this.walletProvider\r\n                .getPublicClient(params.chain)\r\n                .readContract({\r\n                    address: params.fromToken,\r\n                    abi: allowanceAbi,\r\n                    functionName: \"allowance\",\r\n                    args: [bebopRoute.from, bebopRoute.approvalTarget],\r\n                });\r\n            if (allowance < BigInt(bebopRoute.sellAmount)) {\r\n                const approvalData = encodeFunctionData({\r\n                    abi: parseAbi([\"function approve(address,uint256)\"]),\r\n                    functionName: \"approve\",\r\n                    args: [\r\n                        bebopRoute.approvalTarget,\r\n                        BigInt(bebopRoute.sellAmount),\r\n                    ],\r\n                });\r\n                await this.walletProvider\r\n                    .getWalletClient(params.chain)\r\n                    .sendTransaction({\r\n                        account: this.walletProvider.getWalletClient(\r\n                            params.chain\r\n                        ).account,\r\n                        to: params.fromToken,\r\n                        value: 0n,\r\n                        data: approvalData,\r\n                        kzg: {\r\n                            blobToKzgCommitment: (\r\n                                _: ByteArray\r\n                            ): ByteArray => {\r\n                                throw new Error(\"Function not implemented.\");\r\n                            },\r\n                            computeBlobKzgProof: (\r\n                                _blob: ByteArray,\r\n                                _commitment: ByteArray\r\n                            ): ByteArray => {\r\n                                throw new Error(\"Function not implemented.\");\r\n                            },\r\n                        },\r\n                        chain: undefined,\r\n                    });\r\n            }\r\n            const hash = await this.walletProvider\r\n                .getWalletClient(params.chain)\r\n                .sendTransaction({\r\n                    account: this.walletProvider.getWalletClient(params.chain)\r\n                        .account,\r\n                    to: bebopRoute.to,\r\n                    value: BigInt(bebopRoute.value),\r\n                    data: bebopRoute.data as Hex,\r\n                    kzg: {\r\n                        blobToKzgCommitment: (\r\n                            _: ByteArray\r\n                        ): ByteArray => {\r\n                            throw new Error(\"Function not implemented.\");\r\n                        },\r\n                        computeBlobKzgProof: (\r\n                            _blob: ByteArray,\r\n                            _commitment: ByteArray\r\n                        ): ByteArray => {\r\n                            throw new Error(\"Function not implemented.\");\r\n                        },\r\n                    },\r\n                    chain: undefined,\r\n                });\r\n            return {\r\n                hash,\r\n                from: this.walletProvider.getWalletClient(params.chain).account\r\n                    .address,\r\n                to: bebopRoute.to,\r\n                value: BigInt(bebopRoute.value),\r\n                data: bebopRoute.data as Hex,\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(`Failed to execute bebop quote: ${error}`);\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n\r\nexport const swapAction = {\r\n    name: \"swap\",\r\n    description: \"Swap tokens on the same chain\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        state: State,\r\n        _options: any,\r\n        callback?: any\r\n    ) => {\r\n        elizaLogger.log(\"Swap action handler called\");\r\n        const walletProvider = await initWalletProvider(runtime);\r\n        const action = new SwapAction(walletProvider);\r\n\r\n        // Compose swap context\r\n        const swapContext = composeContext({\r\n            state,\r\n            template: swapTemplate,\r\n        });\r\n        const content = await generateObjectDeprecated({\r\n            runtime,\r\n            context: swapContext,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        const swapOptions: SwapParams = {\r\n            chain: content.chain,\r\n            fromToken: content.inputToken,\r\n            toToken: content.outputToken,\r\n            amount: content.amount,\r\n            slippage: content.slippage,\r\n        };\r\n\r\n        try {\r\n            const swapResp = await action.swap(swapOptions);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Successfully swap ${swapOptions.amount} ${swapOptions.fromToken} tokens to ${swapOptions.toToken}\\nTransaction Hash: ${swapResp.hash}`,\r\n                    content: {\r\n                        success: true,\r\n                        hash: swapResp.hash,\r\n                        recipient: swapResp.to,\r\n                        chain: content.chain,\r\n                    },\r\n                });\r\n            }\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in swap handler:\", error.message);\r\n            if (callback) {\r\n                callback({ text: `Error: ${error.message}` });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    template: swapTemplate,\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"user\",\r\n                content: {\r\n                    text: \"Swap 1 ETH for USDC on Base\",\r\n                    action: \"TOKEN_SWAP\",\r\n                },\r\n            },\r\n        ],\r\n    ],\r\n    similes: [\"TOKEN_SWAP\", \"EXCHANGE_TOKENS\", \"TRADE_TOKENS\"],\r\n}; // TODO: add more examples\r\n","import { type ByteArray, formatEther, parseEther, type Hex } from \"viem\";\r\nimport {\r\n    type Action,\r\n    composeContext,\r\n    generateObjectDeprecated,\r\n    type HandlerCallback,\r\n    ModelClass,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    type State,\r\n} from \"@elizaos/core\";\r\n\r\nimport { initWalletProvider, type WalletProvider } from \"../providers/wallet\";\r\nimport type { Transaction, TransferParams } from \"../types\";\r\nimport { transferTemplate } from \"../templates\";\r\n\r\n// Exported for tests\r\nexport class TransferAction {\r\n    constructor(private walletProvider: WalletProvider) {}\r\n\r\n    async transfer(params: TransferParams): Promise<Transaction> {\r\n        console.log(\r\n            `Transferring: ${params.amount} tokens to (${params.toAddress} on ${params.fromChain})`\r\n        );\r\n\r\n        if (!params.data) {\r\n            params.data = \"0x\";\r\n        }\r\n\r\n        this.walletProvider.switchChain(params.fromChain);\r\n\r\n        const walletClient = this.walletProvider.getWalletClient(\r\n            params.fromChain\r\n        );\r\n\r\n        try {\r\n            const hash = await walletClient.sendTransaction({\r\n                account: walletClient.account,\r\n                to: params.toAddress,\r\n                value: parseEther(params.amount),\r\n                data: params.data as Hex,\r\n                kzg: {\r\n                    blobToKzgCommitment: (_: ByteArray): ByteArray => {\r\n                        throw new Error(\"Function not implemented.\");\r\n                    },\r\n                    computeBlobKzgProof: (\r\n                        _blob: ByteArray,\r\n                        _commitment: ByteArray\r\n                    ): ByteArray => {\r\n                        throw new Error(\"Function not implemented.\");\r\n                    },\r\n                },\r\n                chain: undefined,\r\n            });\r\n\r\n            return {\r\n                hash,\r\n                from: walletClient.account.address,\r\n                to: params.toAddress,\r\n                value: parseEther(params.amount),\r\n                data: params.data as Hex,\r\n            };\r\n        } catch (error) {\r\n            throw new Error(`Transfer failed: ${error.message}`);\r\n        }\r\n    }\r\n}\r\n\r\nconst buildTransferDetails = async (\r\n    state: State,\r\n    runtime: IAgentRuntime,\r\n    wp: WalletProvider\r\n): Promise<TransferParams> => {\r\n    const chains = Object.keys(wp.chains);\r\n    state.supportedChains = chains.map((item) => `\"${item}\"`).join(\"|\");\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: transferTemplate,\r\n    });\r\n\r\n    const transferDetails = (await generateObjectDeprecated({\r\n        runtime,\r\n        context,\r\n        modelClass: ModelClass.SMALL,\r\n    })) as TransferParams;\r\n\r\n    const existingChain = wp.chains[transferDetails.fromChain];\r\n\r\n    if (!existingChain) {\r\n        throw new Error(\r\n            \"The chain \" +\r\n                transferDetails.fromChain +\r\n                \" not configured yet. Add the chain or choose one from configured: \" +\r\n                chains.toString()\r\n        );\r\n    }\r\n\r\n    return transferDetails;\r\n};\r\n\r\nexport const transferAction: Action = {\r\n    name: \"transfer\",\r\n    description: \"Transfer tokens between addresses on the same chain\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: any,\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n\r\n        console.log(\"Transfer action handler called\");\r\n        const walletProvider = await initWalletProvider(runtime);\r\n        const action = new TransferAction(walletProvider);\r\n\r\n        // Compose transfer context\r\n        const paramOptions = await buildTransferDetails(\r\n            state,\r\n            runtime,\r\n            walletProvider\r\n        );\r\n\r\n        try {\r\n            const transferResp = await action.transfer(paramOptions);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Successfully transferred ${paramOptions.amount} tokens to ${paramOptions.toAddress}\\nTransaction Hash: ${transferResp.hash}`,\r\n                    content: {\r\n                        success: true,\r\n                        hash: transferResp.hash,\r\n                        amount: formatEther(transferResp.value),\r\n                        recipient: transferResp.to,\r\n                        chain: paramOptions.fromChain,\r\n                    },\r\n                });\r\n            }\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error during token transfer:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error transferring tokens: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    validate: async (runtime: IAgentRuntime) => {\r\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\r\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"assistant\",\r\n                content: {\r\n                    text: \"I'll help you transfer 1 ETH to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\r\n                    action: \"SEND_TOKENS\",\r\n                },\r\n            },\r\n            {\r\n                user: \"user\",\r\n                content: {\r\n                    text: \"Transfer 1 ETH to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\r\n                    action: \"SEND_TOKENS\",\r\n                },\r\n            },\r\n        ],\r\n    ],\r\n    similes: [\"SEND_TOKENS\", \"TOKEN_TRANSFER\", \"MOVE_TOKENS\"],\r\n};\r\n","import type { Route, Token } from \"@lifi/types\";\r\nimport type {\r\n    Account,\r\n    Address,\r\n    Chain,\r\n    Hash,\r\n    HttpTransport,\r\n    PublicClient,\r\n    WalletClient,\r\n    Log,\r\n} from \"viem\";\r\nimport * as viemChains from \"viem/chains\";\r\n\r\nconst _SupportedChainList = Object.keys(viemChains) as Array<\r\n    keyof typeof viemChains\r\n>;\r\nexport type SupportedChain = (typeof _SupportedChainList)[number];\r\n\r\n// Transaction types\r\nexport interface Transaction {\r\n    hash: Hash;\r\n    from: Address;\r\n    to: Address;\r\n    value: bigint;\r\n    data?: `0x${string}`;\r\n    chainId?: number;\r\n    logs?: Log[];\r\n}\r\n\r\n// Token types\r\nexport interface TokenWithBalance {\r\n    token: Token;\r\n    balance: bigint;\r\n    formattedBalance: string;\r\n    priceUSD: string;\r\n    valueUSD: string;\r\n}\r\n\r\nexport interface WalletBalance {\r\n    chain: SupportedChain;\r\n    address: Address;\r\n    totalValueUSD: string;\r\n    tokens: TokenWithBalance[];\r\n}\r\n\r\n// Chain configuration\r\nexport interface ChainMetadata {\r\n    chainId: number;\r\n    name: string;\r\n    chain: Chain;\r\n    rpcUrl: string;\r\n    nativeCurrency: {\r\n        name: string;\r\n        symbol: string;\r\n        decimals: number;\r\n    };\r\n    blockExplorerUrl: string;\r\n}\r\n\r\nexport interface ChainConfig {\r\n    chain: Chain;\r\n    publicClient: PublicClient<HttpTransport, Chain, Account | undefined>;\r\n    walletClient?: WalletClient;\r\n}\r\n\r\n// Action parameters\r\nexport interface TransferParams {\r\n    fromChain: SupportedChain;\r\n    toAddress: Address;\r\n    amount: string;\r\n    data?: `0x${string}`;\r\n}\r\n\r\nexport interface SwapParams {\r\n    chain: SupportedChain;\r\n    fromToken: Address;\r\n    toToken: Address;\r\n    amount: string;\r\n    slippage?: number;\r\n}\r\n\r\nexport interface BebopRoute {\r\n    data: string;\r\n    approvalTarget: Address;\r\n    sellAmount: string;\r\n    from: Address;\r\n    to: Address;\r\n    value: string;\r\n    gas: string;\r\n    gasPrice: string;\r\n}\r\n\r\nexport interface SwapQuote {\r\n    aggregator: \"lifi\" | \"bebop\";\r\n    minOutputAmount: string;\r\n    swapData: Route | BebopRoute;\r\n}\r\n\r\nexport interface BridgeParams {\r\n    fromChain: SupportedChain;\r\n    toChain: SupportedChain;\r\n    fromToken: Address;\r\n    toToken: Address;\r\n    amount: string;\r\n    toAddress?: Address;\r\n}\r\n\r\n// Plugin configuration\r\nexport interface EvmPluginConfig {\r\n    rpcUrl?: {\r\n        ethereum?: string;\r\n        abstract?: string;\r\n        base?: string;\r\n        sepolia?: string;\r\n        bsc?: string;\r\n        arbitrum?: string;\r\n        avalanche?: string;\r\n        polygon?: string;\r\n        optimism?: string;\r\n        cronos?: string;\r\n        gnosis?: string;\r\n        fantom?: string;\r\n        fraxtal?: string;\r\n        klaytn?: string;\r\n        celo?: string;\r\n        moonbeam?: string;\r\n        aurora?: string;\r\n        harmonyOne?: string;\r\n        moonriver?: string;\r\n        arbitrumNova?: string;\r\n        mantle?: string;\r\n        linea?: string;\r\n        scroll?: string;\r\n        filecoin?: string;\r\n        taiko?: string;\r\n        zksync?: string;\r\n        canto?: string;\r\n        alienx?: string;\r\n        gravity?: string;\r\n    };\r\n    secrets?: {\r\n        EVM_PRIVATE_KEY: string;\r\n    };\r\n    testMode?: boolean;\r\n    multicall?: {\r\n        batchSize?: number;\r\n        wait?: number;\r\n    };\r\n}\r\n\r\n// LiFi types\r\nexport type LiFiStatus = {\r\n    status: \"PENDING\" | \"DONE\" | \"FAILED\";\r\n    substatus?: string;\r\n    error?: Error;\r\n};\r\n\r\nexport type LiFiRoute = {\r\n    transactionHash: Hash;\r\n    transactionData: `0x${string}`;\r\n    toAddress: Address;\r\n    status: LiFiStatus;\r\n};\r\n\r\n// Provider types\r\nexport interface TokenData extends Token {\r\n    symbol: string;\r\n    decimals: number;\r\n    address: Address;\r\n    name: string;\r\n    logoURI?: string;\r\n    chainId: number;\r\n}\r\n\r\nexport interface TokenPriceResponse {\r\n    priceUSD: string;\r\n    token: TokenData;\r\n}\r\n\r\nexport interface TokenListResponse {\r\n    tokens: TokenData[];\r\n}\r\n\r\nexport interface ProviderError extends Error {\r\n    code?: number;\r\n    data?: unknown;\r\n}\r\n\r\nexport enum VoteType {\r\n    AGAINST = 0,\r\n    FOR = 1,\r\n    ABSTAIN = 2,\r\n}\r\n\r\nexport interface Proposal {\r\n    targets: Address[];\r\n    values: bigint[];\r\n    calldatas: `0x${string}`[];\r\n    description: string;\r\n}\r\n\r\nexport interface VoteParams {\r\n    chain: SupportedChain;\r\n    governor: Address;\r\n    proposalId: string;\r\n    support: VoteType;\r\n}\r\n\r\nexport interface QueueProposalParams extends Proposal {\r\n    chain: SupportedChain;\r\n    governor: Address;\r\n}\r\n\r\nexport interface ExecuteProposalParams extends Proposal {\r\n    chain: SupportedChain;\r\n    governor: Address;\r\n    proposalId: string;\r\n}\r\n\r\nexport interface ProposeProposalParams extends Proposal {\r\n    chain: SupportedChain;\r\n    governor: Address;\r\n}\r\n","export * from \"./actions/bridge\";\r\nexport * from \"./actions/swap\";\r\nexport * from \"./actions/transfer\";\r\nexport * from \"./providers/wallet\";\r\nexport * from \"./types\";\r\n\r\nimport type { Plugin } from \"@elizaos/core\";\r\nimport { bridgeAction } from \"./actions/bridge\";\r\nimport { swapAction } from \"./actions/swap\";\r\nimport { transferAction } from \"./actions/transfer\";\r\nimport { evmWalletProvider } from \"./providers/wallet\";\r\n\r\nexport const evmPlugin: Plugin = {\r\n    name: \"evm\",\r\n    description: \"EVM blockchain integration plugin\",\r\n    providers: [evmWalletProvider],\r\n    evaluators: [],\r\n    services: [],\r\n    actions: [transferAction, bridgeAction, swapAction],\r\n};\r\n\r\nexport default evmPlugin;\r\n"],"mappings":"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","names":["composeContext","generateObjectDeprecated","ModelClass","elizaLogger","createConfig","executeRoute","getRoutes","createConfig","getRoutes","elizaLogger","executeRoute","composeContext","generateObjectDeprecated","ModelClass","parseEther","composeContext","generateObjectDeprecated","ModelClass","parseEther","composeContext","generateObjectDeprecated","ModelClass","viemChains","VoteType"]}