{"version":3,"sources":["../src/index.ts","../src/echoChamberClient.ts","../src/interactions.ts","../src/environment.ts","../src/types.ts"],"sourcesContent":["import { elizaLogger, type Client, type IAgentRuntime, type Plugin } from \"@elizaos/core\";\r\nimport { EchoChamberClient } from \"./echoChamberClient\";\r\nimport { InteractionClient } from \"./interactions\";\r\nimport type { EchoChamberConfig } from \"./types\";\r\nimport { validateEchoChamberConfig } from \"./environment\";\r\n\r\nexport const EchoChamberClientInterface: Client = {\r\n    async start(runtime: IAgentRuntime) {\r\n        try {\r\n            // Validate configuration before starting\r\n            await validateEchoChamberConfig(runtime);\r\n\r\n            const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\r\n            const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\r\n\r\n            if (!apiKey || !apiUrl) {\r\n                throw new Error(\r\n                    \"ECHOCHAMBERS_API_KEY/ECHOCHAMBERS_API_URL is required\"\r\n                );\r\n            }\r\n\r\n            const config: EchoChamberConfig = {\r\n                apiUrl,\r\n                apiKey,\r\n                username:\r\n                    runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\r\n                    `agent-${runtime.agentId}`,\r\n                model: runtime.modelProvider,\r\n                rooms: runtime\r\n                    .getSetting(\"ECHOCHAMBERS_ROOMS\")\r\n                    ?.split(\",\")\r\n                    .map((r) => r.trim()) || [\"general\"],\r\n            };\r\n\r\n            elizaLogger.log(\"Starting EchoChambers client...\");\r\n\r\n            // Initialize the API client\r\n            const client = new EchoChamberClient(runtime, config);\r\n            await client.start();\r\n\r\n            // Initialize the interaction handler\r\n            const interactionClient = new InteractionClient(client, runtime);\r\n            await interactionClient.start();\r\n\r\n            elizaLogger.success(\r\n                `‚úÖ EchoChambers client successfully started for character ${runtime.character.name}`\r\n            );\r\n\r\n            return { client, interactionClient };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Failed to start EchoChambers client:\", error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    async stop(runtime: IAgentRuntime) {\r\n        try {\r\n            elizaLogger.warn(\"Stopping EchoChambers client...\");\r\n\r\n            // Get client instances if they exist\r\n            const clients = (runtime as any).clients?.filter(\r\n                (c: any) =>\r\n                    c instanceof EchoChamberClient ||\r\n                    c instanceof InteractionClient\r\n            );\r\n\r\n            for (const client of clients) {\r\n                await client.stop();\r\n            }\r\n\r\n            elizaLogger.success(\"EchoChambers client stopped successfully\");\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error stopping EchoChambers client:\", error);\r\n            throw error;\r\n        }\r\n    },\r\n};\r\n\r\nexport const echoChambersPlugin: Plugin = {\r\n    name: \"echochambers\",\r\n    description:\r\n        \"Plugin for interacting with EchoChambers API to enable multi-agent communication\",\r\n    actions: [], // No custom actions needed - core functionality handled by client\r\n    evaluators: [], // No custom evaluators needed\r\n    providers: [], // No custom providers needed\r\n    clients: [EchoChamberClientInterface],\r\n};\r\n\r\nexport default echoChambersPlugin;\r\n\r\n// Export types and classes\r\nexport * from \"./types\";\r\nexport { EchoChamberClient } from \"./echoChamberClient\";\r\nexport { InteractionClient } from \"./interactions\";\r\n","import { elizaLogger, type IAgentRuntime } from \"@elizaos/core\";\r\nimport type {\r\n    ChatMessage,\r\n    ChatRoom,\r\n    EchoChamberConfig,\r\n    ModelInfo,\r\n    ListRoomsResponse,\r\n    RoomHistoryResponse,\r\n    MessageResponse,\r\n} from \"./types\";\r\n\r\nconst MAX_RETRIES = 3;\r\n\r\nconst RETRY_DELAY = 5000;\r\n\r\nexport class EchoChamberClient {\r\n    private runtime: IAgentRuntime;\r\n    private config: EchoChamberConfig;\r\n    private apiUrl: string;\r\n    private modelInfo: ModelInfo;\r\n    private watchedRooms: Set<string> = new Set();\r\n\r\n    constructor(runtime: IAgentRuntime, config: EchoChamberConfig) {\r\n        this.runtime = runtime;\r\n        this.config = config;\r\n        this.apiUrl = `${config.apiUrl}/api/rooms`;\r\n        this.modelInfo = {\r\n            username: config.username || `agent-${runtime.agentId}`,\r\n            model: config.model || runtime.modelProvider,\r\n        };\r\n    }\r\n\r\n    public getUsername(): string {\r\n        return this.modelInfo.username;\r\n    }\r\n\r\n    public getModelInfo(): ModelInfo {\r\n        return { ...this.modelInfo };\r\n    }\r\n\r\n    public getConfig(): EchoChamberConfig {\r\n        return { ...this.config };\r\n    }\r\n\r\n    private getAuthHeaders(): { [key: string]: string } {\r\n        return {\r\n            \"Content-Type\": \"application/json\",\r\n            \"x-api-key\": this.config.apiKey,\r\n        };\r\n    }\r\n\r\n    public async addWatchedRoom(roomId: string): Promise<void> {\r\n        try {\r\n            const rooms = await this.listRooms();\r\n            const room = rooms.find((r) => r.id === roomId);\r\n\r\n            if (!room) {\r\n                throw new Error(`Room ${roomId} not found`);\r\n            }\r\n\r\n            this.watchedRooms.add(roomId);\r\n            elizaLogger.success(`Now watching room: ${room.name}`);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error adding watched room:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    public removeWatchedRoom(roomId: string): void {\r\n        this.watchedRooms.delete(roomId);\r\n        elizaLogger.success(`Stopped watching room: ${roomId}`);\r\n    }\r\n\r\n    public getWatchedRooms(): string[] {\r\n        return Array.from(this.watchedRooms);\r\n    }\r\n\r\n    private async retryOperation<T>(\r\n        operation: () => Promise<T>,\r\n        retries: number = MAX_RETRIES\r\n    ): Promise<T> {\r\n        for (let i = 0; i < retries; i++) {\r\n            try {\r\n                return await operation();\r\n            } catch (error) {\r\n                if (i === retries - 1) throw error;\r\n                const delay = RETRY_DELAY * (2 ** i);\r\n                elizaLogger.warn(`Retrying operation in ${delay}ms...`);\r\n                await new Promise((resolve) => setTimeout(resolve, delay));\r\n            }\r\n        }\r\n        throw new Error(\"Max retries exceeded\");\r\n    }\r\n\r\n    public async start(): Promise<void> {\r\n        elizaLogger.log(\"üöÄ Starting EchoChamber client...\");\r\n        try {\r\n            await this.retryOperation(() => this.listRooms());\r\n\r\n            for (const room of this.config.rooms) {\r\n                await this.addWatchedRoom(room);\r\n            }\r\n\r\n            elizaLogger.success(\r\n                `‚úÖ EchoChamber client started for ${this.modelInfo.username}`\r\n            );\r\n            elizaLogger.info(\r\n                `Watching rooms: ${Array.from(this.watchedRooms).join(\", \")}`\r\n            );\r\n        } catch (error) {\r\n            elizaLogger.error(\"‚ùå Failed to start EchoChamber client:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        this.watchedRooms.clear();\r\n        elizaLogger.log(\"Stopping EchoChamber client...\");\r\n    }\r\n\r\n    public async listRooms(tags?: string[]): Promise<ChatRoom[]> {\r\n        try {\r\n            const url = new URL(this.apiUrl);\r\n            if (tags?.length) {\r\n                url.searchParams.append(\"tags\", tags.join(\",\"));\r\n            }\r\n\r\n            const response = await fetch(url.toString());\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to list rooms: ${response.statusText}`);\r\n            }\r\n\r\n            const data = (await response.json()) as ListRoomsResponse;\r\n            return data.rooms;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error listing rooms:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    public async getRoomHistory(roomId: string): Promise<ChatMessage[]> {\r\n        return this.retryOperation(async () => {\r\n            const response = await fetch(`${this.apiUrl}/${roomId}/history`);\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `Failed to get room history: ${response.statusText}`\r\n                );\r\n            }\r\n\r\n            const data = (await response.json()) as RoomHistoryResponse;\r\n            return data.messages;\r\n        });\r\n    }\r\n\r\n    public async sendMessage(\r\n        roomId: string,\r\n        content: string\r\n    ): Promise<ChatMessage> {\r\n        return this.retryOperation(async () => {\r\n            const response = await fetch(`${this.apiUrl}/${roomId}/message`, {\r\n                method: \"POST\",\r\n                headers: this.getAuthHeaders(),\r\n                body: JSON.stringify({\r\n                    content,\r\n                    sender: this.modelInfo,\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `Failed to send message: ${response.statusText}`\r\n                );\r\n            }\r\n\r\n            const data = (await response.json()) as MessageResponse;\r\n            return data.message;\r\n        });\r\n    }\r\n\r\n    public async shouldInitiateConversation(room: ChatRoom): Promise<boolean> {\r\n        try {\r\n            const history = await this.getRoomHistory(room.id);\r\n            if (!history?.length) return true; // Empty room is good to start\r\n\r\n            const recentMessages = history\r\n                .filter((msg) => msg != null) // Filter out null messages\r\n                .sort(\r\n                    (a, b) =>\r\n                        new Date(b.timestamp).getTime() -\r\n                        new Date(a.timestamp).getTime()\r\n                );\r\n\r\n            if (!recentMessages.length) return true; // No valid messages\r\n\r\n            const lastMessageTime = new Date(\r\n                recentMessages[0].timestamp\r\n            ).getTime();\r\n            const timeSinceLastMessage = Date.now() - lastMessageTime;\r\n\r\n            const quietPeriodSeconds = Number(\r\n                this.runtime.getSetting(\"ECHOCHAMBERS_QUIET_PERIOD\") || 300 // 5 minutes in seconds\r\n            );\r\n            const quietPeriod = quietPeriodSeconds * 1000; // Convert to milliseconds\r\n\r\n            if (timeSinceLastMessage < quietPeriod) {\r\n                elizaLogger.debug(\r\n                    `Room ${room.name} active recently, skipping`\r\n                );\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            elizaLogger.error(`Error checking conversation state: ${error}`);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","import {\r\n    composeContext,\r\n    generateMessageResponse,\r\n    generateShouldRespond,\r\n    messageCompletionFooter,\r\n    shouldRespondFooter,\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    ModelClass,\r\n    stringToUuid,\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n} from \"@elizaos/core\";\r\nimport type { EchoChamberClient } from \"./echoChamberClient\";\r\nimport type { ChatMessage, ChatRoom } from \"./types\";\r\n\r\nfunction createMessageTemplate(currentRoom: string, roomTopic: string) {\r\n    return `\r\n# About {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n{{knowledge}}\r\n\r\nCurrent Room: ${currentRoom}\r\nRoom Topic: ${roomTopic}\r\n\r\n{{messageDirections}}\r\n\r\nRecent conversation history:\r\n{{recentMessages}}\r\n\r\nThread Context:\r\n{{formattedConversation}}\r\n\r\n# Task: Generate a response in the voice and style of {{agentName}} while:\r\n1. Staying relevant to the room's topic\r\n2. Maintaining conversation context\r\n3. Being helpful but not overly talkative\r\n4. Responding naturally to direct questions or mentions\r\n5. Contributing meaningfully to ongoing discussions\r\n\r\nRemember:\r\n- Keep responses concise and focused\r\n- Stay on topic for the current room\r\n- Don't repeat information already shared\r\n- Be natural and conversational\r\n\r\n${messageCompletionFooter}`;\r\n}\r\n\r\nfunction createShouldRespondTemplate(currentRoom: string, roomTopic: string) {\r\n    return `\r\n# About {{agentName}}:\r\n{{bio}}\r\n{{knowledge}}\r\n\r\nCurrent Room: ${currentRoom}\r\nRoom Topic: ${roomTopic}\r\n\r\nResponse options are [RESPOND], [IGNORE] and [STOP].\r\n\r\n{{agentName}} should:\r\n- RESPOND when:\r\n  * Directly mentioned or asked a question\r\n  * Can contribute relevant expertise to the discussion\r\n  * Topic aligns with their knowledge and background\r\n  * Conversation is active and engaging\r\n\r\n- IGNORE when:\r\n  * Message is not relevant to their expertise\r\n  * Already responded recently without new information to add\r\n  * Conversation has moved to a different topic\r\n  * Message is too short or lacks substance\r\n  * Other participants are handling the discussion well\r\n\r\n- STOP when:\r\n  * Asked to stop participating\r\n  * Conversation has concluded\r\n  * Discussion has completely diverged from their expertise\r\n  * Room topic has changed significantly\r\n\r\nRecent messages:\r\n{{recentMessages}}\r\n\r\nThread Context:\r\n{{formattedConversation}}\r\n\r\n# Task: Choose whether {{agentName}} should respond to the last message.\r\nConsider:\r\n1. Message relevance to {{agentName}}'s expertise\r\n2. Current conversation context\r\n3. Time since last response\r\n4. Value of potential contribution\r\n\r\n${shouldRespondFooter}`;\r\n}\r\n\r\nfunction createConversationStarterTemplate(\r\n    currentRoom: string,\r\n    roomTopic: string\r\n) {\r\n    return `\r\n# Room Context:\r\nRoom: ${currentRoom}\r\nTopic: ${roomTopic}\r\n\r\n# About {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n{{knowledge}}\r\n\r\n# Task: Generate a conversation starter that:\r\n1. Is specifically relevant to the room's topic\r\n2. Draws from {{agentName}}'s knowledge\r\n3. Encourages discussion and engagement\r\n4. Is natural and conversational\r\n\r\nKeep it concise and focused on the room's topic.\r\n${messageCompletionFooter}`;\r\n}\r\n\r\nexport class InteractionClient {\r\n    private client: EchoChamberClient;\r\n    private runtime: IAgentRuntime;\r\n    private lastCheckedTimestamps: Map<string, string> = new Map();\r\n    private lastResponseTimes: Map<string, number> = new Map();\r\n    private messageThreads: Map<string, ChatMessage[]> = new Map();\r\n    private messageHistory: Map<\r\n        string,\r\n        { message: ChatMessage; response: ChatMessage | null }[]\r\n    > = new Map();\r\n    private pollInterval: NodeJS.Timeout | null = null;\r\n    private conversationStarterInterval: NodeJS.Timeout | null = null;\r\n\r\n    constructor(client: EchoChamberClient, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    async start() {\r\n        const pollInterval = Number(\r\n            this.runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 60\r\n        );\r\n\r\n        const conversationStarterInterval = Number(\r\n            this.runtime.getSetting(\r\n                \"ECHOCHAMBERS_CONVERSATION_STARTER_INTERVAL\"\r\n            ) || 300\r\n        );\r\n\r\n        // Reactive message handling loop\r\n        const handleInteractionsLoop = () => {\r\n            this.handleInteractions();\r\n            this.pollInterval = setTimeout(\r\n                handleInteractionsLoop,\r\n                pollInterval * 1000\r\n            );\r\n        };\r\n\r\n        // Proactive conversation loop\r\n        const conversationStarterLoop = () => {\r\n            this.checkForDeadRooms();\r\n            this.conversationStarterInterval = setTimeout(\r\n                conversationStarterLoop,\r\n                conversationStarterInterval * 1000\r\n            );\r\n        };\r\n\r\n        handleInteractionsLoop();\r\n        conversationStarterLoop();\r\n    }\r\n\r\n    async stop() {\r\n        if (this.pollInterval) {\r\n            clearTimeout(this.pollInterval);\r\n            this.pollInterval = null;\r\n        }\r\n\r\n        if (this.conversationStarterInterval) {\r\n            clearTimeout(this.conversationStarterInterval);\r\n            this.conversationStarterInterval = null;\r\n        }\r\n    }\r\n\r\n    private async buildMessageThread(\r\n        message: ChatMessage,\r\n        messages: ChatMessage[]\r\n    ): Promise<ChatMessage[]> {\r\n        const thread: ChatMessage[] = [];\r\n        const maxThreadLength = Number(\r\n            this.runtime.getSetting(\"ECHOCHAMBERS_MAX_MESSAGES\") || 10\r\n        );\r\n\r\n        // Start with the current message\r\n        thread.push(message);\r\n\r\n        // Get recent messages in the same room, ordered by timestamp\r\n        const roomMessages = messages\r\n            .filter((msg) => msg.roomId === message.roomId)\r\n            .sort(\r\n                (a, b) =>\r\n                    new Date(b.timestamp).getTime() -\r\n                    new Date(a.timestamp).getTime()\r\n            );\r\n\r\n        // Add recent messages to provide context\r\n        for (const msg of roomMessages) {\r\n            if (thread.length >= maxThreadLength) break;\r\n            if (msg.id !== message.id) {\r\n                thread.unshift(msg);\r\n            }\r\n        }\r\n\r\n        return thread;\r\n    }\r\n\r\n    private shouldProcessMessage(\r\n        message: ChatMessage,\r\n        room: { topic: string }\r\n    ): boolean {\r\n        const modelInfo = this.client.getModelInfo();\r\n\r\n        // Don't process own messages\r\n        if (message.sender.username === modelInfo.username) {\r\n            return false;\r\n        }\r\n\r\n        // Check if we've processed this message before\r\n        const lastChecked =\r\n            this.lastCheckedTimestamps.get(message.roomId) || \"0\";\r\n        if (message.timestamp <= lastChecked) {\r\n            return false;\r\n        }\r\n\r\n        // Check rate limiting for responses\r\n        const lastResponseTime =\r\n            this.lastResponseTimes.get(message.roomId) || 0;\r\n        const minTimeBetweenResponses = 30000; // 30 seconds\r\n        if (Date.now() - lastResponseTime < minTimeBetweenResponses) {\r\n            return false;\r\n        }\r\n\r\n        // Check if message mentions the agent\r\n        const isMentioned = message.content\r\n            .toLowerCase()\r\n            .includes(`${modelInfo.username.toLowerCase()}`);\r\n\r\n        // Check if message is relevant to room topic\r\n        const isRelevantToTopic =\r\n            room.topic &&\r\n            message.content.toLowerCase().includes(room.topic.toLowerCase());\r\n\r\n        // Always process if mentioned, otherwise check relevance\r\n        return isMentioned || isRelevantToTopic;\r\n    }\r\n\r\n    private async handleInteractions() {\r\n        elizaLogger.log(\"Checking EchoChambers interactions\");\r\n\r\n        try {\r\n            // Get all watched rooms from the client\r\n            const watchedRooms = this.client.getWatchedRooms();\r\n            const rooms = await this.client.listRooms();\r\n\r\n            for (const room of rooms) {\r\n                // Only process messages from watched rooms\r\n                if (!watchedRooms.includes(room.id)) {\r\n                    continue;\r\n                }\r\n\r\n                const messages = await this.client.getRoomHistory(room.id);\r\n                this.messageThreads.set(room.id, messages);\r\n\r\n                // Get only the most recent message that we should process\r\n                const latestMessages = messages\r\n                    .filter((msg) => this.shouldProcessMessage(msg, room))\r\n                    .sort(\r\n                        (a, b) =>\r\n                            new Date(b.timestamp).getTime() -\r\n                            new Date(a.timestamp).getTime()\r\n                    );\r\n\r\n                if (latestMessages.length > 0) {\r\n                    const latestMessage = latestMessages[0];\r\n                    await this.handleMessage(latestMessage, room.topic);\r\n\r\n                    // Update history\r\n                    const roomHistory = this.messageHistory.get(room.id) || [];\r\n                    roomHistory.push({\r\n                        message: latestMessage,\r\n                        response: null,\r\n                    });\r\n                    this.messageHistory.set(room.id, roomHistory);\r\n\r\n                    // Update last checked timestamp\r\n                    if (\r\n                        latestMessage.timestamp >\r\n                        (this.lastCheckedTimestamps.get(room.id) || \"0\")\r\n                    ) {\r\n                        this.lastCheckedTimestamps.set(\r\n                            room.id,\r\n                            latestMessage.timestamp\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            elizaLogger.log(\"Finished checking EchoChambers interactions\");\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Error handling EchoChambers interactions:\",\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private async handleMessage(message: ChatMessage, roomTopic: string) {\r\n        try {\r\n            const content = `${message.content?.substring(0, 50)}...`; // First 50 chars\r\n            elizaLogger.debug(\"Processing message:\", {\r\n                id: message.id,\r\n                room: message.roomId,\r\n                sender: message?.sender?.username,\r\n                content: `${content}`,\r\n            });\r\n\r\n            const roomId = stringToUuid(message.roomId);\r\n            const userId = stringToUuid(message.sender.username);\r\n\r\n            elizaLogger.debug(\"Converted IDs:\", { roomId, userId });\r\n\r\n            // Ensure connection exists\r\n            await this.runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                message.sender.username,\r\n                message.sender.username,\r\n                \"echochambers\"\r\n            );\r\n\r\n            // Build message thread for context\r\n            const thread = await this.buildMessageThread(\r\n                message,\r\n                this.messageThreads.get(message.roomId) || []\r\n            );\r\n\r\n            // Create memory object\r\n            const memory: Memory = {\r\n                id: stringToUuid(message.id),\r\n                userId,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                content: {\r\n                    text: message.content,\r\n                    source: \"echochambers\",\r\n                    thread: thread.map((msg) => ({\r\n                        text: msg.content,\r\n                        sender: msg.sender.username,\r\n                        timestamp: msg.timestamp,\r\n                    })),\r\n                },\r\n                createdAt: new Date(message.timestamp).getTime(),\r\n                embedding: getEmbeddingZeroVector(),\r\n            };\r\n\r\n            // Check if we've already processed this message\r\n            const existing = await this.runtime.messageManager.getMemoryById(\r\n                memory.id\r\n            );\r\n            if (existing) {\r\n                elizaLogger.log(\r\n                    `Already processed message ${message.id}, skipping`\r\n                );\r\n                return;\r\n            }\r\n\r\n            // Save the message to memory\r\n            await this.runtime.messageManager.createMemory(memory);\r\n\r\n            // Compose state with thread context\r\n            let state = await this.runtime.composeState(memory);\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n\r\n            // Decide whether to respond\r\n            const shouldRespondContext = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.shouldRespondTemplate ||\r\n                    createShouldRespondTemplate(message.roomId, roomTopic),\r\n            });\r\n\r\n            const shouldRespond = await generateShouldRespond({\r\n                runtime: this.runtime,\r\n                context: shouldRespondContext,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            if (shouldRespond !== \"RESPOND\") {\r\n                elizaLogger.log(\r\n                    `Not responding to message ${message.id}: ${shouldRespond}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            // Generate response\r\n            const responseContext = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.messageHandlerTemplate ||\r\n                    createMessageTemplate(message.roomId, roomTopic),\r\n            });\r\n\r\n            const response = await generateMessageResponse({\r\n                runtime: this.runtime,\r\n                context: responseContext,\r\n                modelClass: ModelClass.LARGE,\r\n            });\r\n\r\n            if (!response || !response.text) {\r\n                elizaLogger.log(\"No response generated\");\r\n                return;\r\n            }\r\n\r\n            // Send response\r\n            const callback: HandlerCallback = async (content: Content) => {\r\n                const sentMessage = await this.client.sendMessage(\r\n                    message.roomId,\r\n                    content.text\r\n                );\r\n\r\n                // Update last response time\r\n                this.lastResponseTimes.set(message.roomId, Date.now());\r\n\r\n                // Update history with our response\r\n                const roomHistory =\r\n                    this.messageHistory.get(message.roomId) || [];\r\n                const lastEntry = roomHistory[roomHistory.length - 1];\r\n                if (lastEntry && lastEntry.message.id === message.id) {\r\n                    lastEntry.response = sentMessage;\r\n                }\r\n\r\n                const responseMemory: Memory = {\r\n                    id: stringToUuid(sentMessage.id),\r\n                    userId: this.runtime.agentId,\r\n                    agentId: this.runtime.agentId,\r\n                    roomId,\r\n                    content: {\r\n                        text: sentMessage.content,\r\n                        source: \"echochambers\",\r\n                        action: content.action,\r\n                        thread: thread.map((msg) => ({\r\n                            text: msg.content,\r\n                            sender: msg.sender.username,\r\n                            timestamp: msg.timestamp,\r\n                        })),\r\n                    },\r\n                    createdAt: new Date(sentMessage.timestamp).getTime(),\r\n                    embedding: getEmbeddingZeroVector(),\r\n                };\r\n\r\n                await this.runtime.messageManager.createMemory(responseMemory);\r\n                return [responseMemory];\r\n            };\r\n\r\n            // Send the response and process any resulting actions\r\n            const responseMessages = await callback(response);\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n            await this.runtime.processActions(\r\n                memory,\r\n                responseMessages,\r\n                state,\r\n                callback\r\n            );\r\n            await this.runtime.evaluate(memory, state, true);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error handling message:\", error);\r\n            elizaLogger.debug(\"Message that caused error:\", {\r\n                message,\r\n                roomTopic,\r\n            });\r\n        }\r\n    }\r\n\r\n    private async checkForDeadRooms() {\r\n        try {\r\n            const watchedRooms = this.client.getWatchedRooms();\r\n            elizaLogger.debug(\r\n                \"Starting dead room check. Watched rooms:\",\r\n                watchedRooms\r\n            );\r\n\r\n            const rooms = await this.client.listRooms();\r\n            elizaLogger.debug(\r\n                \"Available rooms:\",\r\n                rooms.map((r) => ({ id: r.id, name: r.name }))\r\n            );\r\n\r\n            for (const roomId of watchedRooms) {\r\n                try {\r\n                    elizaLogger.debug(`Checking room ${roomId}`);\r\n\r\n                    const room = rooms.find((r) => r.id === roomId);\r\n                    if (!room) {\r\n                        elizaLogger.debug(`Room ${roomId} not found, skipping`);\r\n                        continue;\r\n                    }\r\n\r\n                    // Log room details\r\n                    elizaLogger.debug(\"Room details:\", {\r\n                        id: room.id,\r\n                        name: room.name,\r\n                        topic: room.topic,\r\n                    });\r\n\r\n                    // Random check with logging\r\n                    const randomCheck = Math.random();\r\n                    elizaLogger.debug(\r\n                        `Random check for ${room.name}: ${randomCheck}`\r\n                    );\r\n\r\n                    if (randomCheck > 0.8) {\r\n                        elizaLogger.debug(\r\n                            `Checking conversation state for ${room.name}`\r\n                        );\r\n\r\n                        const shouldInitiate =\r\n                            await this.client.shouldInitiateConversation(room);\r\n                        elizaLogger.debug(\r\n                            `Should initiate conversation in ${room.name}:`,\r\n                            shouldInitiate\r\n                        );\r\n\r\n                        if (shouldInitiate) {\r\n                            elizaLogger.debug(\r\n                                `Starting conversation initiation in ${room.name}`\r\n                            );\r\n                            await this.initiateConversation(room);\r\n                            elizaLogger.debug(\r\n                                `Completed conversation initiation in ${room.name}`\r\n                            );\r\n                        }\r\n                    }\r\n                } catch (roomError: unknown) {\r\n                    // Log individual room errors without stopping the loop\r\n                    if (roomError instanceof Error) {\r\n                        elizaLogger.error(`Error processing room ${roomId}:`, {\r\n                            error: roomError.message,\r\n                            stack: roomError.stack,\r\n                        });\r\n                    } else {\r\n                        elizaLogger.error(`Error processing room ${roomId}:`, roomError);\r\n                    }\r\n                }\r\n            }\r\n        } catch (error: unknown) {\r\n            if (error instanceof Error) {\r\n                elizaLogger.error(\r\n                    \"Error in checkForDeadRooms:\",\r\n                    error.message || \"Unknown error\"\r\n                );\r\n                elizaLogger.debug(\"Full error details:\", {\r\n                    error,\r\n                    stack: error.stack,\r\n                    type: typeof error,\r\n                });\r\n            } else {\r\n                elizaLogger.error(\"Error in checkForDeadRooms:\", String(error));\r\n            }\r\n        }\r\n    }\r\n\r\n    private async initiateConversation(room: ChatRoom) {\r\n        try {\r\n            elizaLogger.debug(`Starting initiateConversation for ${room.name}`);\r\n\r\n            // Create a dummy memory instead of passing null\r\n            const dummyMemory: Memory = {\r\n                id: stringToUuid(\"conversation-starter\"),\r\n                userId: this.runtime.agentId,\r\n                agentId: this.runtime.agentId,\r\n                roomId: stringToUuid(room.id),\r\n                content: {\r\n                    text: \"\",\r\n                    source: \"echochambers\",\r\n                    thread: [],\r\n                },\r\n                createdAt: Date.now(),\r\n                embedding: getEmbeddingZeroVector(),\r\n            };\r\n\r\n            const state = await this.runtime.composeState(dummyMemory);\r\n            elizaLogger.debug(\"Composed state for conversation\");\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template: createConversationStarterTemplate(\r\n                    room.name,\r\n                    room.topic\r\n                ),\r\n            });\r\n            elizaLogger.debug(\"Created conversation context\");\r\n\r\n            const content = await generateMessageResponse({\r\n                runtime: this.runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n            elizaLogger.debug(\"Generated response content:\", {\r\n                hasContent: !!content,\r\n                textLength: content?.text?.length,\r\n            });\r\n\r\n            if (content?.text) {\r\n                elizaLogger.debug(`Sending message to ${room.name}`);\r\n                await this.client.sendMessage(room.id, content.text);\r\n                elizaLogger.info(\r\n                    `Started conversation in ${room.name} (Topic: ${room.topic})`\r\n                );\r\n            }\r\n        } catch (error: unknown) {\r\n            if (error instanceof Error) {\r\n                elizaLogger.error(\r\n                    `Error in initiateConversation for ${room.name}:`,\r\n                    {\r\n                        error: error.message,\r\n                        stack: error.stack,\r\n                    }\r\n                );\r\n            } else {\r\n                elizaLogger.error(\r\n                    `Error in initiateConversation for ${room.name}:`,\r\n                    String(error)\r\n                );\r\n            }\r\n            throw error; // Re-throw to be caught by parent\r\n        }\r\n    }\r\n}\r\n","import { type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\r\n\r\nexport async function validateEchoChamberConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<void> {\r\n    const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\r\n    const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\r\n\r\n    if (!apiUrl) {\r\n        elizaLogger.error(\r\n            \"ECHOCHAMBERS_API_URL is required. Please set it in your environment variables.\"\r\n        );\r\n        throw new Error(\"ECHOCHAMBERS_API_URL is required\");\r\n    }\r\n\r\n    if (!apiKey) {\r\n        elizaLogger.error(\r\n            \"ECHOCHAMBERS_API_KEY is required. Please set it in your environment variables.\"\r\n        );\r\n        throw new Error(\"ECHOCHAMBERS_API_KEY is required\");\r\n    }\r\n\r\n    // Validate API URL format\r\n    try {\r\n        new URL(apiUrl);\r\n    } catch {\r\n        elizaLogger.error(\r\n            `Invalid ECHOCHAMBERS_API_URL format: ${apiUrl}. Please provide a valid URL.`\r\n        );\r\n        throw new Error(\"Invalid ECHOCHAMBERS_API_URL format\");\r\n    }\r\n\r\n    // Optional settings with defaults\r\n    const username =\r\n        runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\r\n        `agent-${runtime.agentId}`;\r\n    // Change from DEFAULT_ROOM to ROOMS\r\n    const rooms = runtime.getSetting(\"ECHOCHAMBERS_ROOMS\")?.split(\",\").map(r => r.trim()) || [\"general\"];\r\n\r\n    const pollInterval = Number(\r\n        runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 120\r\n    );\r\n\r\n    if (Number.isNaN(pollInterval) || pollInterval < 1) {\r\n        elizaLogger.error(\r\n            \"ECHOCHAMBERS_POLL_INTERVAL must be a positive number in seconds\"\r\n        );\r\n        throw new Error(\"Invalid ECHOCHAMBERS_POLL_INTERVAL\");\r\n    }\r\n\r\n    elizaLogger.log(\"EchoChambers configuration validated successfully\");\r\n    elizaLogger.log(`API URL: ${apiUrl}`);\r\n    elizaLogger.log(`Username: ${username}`);\r\n    elizaLogger.log(`Watching Rooms: ${rooms.join(\", \")}`);\r\n    elizaLogger.log(`Poll Interval: ${pollInterval}s`);\r\n}\r\n","export interface ModelInfo {\r\n    username: string; // Unique username for the model/agent\r\n    model: string; // Type/name of the model being used\r\n}\r\n\r\nexport interface ChatMessage {\r\n    id: string; // Unique message identifier\r\n    content: string; // Message content/text\r\n    sender: ModelInfo; // Information about who sent the message\r\n    timestamp: string; // ISO timestamp of when message was sent\r\n    roomId: string; // ID of the room this message belongs to\r\n}\r\n\r\nexport interface ChatRoom {\r\n    id: string; // Unique room identifier\r\n    name: string; // Display name of the room\r\n    topic: string; // Room's current topic/description\r\n    tags: string[]; // Tags associated with the room for categorization\r\n    participants: ModelInfo[]; // List of current room participants\r\n    createdAt: string; // ISO timestamp of room creation\r\n    messageCount: number; // Total number of messages in the room\r\n}\r\n\r\nexport interface EchoChamberConfig {\r\n    apiUrl: string; // Base URL for the EchoChambers API\r\n    apiKey: string; // Required API key for authenticated endpoints\r\n    rooms: string[]; // list of rooms to listen on startup\r\n    username?: string; // Optional custom username (defaults to agent-{agentId})\r\n    model?: string; // Optional model name (defaults to runtime.modelProvider)\r\n}\r\n\r\nexport interface ListRoomsResponse {\r\n    rooms: ChatRoom[];\r\n}\r\n\r\nexport interface RoomHistoryResponse {\r\n    messages: ChatMessage[];\r\n}\r\n\r\nexport interface MessageResponse {\r\n    message: ChatMessage;\r\n}\r\n\r\nexport interface CreateRoomResponse {\r\n    room: ChatRoom;\r\n}\r\n\r\nexport interface ClearMessagesResponse {\r\n    success: boolean;\r\n    message: string;\r\n}\r\n\r\nexport enum RoomEvent {\r\n    MESSAGE_CREATED = \"message_created\",\r\n    ROOM_CREATED = \"room_created\",\r\n    ROOM_UPDATED = \"room_updated\",\r\n    ROOM_JOINED = \"room_joined\",\r\n    ROOM_LEFT = \"room_left\",\r\n}\r\n\r\nexport interface MessageTransformer {\r\n    transformIncoming(content: string): Promise<string>;\r\n    transformOutgoing?(content: string): Promise<string>;\r\n}\r\n\r\nexport interface ContentModerator {\r\n    validateContent(content: string): Promise<boolean>;\r\n}\r\n"],"mappings":"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","names":["elizaLogger","elizaLogger","content","elizaLogger","RoomEvent","elizaLogger"]}