{"version":3,"sources":["../src/index.ts","../src/environment.ts","../src/lib/auth.ts","../src/lib/profile.ts","../src/lib/state.ts","../src/services/interaction.ts","../src/lib/actions.ts","../src/services/post.ts"],"sourcesContent":["// src/index.ts\r\nimport { type Client, type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\r\nimport { validateInstagramConfig } from \"./environment\";\r\nimport { initializeClient } from \"./lib/auth\";\r\nimport { InstagramInteractionService } from \"./services/interaction\";\r\nimport { InstagramPostService } from \"./services/post\";\r\n\r\nexport const InstagramClientInterface: Client = {\r\n    async start(runtime: IAgentRuntime) {\r\n        try {\r\n            // Validate configuration\r\n            const config = await validateInstagramConfig(runtime);\r\n            elizaLogger.log(\"Instagram client configuration validated\");\r\n\r\n            // Initialize client and get initial state\r\n            const state = await initializeClient(runtime, config);\r\n            elizaLogger.log(\"Instagram client initialized\");\r\n\r\n            // Create services\r\n            const postService = new InstagramPostService(runtime, state);\r\n            const interactionService = new InstagramInteractionService(\r\n                runtime,\r\n                state\r\n            );\r\n\r\n            // Start services\r\n            if (!config.INSTAGRAM_DRY_RUN) {\r\n                await postService.start();\r\n                elizaLogger.log(\"Instagram post service started\");\r\n\r\n                if (config.INSTAGRAM_ENABLE_ACTION_PROCESSING) {\r\n                    await interactionService.start();\r\n                    elizaLogger.log(\"Instagram interaction service started\");\r\n                }\r\n            } else {\r\n                elizaLogger.log(\"Instagram client running in dry-run mode\");\r\n            }\r\n\r\n            // Return manager instance\r\n            return {\r\n                post: postService,\r\n                interaction: interactionService,\r\n                state,\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Failed to start Instagram client:\", error);\r\n            throw error;\r\n        }\r\n    },\r\n    // eslint-disable-next-line\r\n    async stop(runtime: IAgentRuntime) {\r\n        elizaLogger.log(\"Stopping Instagram client services...\");\r\n        // Cleanup will be handled by the services themselves\r\n    },\r\n};\r\n\r\nexport default InstagramClientInterface;\r\n","import {\r\n    type IAgentRuntime,\r\n    parseBooleanFromText,\r\n} from \"@elizaos/core\";\r\nimport { z } from \"zod\";\r\n\r\nexport const DEFAULT_POST_INTERVAL_MIN = 60;\r\nexport const DEFAULT_POST_INTERVAL_MAX = 120;\r\nexport const DEFAULT_ACTION_INTERVAL = 5;\r\nexport const DEFAULT_MAX_ACTIONS = 1;\r\n\r\n// Define validation schemas for Instagram usernames and other fields\r\nconst instagramUsernameSchema = z\r\n    .string()\r\n    .min(1, \"An Instagram Username must be at least 1 character long\")\r\n    .max(30, \"An Instagram Username cannot exceed 30 characters\")\r\n    .refine((username) => {\r\n        // Instagram usernames can contain letters, numbers, periods, and underscores\r\n        return /^[A-Za-z0-9._]+$/.test(username);\r\n    }, \"An Instagram Username can only contain letters, numbers, periods, and underscores\");\r\n\r\n/**\r\n * Environment configuration schema for Instagram client\r\n */\r\nexport const instagramEnvSchema = z.object({\r\n    INSTAGRAM_DRY_RUN: z.boolean(),\r\n    INSTAGRAM_USERNAME: instagramUsernameSchema,\r\n    INSTAGRAM_PASSWORD: z.string().min(1, \"Instagram password is required\"),\r\n\r\n    // Instagram API credentials\r\n    INSTAGRAM_APP_ID: z.string().min(1, \"Instagram App ID is required\"),\r\n    INSTAGRAM_APP_SECRET: z.string().min(1, \"Instagram App Secret is required\"),\r\n\r\n    // Optional Business Account ID for additional features\r\n    INSTAGRAM_BUSINESS_ACCOUNT_ID: z.string().optional(),\r\n\r\n    // Posting configuration\r\n    INSTAGRAM_POST_INTERVAL_MIN: z.number().int().default(DEFAULT_POST_INTERVAL_MIN),\r\n    INSTAGRAM_POST_INTERVAL_MAX: z.number().int().default(DEFAULT_POST_INTERVAL_MAX),\r\n\r\n    // Action processing configuration\r\n    INSTAGRAM_ENABLE_ACTION_PROCESSING: z.boolean().default(false),\r\n    INSTAGRAM_ACTION_INTERVAL: z.number().int().default(DEFAULT_ACTION_INTERVAL),\r\n    INSTAGRAM_MAX_ACTIONS: z.number().int().default(DEFAULT_MAX_ACTIONS),\r\n});\r\n\r\nexport type InstagramConfig = z.infer<typeof instagramEnvSchema>;\r\n\r\n/**\r\n * Validates and constructs an InstagramConfig object using zod,\r\n * taking values from the IAgentRuntime or process.env as needed.\r\n */\r\nexport async function validateInstagramConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<InstagramConfig> {\r\n    try {\r\n        const instagramConfig = {\r\n            INSTAGRAM_DRY_RUN: parseBooleanFromText(\r\n                runtime.getSetting(\"INSTAGRAM_DRY_RUN\") ||\r\n                    process.env.INSTAGRAM_DRY_RUN\r\n            ) ?? false,\r\n\r\n            INSTAGRAM_USERNAME: runtime.getSetting(\"INSTAGRAM_USERNAME\") ||\r\n                process.env.INSTAGRAM_USERNAME,\r\n\r\n            INSTAGRAM_PASSWORD: runtime.getSetting(\"INSTAGRAM_PASSWORD\") ||\r\n                process.env.INSTAGRAM_PASSWORD,\r\n\r\n            INSTAGRAM_APP_ID: runtime.getSetting(\"INSTAGRAM_APP_ID\") ||\r\n                process.env.INSTAGRAM_APP_ID,\r\n\r\n            INSTAGRAM_APP_SECRET: runtime.getSetting(\"INSTAGRAM_APP_SECRET\") ||\r\n                process.env.INSTAGRAM_APP_SECRET,\r\n\r\n            INSTAGRAM_BUSINESS_ACCOUNT_ID: runtime.getSetting(\"INSTAGRAM_BUSINESS_ACCOUNT_ID\") ||\r\n                process.env.INSTAGRAM_BUSINESS_ACCOUNT_ID,\r\n\r\n            INSTAGRAM_POST_INTERVAL_MIN: Number.parseInt(\r\n                runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MIN\") ||\r\n                    process.env.INSTAGRAM_POST_INTERVAL_MIN ||\r\n                    DEFAULT_POST_INTERVAL_MIN.toString(),\r\n                10\r\n            ),\r\n\r\n            INSTAGRAM_POST_INTERVAL_MAX: Number.parseInt(\r\n                runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MAX\") ||\r\n                    process.env.INSTAGRAM_POST_INTERVAL_MAX ||\r\n                    DEFAULT_POST_INTERVAL_MAX.toString(),\r\n                10\r\n            ),\r\n\r\n            INSTAGRAM_ENABLE_ACTION_PROCESSING: parseBooleanFromText(\r\n                runtime.getSetting(\"INSTAGRAM_ENABLE_ACTION_PROCESSING\") ||\r\n                    process.env.INSTAGRAM_ENABLE_ACTION_PROCESSING\r\n            ) ?? false,\r\n\r\n            INSTAGRAM_ACTION_INTERVAL: Number.parseInt(\r\n                runtime.getSetting(\"INSTAGRAM_ACTION_INTERVAL\") ||\r\n                    process.env.INSTAGRAM_ACTION_INTERVAL ||\r\n                    DEFAULT_ACTION_INTERVAL.toString(),\r\n                10\r\n            ),\r\n\r\n            INSTAGRAM_MAX_ACTIONS: Number.parseInt(\r\n                runtime.getSetting(\"MAX_ACTIONS_PROCESSING\") ||\r\n                    process.env.MAX_ACTIONS_PROCESSING ||\r\n                    DEFAULT_MAX_ACTIONS.toString(),\r\n                10\r\n            ),\r\n        };\r\n\r\n        return instagramEnvSchema.parse(instagramConfig);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Instagram configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}","// src/lib/auth.ts\r\nimport { type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\r\nimport { IgLoginTwoFactorRequiredError } from \"instagram-private-api\";\r\nimport type { InstagramConfig } from \"../environment\";\r\nimport type { InstagramState } from \"../types\";\r\nimport { fetchProfile } from \"./profile\";\r\nimport { createInitialState, getIgClient } from \"./state\";\r\n\r\n/**\r\n * Authenticates with Instagram\r\n */\r\nasync function authenticate(\r\n    runtime: IAgentRuntime,\r\n    config: InstagramConfig\r\n): Promise<InstagramState> {\r\n    const ig = getIgClient();\r\n    const state = createInitialState();\r\n\r\n    try {\r\n        // Generate device ID\r\n        ig.state.generateDevice(config.INSTAGRAM_USERNAME);\r\n\r\n        // Attempt to load cached session\r\n        const cachedSession =\r\n            await runtime.cacheManager.get(\"instagram/session\");\r\n        if (cachedSession) {\r\n            try {\r\n                await ig.state.deserialize(cachedSession);\r\n                const profile = await fetchProfile(runtime, config);\r\n                return {\r\n                    ...state,\r\n                    isInitialized: true,\r\n                    profile,\r\n                };\r\n            } catch {\r\n                elizaLogger.warn(\r\n                    `Cached session invalid, proceeding with fresh login`\r\n                );\r\n            }\r\n        }\r\n\r\n        // Proceed with fresh login\r\n        try {\r\n            await ig.account.login(\r\n                config.INSTAGRAM_USERNAME,\r\n                config.INSTAGRAM_PASSWORD\r\n            );\r\n\r\n            // Cache the session\r\n            const serialized = await ig.state.serialize();\r\n            await runtime.cacheManager.set(\"instagram/session\", serialized);\r\n\r\n            const profile = await fetchProfile(runtime, config);\r\n\r\n            return {\r\n                ...state,\r\n                isInitialized: true,\r\n                profile,\r\n            };\r\n        } catch (error) {\r\n            if (error instanceof IgLoginTwoFactorRequiredError) {\r\n                // Handle 2FA if needed - would need to implement 2FA code generation\r\n                throw new Error(\"2FA authentication not yet implemented\");\r\n            }\r\n            throw error;\r\n        }\r\n    } catch (error) {\r\n        elizaLogger.error(\"Authentication failed:\", error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Sets up webhooks for real-time updates if needed\r\n */\r\nasync function setupWebhooks() {\r\n    // Implement webhook setup\r\n    // This is a placeholder for future implementation\r\n}\r\n\r\n/**\r\n * Initializes the Instagram client\r\n */\r\nexport async function initializeClient(\r\n    runtime: IAgentRuntime,\r\n    config: InstagramConfig\r\n): Promise<InstagramState> {\r\n    try {\r\n        // Authenticate and get initial state\r\n        const state = await authenticate(runtime, config);\r\n\r\n        // Set up webhook handlers if needed\r\n        await setupWebhooks();\r\n\r\n        return state;\r\n    } catch (error) {\r\n        elizaLogger.error(\"Failed to initialize Instagram client:\", error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Export other authentication related functions if needed\r\nexport { authenticate, setupWebhooks };\r\n","import { elizaLogger, type IAgentRuntime } from \"@elizaos/core\";\r\nimport type { InstagramConfig } from \"../environment\";\r\nimport type { InstagramProfile } from \"../types\";\r\nimport { getIgClient } from \"./state\";\r\n\r\nexport async function fetchProfile(\r\n    runtime: IAgentRuntime,\r\n    config: InstagramConfig\r\n  ): Promise<InstagramProfile> {\r\n    const ig = getIgClient();\r\n\r\n    try {\r\n      const userInfo = await ig.user.info(ig.state.cookieUserId);\r\n\r\n      const profile: InstagramProfile = {\r\n        id: userInfo.pk.toString(),\r\n        username: userInfo.username,\r\n        name: userInfo.full_name,\r\n        biography: userInfo.biography,\r\n        mediaCount: userInfo.media_count,\r\n        followerCount: userInfo.follower_count,\r\n        followingCount: userInfo.following_count\r\n      };\r\n\r\n      // Cache profile info\r\n      await runtime.cacheManager.set(\r\n        `instagram/profile/${config.INSTAGRAM_USERNAME}`,\r\n        profile\r\n      );\r\n\r\n      return profile;\r\n    } catch (error) {\r\n      elizaLogger.error('Error fetching profile:', error);\r\n      throw error;\r\n    }\r\n  }\r\n","import { IgApiClient } from 'instagram-private-api';\r\nimport type { InstagramState } from '../types';\r\n\r\n// Create a singleton for the Instagram API client\r\nlet igClient: IgApiClient | null = null;\r\n\r\nexport const getIgClient = () => {\r\n  if (!igClient) {\r\n    igClient = new IgApiClient();\r\n  }\r\n  return igClient;\r\n};\r\n\r\n// Create initial state\r\nexport const createInitialState = (): InstagramState => ({\r\n  accessToken: null,\r\n  longLivedToken: null,\r\n  profile: null,\r\n  isInitialized: false,\r\n  lastCheckedMediaId: null,\r\n});","import {\r\n    composeContext,\r\n    elizaLogger,\r\n    generateText,\r\n    getEmbeddingZeroVector,\r\n    type IAgentRuntime,\r\n    ModelClass,\r\n    stringToUuid,\r\n    type UUID\r\n} from \"@elizaos/core\";\r\nimport { fetchComments, likeMedia, postComment } from \"../lib/actions\";\r\nimport { getIgClient } from \"../lib/state\";\r\nimport type { InstagramState } from \"../types\";\r\n\r\n  // Templates\r\n  const instagramCommentTemplate = `\r\n  # Areas of Expertise\r\n  {{knowledge}}\r\n\r\n  # About {{agentName}} (@{{instagramUsername}}):\r\n  {{bio}}\r\n  {{lore}}\r\n  {{topics}}\r\n\r\n  {{providers}}\r\n\r\n  {{characterPostExamples}}\r\n\r\n  {{postDirections}}\r\n\r\n  # Task: Generate a response to the following Instagram comment in the voice and style of {{agentName}}.\r\n  Original Comment (@{{commentUsername}}): {{commentText}}\r\n\r\n  Your response should be friendly, engaging, and natural. Keep it brief (1-2 sentences).\r\n  Do not use hashtags in comment responses. Be conversational and authentic.`;\r\n\r\n  const shouldInteractTemplate = `\r\n  # About {{agentName}} (@{{instagramUsername}}):\r\n  {{bio}}\r\n  {{lore}}\r\n  {{topics}}\r\n\r\n  {{postDirections}}\r\n\r\n  # Task: Determine if {{agentName}} should interact with this content:\r\n  Interaction Type: {{interactionType}}\r\n  User: @{{username}}\r\n  Content: {{content}}\r\n\r\n  Consider:\r\n  1. Is this user's content relevant to {{agentName}}'s interests?\r\n  2. Would interaction be authentic and meaningful?\r\n  3. Is there potential for valuable engagement?\r\n\r\n  Respond with one of:\r\n  [INTERACT] - Content is highly relevant and engagement would be valuable\r\n  [SKIP] - Content is not relevant enough or engagement wouldn't be authentic\r\n\r\n  Choose [INTERACT] only if very confident about relevance and value.`;\r\n\r\n  export class InstagramInteractionService {\r\n    private runtime: IAgentRuntime;\r\n    private state: InstagramState;\r\n    private isProcessing = false;\r\n    private stopProcessing = false;\r\n\r\n    constructor(runtime: IAgentRuntime, state: InstagramState) {\r\n      this.runtime = runtime;\r\n      this.state = state;\r\n    }\r\n\r\n    async start() {\r\n      const handleInteractionsLoop = () => {\r\n        this.handleInteractions();\r\n        if (!this.stopProcessing) {\r\n          setTimeout(\r\n            handleInteractionsLoop,\r\n            Number.parseInt(this.runtime.getSetting('ACTION_INTERVAL') || '300', 10) * 1000\r\n          );\r\n        }\r\n      };\r\n\r\n      handleInteractionsLoop();\r\n    }\r\n\r\n    async stop() {\r\n      this.stopProcessing = true;\r\n    }\r\n\r\n    private async generateResponse(\r\n      text: string,\r\n      username: string,\r\n      action: string\r\n    ) {\r\n      const state = await this.runtime.composeState(\r\n        {\r\n          userId: this.runtime.agentId,\r\n          roomId: stringToUuid(`instagram-temp-${Date.now()}-${this.runtime.agentId}`),\r\n          agentId: this.runtime.agentId,\r\n          content: {\r\n            text,\r\n            action,\r\n          },\r\n        },\r\n        {\r\n          instagramUsername: this.state.profile?.username,\r\n          commentUsername: username,\r\n          commentText: text,\r\n        }\r\n      );\r\n\r\n      const context = composeContext({\r\n        state,\r\n        template: instagramCommentTemplate,\r\n      });\r\n\r\n      const response = await generateText({\r\n        runtime: this.runtime,\r\n        context,\r\n        modelClass: ModelClass.SMALL,\r\n      });\r\n\r\n      return this.cleanResponse(response);\r\n    }\r\n\r\n    private cleanResponse(response: string): string {\r\n      return response\r\n        .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\")\r\n        .replace(/^['\"](.*)['\"]$/g, \"$1\")\r\n        .replace(/\\\\\"/g, '\"')\r\n        .trim();\r\n    }\r\n\r\n    private async handleInteractions() {\r\n      if (this.isProcessing) {\r\n        elizaLogger.log(\"Already processing interactions, skipping\");\r\n        return;\r\n      }\r\n\r\n      try {\r\n        this.isProcessing = true;\r\n        elizaLogger.log(\"Checking Instagram interactions\");\r\n\r\n        const ig = getIgClient();\r\n        const activity = await ig.feed.news().items();\r\n\r\n        for (const item of activity) {\r\n          const activityId = `instagram-activity-${item.pk}`;\r\n          if (await this.runtime.cacheManager.get(activityId)) continue;\r\n\r\n          switch (item.type) {\r\n            case 2: // Comment on your post\r\n              await this.handleComment(item);\r\n              break;\r\n            case 3: // Like on your post\r\n              await this.handleLike(item);\r\n              break;\r\n            case 12: // Mention in comment\r\n              await this.handleMention(item);\r\n              break;\r\n          }\r\n\r\n          await this.runtime.cacheManager.set(activityId, true);\r\n        }\r\n      } catch (error) {\r\n        elizaLogger.error(\"Error handling Instagram interactions:\", error);\r\n      } finally {\r\n        this.isProcessing = false;\r\n      }\r\n    }\r\n\r\n    private async handleComment(item: any) {\r\n      try {\r\n        const comments = await fetchComments(item.media_id);\r\n        const comment = comments.find(c => c.id === item.pk.toString());\r\n        if (!comment) return;\r\n\r\n        const roomId = stringToUuid(`instagram-comment-${item.media_id}-${this.runtime.agentId}`);\r\n        const commentId = stringToUuid(`instagram-comment-${comment.id}-${this.runtime.agentId}`);\r\n        const userId = stringToUuid(`instagram-user-${item.user_id}-${this.runtime.agentId}`);\r\n\r\n        const cleanedResponse = await this.generateResponse(\r\n          comment.text,\r\n          comment.username,\r\n          \"COMMENT\"\r\n        );\r\n\r\n        if (!cleanedResponse) {\r\n          elizaLogger.error(\"Failed to generate valid comment response\");\r\n          return;\r\n        }\r\n\r\n        await this.ensureEntities(roomId, userId, comment.username);\r\n        await this.createInteractionMemories(\r\n          commentId,\r\n          userId,\r\n          roomId,\r\n          comment,\r\n          cleanedResponse,\r\n          item.media_id\r\n        );\r\n\r\n      } catch (error) {\r\n        elizaLogger.error(\"Error handling comment:\", error);\r\n      }\r\n    }\r\n\r\n    private async handleLike(item: any) {\r\n      try {\r\n        const state = await this.runtime.composeState(\r\n          {\r\n            userId: this.runtime.agentId,\r\n            roomId: stringToUuid(`instagram-like-${item.media_id}-${this.runtime.agentId}`),\r\n            agentId: this.runtime.agentId,\r\n            content: { text: \"\", action: \"DECIDE_INTERACTION\" },\r\n          },\r\n          {\r\n            instagramUsername: this.state.profile?.username,\r\n            interactionType: \"like\",\r\n            username: item.user?.username,\r\n            content: item.text || \"\",\r\n          }\r\n        );\r\n\r\n        const context = composeContext({ state, template: shouldInteractTemplate });\r\n        const decision = await generateText({\r\n          runtime: this.runtime,\r\n          context,\r\n          modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        if (decision.includes(\"[INTERACT]\")) {\r\n          const userFeed = await getIgClient().feed.user(item.user_id).items();\r\n          if (userFeed.length > 0) {\r\n            await likeMedia(userFeed[0].id);\r\n            elizaLogger.log(`Liked post from user: ${item.user?.username}`);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        elizaLogger.error(\"Error handling like:\", error);\r\n      }\r\n    }\r\n\r\n    private async handleMention(item: any) {\r\n      try {\r\n        const roomId = stringToUuid(`instagram-mention-${item.media_id}-${this.runtime.agentId}`);\r\n        const mentionId = stringToUuid(`instagram-mention-${item.pk}-${this.runtime.agentId}`);\r\n        const userId = stringToUuid(`instagram-user-${item.user.pk}-${this.runtime.agentId}`);\r\n\r\n        const cleanedResponse = await this.generateResponse(\r\n          item.text,\r\n          item.user.username,\r\n          \"MENTION\"\r\n        );\r\n\r\n        if (!cleanedResponse) {\r\n          elizaLogger.error(\"Failed to generate valid mention response\");\r\n          return;\r\n        }\r\n\r\n        await this.ensureEntities(roomId, userId, item.user.username);\r\n        await this.createInteractionMemories(\r\n          mentionId,\r\n          userId,\r\n          roomId,\r\n          item,\r\n          cleanedResponse,\r\n          item.media_id\r\n        );\r\n\r\n      } catch (error) {\r\n        elizaLogger.error(\"Error handling mention:\", error);\r\n      }\r\n    }\r\n\r\n    private async ensureEntities(roomId: UUID, userId: UUID, username: string) {\r\n      await this.runtime.ensureRoomExists(roomId);\r\n      await this.runtime.ensureUserExists(userId, username, username, \"instagram\");\r\n      await this.runtime.ensureParticipantInRoom(this.runtime.agentId, roomId);\r\n    }\r\n\r\n    private async createInteractionMemories(\r\n      originalId: UUID,\r\n      userId: UUID,\r\n      roomId: UUID,\r\n      originalItem: any,\r\n      response: string,\r\n      mediaId: string\r\n    ) {\r\n      // Create memory of original interaction\r\n      await this.runtime.messageManager.createMemory({\r\n        id: originalId,\r\n        userId,\r\n        agentId: this.runtime.agentId,\r\n        content: {\r\n          text: originalItem.text,\r\n          source: \"instagram\",\r\n        },\r\n        roomId,\r\n        embedding: getEmbeddingZeroVector(),\r\n        createdAt: new Date(originalItem.timestamp || originalItem.created_at * 1000).getTime(),\r\n      });\r\n\r\n      // Post response\r\n      const postedComment = await postComment(mediaId, response);\r\n\r\n      // Create memory of our response\r\n      await this.runtime.messageManager.createMemory({\r\n        id: stringToUuid(`instagram-reply-${postedComment.id}-${this.runtime.agentId}`),\r\n        userId: this.runtime.agentId,\r\n        agentId: this.runtime.agentId,\r\n        content: {\r\n          text: response,\r\n          source: \"instagram\",\r\n          inReplyTo: originalId\r\n        },\r\n        roomId,\r\n        embedding: getEmbeddingZeroVector(),\r\n        createdAt: Date.now(),\r\n      });\r\n    }\r\n  }","// src/lib/actions.ts\r\nimport { elizaLogger } from \"@elizaos/core\";\r\nimport type { Comment } from \"../types\";\r\nimport { getIgClient } from \"./state\";\r\n\r\n/**\r\n * Fetches comments for a specific media post\r\n */\r\nexport async function fetchComments(\r\n  mediaId: string,\r\n  count = 20\r\n): Promise<Comment[]> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    const feed = ig.feed.mediaComments(mediaId);\r\n    const comments = await feed.items();\r\n\r\n    return comments.slice(0, count).map(comment => ({\r\n      id: comment.pk.toString(),\r\n      text: comment.text,\r\n      timestamp: new Date(comment.created_at * 1000).toISOString(),\r\n      username: comment.user.username,\r\n      replies: [] // Instagram API doesn't provide replies in the same call\r\n    }));\r\n  } catch (error) {\r\n    elizaLogger.error('Error fetching comments:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Posts a comment on a media post\r\n */\r\nexport async function postComment(\r\n  mediaId: string,\r\n  text: string\r\n): Promise<Comment> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    const result = await ig.media.comment({\r\n      mediaId,\r\n      text: text.slice(0, 2200) // Instagram comment length limit\r\n    });\r\n\r\n    return {\r\n      id: result.pk.toString(),\r\n      text: result.text,\r\n      timestamp: new Date(result.created_at * 1000).toISOString(),\r\n      username: result.user.username,\r\n      replies: []\r\n    };\r\n  } catch (error) {\r\n    elizaLogger.error('Error posting comment:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Likes a media post\r\n */\r\nexport async function likeMedia(mediaId: string): Promise<void> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    await ig.media.like({\r\n      mediaId,\r\n      moduleInfo: {\r\n        module_name: 'profile',\r\n        user_id: ig.state.cookieUserId,\r\n        username: ig.state.cookieUsername\r\n      }\r\n    });\r\n    elizaLogger.log(`Liked media: ${mediaId}`);\r\n  } catch (error) {\r\n    elizaLogger.error('Error liking media:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Unlikes a media post\r\n */\r\nexport async function unlikeMedia(mediaId: string): Promise<void> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    await ig.media.unlike({\r\n      mediaId,\r\n      moduleInfo: {\r\n        module_name: 'profile',\r\n        user_id: ig.state.cookieUserId,\r\n        username: ig.state.cookieUsername\r\n      }\r\n    });\r\n    elizaLogger.log(`Unliked media: ${mediaId}`);\r\n  } catch (error) {\r\n    elizaLogger.error('Error unliking media:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Replies to a comment\r\n */\r\nexport async function replyToComment(\r\n  mediaId: string,\r\n  commentId: string,\r\n  text: string\r\n): Promise<Comment> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    const result = await ig.media.comment({\r\n      mediaId,\r\n      text: text.slice(0, 2200), // Instagram comment length limit\r\n      replyToCommentId: commentId\r\n    });\r\n\r\n    return {\r\n      id: result.pk.toString(),\r\n      text: result.text,\r\n      timestamp: new Date(result.created_at * 1000).toISOString(),\r\n      username: result.user.username,\r\n      replies: []\r\n    };\r\n  } catch (error) {\r\n    elizaLogger.error('Error replying to comment:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Deletes a comment\r\n */\r\nexport async function deleteComment(\r\n  mediaId: string,\r\n  commentId: string\r\n): Promise<void> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    await ig.media.deleteComment({\r\n      mediaId,\r\n      commentId\r\n    });\r\n    elizaLogger.log(`Deleted comment: ${commentId} from media: ${mediaId}`);\r\n  } catch (error) {\r\n    elizaLogger.error('Error deleting comment:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if current user has liked a media post\r\n */\r\nexport async function hasLikedMedia(mediaId: string): Promise<boolean> {\r\n  const ig = getIgClient();\r\n\r\n  try {\r\n    const info = await ig.media.info(mediaId);\r\n    return info.items[0].has_liked ?? false;\r\n  } catch (error) {\r\n    elizaLogger.error('Error checking if media is liked:', error);\r\n    throw error;\r\n  }\r\n}","// src/services/post.ts\r\nimport {\r\n    type IAgentRuntime,\r\n    ModelClass,\r\n    composeContext,\r\n    elizaLogger,\r\n    generateImage,\r\n    generateText,\r\n    getEmbeddingZeroVector,\r\n    stringToUuid,\r\n} from \"@elizaos/core\";\r\nimport { promises as fs } from \"fs\";\r\nimport path from \"path\";\r\nimport sharp from \"sharp\";\r\nimport { getIgClient } from \"../lib/state\";\r\nimport type { InstagramState } from \"../types\";\r\n\r\n// Template for generating Instagram posts\r\nconst instagramPostTemplate = `\r\n# Areas of Expertise\r\n{{knowledge}}\r\n\r\n# About {{agentName}} (@{{instagramUsername}}):\r\n{{bio}}\r\n{{lore}}\r\n{{topics}}\r\n\r\n{{providers}}\r\n\r\n{{characterPostExamples}}\r\n\r\n{{postDirections}}\r\n\r\n# Task: Generate a post in the voice and style and perspective of {{agentName}}.\r\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}.\r\nYour response should be 1-3 sentences (choose the length at random).\r\nYour response should not contain any questions. Brief, concise statements only.\r\nAdd up to 3 relevant hashtags at the end.`;\r\n\r\ninterface PostOptions {\r\n    media: Array<{\r\n        type: \"IMAGE\" | \"VIDEO\" | \"CAROUSEL\";\r\n        url: string;\r\n    }>;\r\n    caption?: string;\r\n}\r\n\r\nexport class InstagramPostService {\r\n    private runtime: IAgentRuntime;\r\n    private state: InstagramState;\r\n    private isProcessing = false;\r\n    private lastPostTime = 0;\r\n    private stopProcessing = false;\r\n\r\n    constructor(runtime: IAgentRuntime, state: InstagramState) {\r\n        this.runtime = runtime;\r\n        this.state = state;\r\n    }\r\n\r\n    async start() {\r\n        const generatePostLoop = async () => {\r\n            const lastPost = await this.runtime.cacheManager.get<{\r\n                timestamp: number;\r\n            }>(\"instagram/lastPost\");\r\n\r\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\r\n            const minMinutes = Number.parseInt(\r\n                this.runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MIN\") || this.runtime.getSetting(\"POST_INTERVAL_MIN\") || \"90\",\r\n                10\r\n            );\r\n            const maxMinutes = Number.parseInt(\r\n                this.runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MAX\") || this.runtime.getSetting(\"POST_INTERVAL_MAX\") || \"180\",\r\n                10\r\n            );\r\n            const randomMinutes =\r\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\r\n                minMinutes;\r\n            const delay = randomMinutes * 60 * 1000;\r\n\r\n            if (Date.now() > lastPostTimestamp + delay) {\r\n                await this.generateNewPost();\r\n            }\r\n\r\n            if (!this.stopProcessing) {\r\n                setTimeout(generatePostLoop, delay);\r\n            }\r\n\r\n            elizaLogger.log(\r\n                `Next Instagram post scheduled in ${randomMinutes} minutes`\r\n            );\r\n        };\r\n\r\n        // Start the loop\r\n        generatePostLoop();\r\n    }\r\n\r\n    async stop() {\r\n        this.stopProcessing = true;\r\n    }\r\n\r\n    private async generateNewPost() {\r\n        try {\r\n            elizaLogger.log(\"Generating new Instagram post\");\r\n\r\n            const roomId = stringToUuid(\r\n                \"instagram_generate_room-\" + this.state.profile?.username\r\n            );\r\n\r\n            await this.runtime.ensureUserExists(\r\n                this.runtime.agentId,\r\n                this.state.profile?.username || \"\",\r\n                this.runtime.character.name,\r\n                \"instagram\"\r\n            );\r\n\r\n            const topics = this.runtime.character.topics.join(\", \");\r\n\r\n            const state = await this.runtime.composeState(\r\n                {\r\n                    userId: this.runtime.agentId,\r\n                    roomId: roomId,\r\n                    agentId: this.runtime.agentId,\r\n                    content: {\r\n                        text: topics || \"\",\r\n                        action: \"POST\",\r\n                    },\r\n                },\r\n                {\r\n                    instagramUsername: this.state.profile?.username,\r\n                }\r\n            );\r\n\r\n            const context = composeContext({\r\n                state,\r\n                // TODO: Add back in when we have a template for Instagram on character\r\n                //template: this.runtime.character.templates?.instagramPostTemplate || instagramPostTemplate,\r\n                template: instagramPostTemplate,\r\n            });\r\n\r\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\r\n\r\n            const content = await generateText({\r\n                runtime: this.runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            // Clean the generated content\r\n            let cleanedContent = \"\";\r\n\r\n            // Try parsing as JSON first\r\n            try {\r\n                const parsedResponse = JSON.parse(content);\r\n                if (parsedResponse.text) {\r\n                    cleanedContent = parsedResponse.text;\r\n                } else if (typeof parsedResponse === \"string\") {\r\n                    cleanedContent = parsedResponse;\r\n                }\r\n            } catch {\r\n                // If not JSON, clean the raw content\r\n                cleanedContent = content\r\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\r\n                    .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\r\n                    .replace(/\\\\\"/g, '\"') // Unescape quotes\r\n                    .replace(/\\\\n/g, \"\\n\\n\") // Unescape newlines\r\n                    .trim();\r\n            }\r\n\r\n            if (!cleanedContent) {\r\n                elizaLogger.error(\r\n                    \"Failed to extract valid content from response:\",\r\n                    {\r\n                        rawResponse: content,\r\n                        attempted: \"JSON parsing\",\r\n                    }\r\n                );\r\n                return;\r\n            }\r\n\r\n            // For Instagram, we need to generate or get an image\r\n            const mediaUrl = await this.getOrGenerateImage(cleanedContent);\r\n\r\n            await this.createPost({\r\n                media: [\r\n                    {\r\n                        type: \"IMAGE\",\r\n                        url: mediaUrl,\r\n                    },\r\n                ],\r\n                caption: cleanedContent,\r\n            });\r\n\r\n            // Create memory of the post\r\n            await this.runtime.messageManager.createMemory({\r\n                id: stringToUuid(`instagram-post-${Date.now()}`),\r\n                userId: this.runtime.agentId,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: cleanedContent,\r\n                    source: \"instagram\",\r\n                },\r\n                roomId,\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: Date.now(),\r\n            });\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error generating Instagram post:\", {\r\n                error: error instanceof Error ? error.message : String(error),\r\n                stack: error instanceof Error ? error.stack : undefined,\r\n                phase: \"generateNewPost\",\r\n            });\r\n        }\r\n    }\r\n\r\n    // Placeholder - implement actual image generation/selection\r\n    private async getOrGenerateImage(content: string): Promise<string> {\r\n        try {\r\n            elizaLogger.log(\"Generating image for Instagram post\");\r\n\r\n            let imageSettings = this.runtime.character.settings.imageSettings || {};\r\n\r\n            const result = await generateImage(\r\n                {\r\n                    prompt: content,\r\n                    width: imageSettings?.width || 1024,\r\n                    height: imageSettings?.height || 1024,\r\n                    count: imageSettings?.count || 1,\r\nnegativePrompt: imageSettings?.negativePrompt || null,\r\n                    numIterations: imageSettings?.numIterations || 50,\r\n                    guidanceScale: imageSettings?.guidanceScale || 7.5,\r\nseed: imageSettings?.seed || null,\r\n                    modelId: imageSettings?.modelId || null,\r\n                    jobId: imageSettings?.jobId || null,\r\n                    stylePreset: imageSettings?.stylePreset || \"\",\r\n                    hideWatermark: imageSettings?.hideWatermark ?? true,\r\n                    safeMode: imageSettings?.safeMode ?? true,\r\n                    cfgScale: imageSettings?.cfgScale || null,\r\n                },\r\n                this.runtime\r\n            );\r\n\r\n            if (!result.success || !result.data || result.data.length === 0) {\r\n                throw new Error(\r\n                    \"Failed to generate image: \" +\r\n                        (result.error || \"No image data returned\")\r\n                );\r\n            }\r\n\r\n            // Save the base64 image to a temporary file\r\n            const imageData = result.data[0].replace(\r\n                /^data:image\\/\\w+;base64,/,\r\n                \"\"\r\n            );\r\n            const tempDir = path.resolve(process.cwd(), \"temp\");\r\n            await fs.mkdir(tempDir, { recursive: true });\r\n            const tempFile = path.join(\r\n                tempDir,\r\n                `instagram-post-${Date.now()}.png`\r\n            );\r\n            await fs.writeFile(tempFile, Buffer.from(imageData, \"base64\"));\r\n\r\n            return tempFile;\r\n        } catch {\r\n            // If not JSON, clean the raw content\r\n            cleanedContent = content\r\n              .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\r\n              .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\r\n              .replace(/\\\\\"/g, '\"') // Unescape quotes\r\n              .replace(/\\\\n/g, \"\\n\\n\") // Unescape newlines\r\n              .trim();\r\n        }\r\n\r\n      if (!cleanedContent) {\r\n        elizaLogger.error(\"Failed to extract valid content from response:\", {\r\n          rawResponse: content,\r\n          attempted: \"JSON parsing\",\r\n        });\r\n        return;\r\n      }\r\n\r\n      // For Instagram, we need to generate or get an image\r\n      const mediaUrl = await this.getOrGenerateImage(cleanedContent);\r\n\r\n      await this.createPost({\r\n        media: [{\r\n          type: 'IMAGE',\r\n          url: mediaUrl\r\n        }],\r\n        caption: cleanedContent\r\n      });\r\n\r\n      // Create memory of the post\r\n      await this.runtime.messageManager.createMemory({\r\n        id: stringToUuid(`instagram-post-${Date.now()}`),\r\n        userId: this.runtime.agentId,\r\n        agentId: this.runtime.agentId,\r\n        content: {\r\n          text: cleanedContent,\r\n          source: \"instagram\",\r\n        },\r\n        roomId,\r\n        embedding: getEmbeddingZeroVector(),\r\n        createdAt: Date.now(),\r\n      });\r\n\r\n    } catch (error) {\r\n      elizaLogger.error(\"Error generating Instagram post:\", {\r\n        error: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n        phase: 'generateNewPost'\r\n      });\r\n    }\r\n\r\n    async createPost(options: PostOptions) {\r\n        const ig = getIgClient();\r\n\r\n        try {\r\n            elizaLogger.log(\"Creating Instagram post\", {\r\n                mediaCount: options.media.length,\r\n                hasCaption: !!options.caption,\r\n            });\r\n\r\n            // Process media\r\n            const processedMedia = await Promise.all(\r\n                options.media.map(async (media) => {\r\n                    const buffer = await this.processMedia(media);\r\n                    return {\r\n                        ...media,\r\n                        buffer,\r\n                    };\r\n                })\r\n            );\r\n\r\n            // Handle different post types\r\n            if (processedMedia.length > 1) {\r\n                // Create carousel post\r\n                await ig.publish.album({\r\n                    items: processedMedia.map((media) => ({\r\n                        file: media.buffer,\r\n                        caption: options.caption,\r\n                    })),\r\n                });\r\n            } else {\r\n                // Single image/video post\r\n                const media = processedMedia[0];\r\n                if (media.type === \"VIDEO\") {\r\n                    await ig.publish.video({\r\n                        video: media.buffer,\r\n                        caption: options.caption,\r\n                        coverImage: media.buffer,\r\n                    });\r\n                } else {\r\n                    await ig.publish.photo({\r\n                        file: media.buffer,\r\n                        caption: options.caption,\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Update last post time\r\n            this.lastPostTime = Date.now();\r\n            await this.runtime.cacheManager.set(\"instagram/lastPost\", {\r\n                timestamp: this.lastPostTime,\r\n            });\r\n\r\n            elizaLogger.log(\"Instagram post created successfully\");\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error creating Instagram post:\", {\r\n                error: error instanceof Error ? error.message : String(error),\r\n                stack: error instanceof Error ? error.stack : undefined,\r\n                phase: \"createPost\",\r\n                mediaCount: options.media.length,\r\n                hasCaption: !!options.caption,\r\n            });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async processMedia(media: {\r\n        type: string;\r\n        url: string;\r\n    }): Promise<Buffer> {\r\n        try {\r\n            elizaLogger.log(\"Processing media\", {\r\n                type: media.type,\r\n                url: media.url,\r\n            });\r\n\r\n            // Read file directly from filesystem instead of using fetch\r\n            const buffer = await fs.readFile(media.url);\r\n\r\n            if (media.type === \"IMAGE\") {\r\n                // Process image with sharp\r\n                return await sharp(buffer)\r\n                    .resize(1080, 1080, {\r\n                        fit: \"inside\",\r\n                        withoutEnlargement: true,\r\n                    })\r\n                    .jpeg({\r\n                        quality: 85,\r\n                        progressive: true,\r\n                    })\r\n                    .toBuffer();\r\n            }\r\n\r\n            // For other types, return original buffer\r\n            return buffer;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error processing media:\", {\r\n                error: error instanceof Error ? error.message : String(error),\r\n                stack: error instanceof Error ? error.stack : undefined,\r\n                phase: \"processMedia\",\r\n                mediaType: media.type,\r\n                url: media.url,\r\n            });\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","roomId","ModelClass","composeContext","elizaLogger","generateText","getEmbeddingZeroVector","stringToUuid","elizaLogger","roomId","stringToUuid","composeContext","generateText","ModelClass","cleanedContent","getEmbeddingZeroVector","elizaLogger"]}