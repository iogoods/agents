{"version":3,"sources":["../src/index.ts","../src/actions/chat_with_attachments.ts","../src/actions/download_media.ts","../src/actions/joinvoice.ts","../src/actions/leavevoice.ts","../src/actions/summarize_conversation.ts","../src/actions/transcribe_media.ts","../src/messages.ts","../src/attachments.ts","../src/templates.ts","../src/constants.ts","../src/utils.ts","../src/providers/channelState.ts","../src/providers/voiceState.ts","../src/voice.ts"],"sourcesContent":["import {\r\n    getEmbeddingZeroVector,\r\n    stringToUuid,\r\n    elizaLogger,\r\n    type Character,\r\n    type Client as ElizaClient,\r\n    type IAgentRuntime,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    Client,\r\n    Events,\r\n    GatewayIntentBits,\r\n    type Guild,\r\n    type MessageReaction,\r\n    Partials,\r\n    type User,\r\n} from \"discord.js\";\r\nimport { EventEmitter } from \"events\";\r\nimport chat_with_attachments from \"./actions/chat_with_attachments.ts\";\r\nimport download_media from \"./actions/download_media.ts\";\r\nimport joinvoice from \"./actions/joinvoice.ts\";\r\nimport leavevoice from \"./actions/leavevoice.ts\";\r\nimport summarize from \"./actions/summarize_conversation.ts\";\r\nimport transcribe_media from \"./actions/transcribe_media.ts\";\r\nimport { MessageManager } from \"./messages.ts\";\r\nimport channelStateProvider from \"./providers/channelState.ts\";\r\nimport voiceStateProvider from \"./providers/voiceState.ts\";\r\nimport { VoiceManager } from \"./voice.ts\";\r\nimport { PermissionsBitField } from \"discord.js\";\r\n\r\nexport class DiscordClient extends EventEmitter {\r\n    apiToken: string;\r\n    client: Client;\r\n    runtime: IAgentRuntime;\r\n    character: Character;\r\n    private messageManager: MessageManager;\r\n    private voiceManager: VoiceManager;\r\n\r\n    constructor(runtime: IAgentRuntime) {\r\n        super();\r\n\r\n        this.apiToken = runtime.getSetting(\"DISCORD_API_TOKEN\") as string;\r\n        this.client = new Client({\r\n            intents: [\r\n                GatewayIntentBits.Guilds,\r\n                GatewayIntentBits.DirectMessages,\r\n                GatewayIntentBits.GuildVoiceStates,\r\n                GatewayIntentBits.MessageContent,\r\n                GatewayIntentBits.GuildMessages,\r\n                GatewayIntentBits.DirectMessageTyping,\r\n                GatewayIntentBits.GuildMessageTyping,\r\n                GatewayIntentBits.GuildMessageReactions,\r\n            ],\r\n            partials: [\r\n                Partials.Channel,\r\n                Partials.Message,\r\n                Partials.User,\r\n                Partials.Reaction,\r\n            ],\r\n        });\r\n\r\n        this.runtime = runtime;\r\n        this.voiceManager = new VoiceManager(this);\r\n        this.messageManager = new MessageManager(this, this.voiceManager);\r\n\r\n        this.client.once(Events.ClientReady, this.onClientReady.bind(this));\r\n        this.client.login(this.apiToken);\r\n\r\n        this.setupEventListeners();\r\n\r\n        this.runtime.registerAction(joinvoice);\r\n        this.runtime.registerAction(leavevoice);\r\n        this.runtime.registerAction(summarize);\r\n        this.runtime.registerAction(chat_with_attachments);\r\n        this.runtime.registerAction(transcribe_media);\r\n        this.runtime.registerAction(download_media);\r\n\r\n        this.runtime.providers.push(channelStateProvider);\r\n        this.runtime.providers.push(voiceStateProvider);\r\n    }\r\n\r\n    private setupEventListeners() {\r\n        // When joining to a new server\r\n        this.client.on(\"guildCreate\", this.handleGuildCreate.bind(this));\r\n\r\n        this.client.on(\r\n            Events.MessageReactionAdd,\r\n            this.handleReactionAdd.bind(this)\r\n        );\r\n        this.client.on(\r\n            Events.MessageReactionRemove,\r\n            this.handleReactionRemove.bind(this)\r\n        );\r\n\r\n        // Handle voice events with the voice manager\r\n        this.client.on(\r\n            \"voiceStateUpdate\",\r\n            this.voiceManager.handleVoiceStateUpdate.bind(this.voiceManager)\r\n        );\r\n        this.client.on(\r\n            \"userStream\",\r\n            this.voiceManager.handleUserStream.bind(this.voiceManager)\r\n        );\r\n\r\n        // Handle a new message with the message manager\r\n        this.client.on(\r\n            Events.MessageCreate,\r\n            this.messageManager.handleMessage.bind(this.messageManager)\r\n        );\r\n\r\n        // Handle a new interaction\r\n        this.client.on(\r\n            Events.InteractionCreate,\r\n            this.handleInteractionCreate.bind(this)\r\n        );\r\n    }\r\n\r\n    async stop() {\r\n        try {\r\n            // disconnect websocket\r\n            // this unbinds all the listeners\r\n            await this.client.destroy();\r\n        } catch (e) {\r\n            elizaLogger.error(\"client-discord instance stop err\", e);\r\n        }\r\n    }\r\n\r\n    private async onClientReady(readyClient: { user: { tag: any; id: any } }) {\r\n        elizaLogger.success(`Logged in as ${readyClient.user?.tag}`);\r\n\r\n        // Register slash commands\r\n        const commands = [\r\n            {\r\n                name: \"joinchannel\",\r\n                description: \"Join a voice channel\",\r\n                options: [\r\n                    {\r\n                        name: \"channel\",\r\n                        type: 7, // CHANNEL type\r\n                        description: \"The voice channel to join\",\r\n                        required: true,\r\n                        channel_types: [2], // GuildVoice type\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                name: \"leavechannel\",\r\n                description: \"Leave the current voice channel\",\r\n            },\r\n        ];\r\n\r\n        try {\r\n            await this.client.application?.commands.set(commands);\r\n            elizaLogger.success(\"Slash commands registered\");\r\n        } catch (error) {\r\n            console.error(\"Error registering slash commands:\", error);\r\n        }\r\n\r\n        // Required permissions for the bot\r\n        const requiredPermissions = [\r\n            // Text Permissions\r\n            PermissionsBitField.Flags.ViewChannel,\r\n            PermissionsBitField.Flags.SendMessages,\r\n            PermissionsBitField.Flags.SendMessagesInThreads,\r\n            PermissionsBitField.Flags.CreatePrivateThreads,\r\n            PermissionsBitField.Flags.CreatePublicThreads,\r\n            PermissionsBitField.Flags.EmbedLinks,\r\n            PermissionsBitField.Flags.AttachFiles,\r\n            PermissionsBitField.Flags.AddReactions,\r\n            PermissionsBitField.Flags.UseExternalEmojis,\r\n            PermissionsBitField.Flags.UseExternalStickers,\r\n            PermissionsBitField.Flags.MentionEveryone,\r\n            PermissionsBitField.Flags.ManageMessages,\r\n            PermissionsBitField.Flags.ReadMessageHistory,\r\n            // Voice Permissions\r\n            PermissionsBitField.Flags.Connect,\r\n            PermissionsBitField.Flags.Speak,\r\n            PermissionsBitField.Flags.UseVAD,\r\n            PermissionsBitField.Flags.PrioritySpeaker,\r\n        ].reduce((a, b) => a | b, 0n);\r\n\r\n        elizaLogger.success(\"Use this URL to add the bot to your server:\");\r\n        elizaLogger.success(\r\n            `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user?.id}&permissions=${requiredPermissions}&scope=bot%20applications.commands`\r\n        );\r\n        await this.onReady();\r\n    }\r\n\r\n    async handleReactionAdd(reaction: MessageReaction, user: User) {\r\n        try {\r\n            elizaLogger.log(\"Reaction added\");\r\n\r\n            // Early returns\r\n            if (!reaction || !user) {\r\n                elizaLogger.warn(\"Invalid reaction or user\");\r\n                return;\r\n            }\r\n\r\n            // Get emoji info\r\n            let emoji = reaction.emoji.name;\r\n            if (!emoji && reaction.emoji.id) {\r\n                emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\r\n            }\r\n\r\n            // Fetch full message if partial\r\n            if (reaction.partial) {\r\n                try {\r\n                    await reaction.fetch();\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        \"Failed to fetch partial reaction:\",\r\n                        error\r\n                    );\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Generate IDs with timestamp to ensure uniqueness\r\n            const timestamp = Date.now();\r\n            const roomId = stringToUuid(\r\n                `${reaction.message.channel.id}-${this.runtime.agentId}`\r\n            );\r\n            const userIdUUID = stringToUuid(\r\n                `${user.id}-${this.runtime.agentId}`\r\n            );\r\n            const reactionUUID = stringToUuid(\r\n                `${reaction.message.id}-${user.id}-${emoji}-${timestamp}-${this.runtime.agentId}`\r\n            );\r\n\r\n            // Validate IDs\r\n            if (!userIdUUID || !roomId) {\r\n                elizaLogger.error(\"Invalid user ID or room ID\", {\r\n                    userIdUUID,\r\n                    roomId,\r\n                });\r\n                return;\r\n            }\r\n\r\n            // Process message content\r\n            const messageContent = reaction.message.content || \"\";\r\n            const truncatedContent =\r\n                messageContent.length > 100\r\n                    ? `${messageContent.substring(0, 100)}...`\r\n                    : messageContent;\r\n            const reactionMessage = `*<${emoji}>: \"${truncatedContent}\"*`;\r\n\r\n            // Get user info\r\n            const userName = reaction.message.author?.username || \"unknown\";\r\n            const name = reaction.message.author?.displayName || userName;\r\n\r\n            // Ensure connection\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                userName,\r\n                name,\r\n                \"discord\"\r\n            );\r\n\r\n            // Create memory with retry logic\r\n            const memory = {\r\n                id: reactionUUID,\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: reactionMessage,\r\n                    source: \"discord\",\r\n                    inReplyTo: stringToUuid(\r\n                        `${reaction.message.id}-${this.runtime.agentId}`\r\n                    ),\r\n                },\r\n                roomId,\r\n                createdAt: timestamp,\r\n                embedding: getEmbeddingZeroVector(),\r\n            };\r\n\r\n            try {\r\n                await this.runtime.messageManager.createMemory(memory);\r\n                elizaLogger.debug(\"Reaction memory created\", {\r\n                    reactionId: reactionUUID,\r\n                    emoji,\r\n                    userId: user.id,\r\n                });\r\n            } catch (error) {\r\n                if (error.code === \"23505\") {\r\n                    // Duplicate key error\r\n                    elizaLogger.warn(\"Duplicate reaction memory, skipping\", {\r\n                        reactionId: reactionUUID,\r\n                    });\r\n                    return;\r\n                }\r\n                throw error; // Re-throw other errors\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error handling reaction:\", error);\r\n        }\r\n    }\r\n\r\n    async handleReactionRemove(reaction: MessageReaction, user: User) {\r\n        elizaLogger.log(\"Reaction removed\");\r\n        // if (user.bot) return;\r\n\r\n        let emoji = reaction.emoji.name;\r\n        if (!emoji && reaction.emoji.id) {\r\n            emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\r\n        }\r\n\r\n        // Fetch the full message if it's a partial\r\n        if (reaction.partial) {\r\n            try {\r\n                await reaction.fetch();\r\n            } catch (error) {\r\n                console.error(\r\n                    \"Something went wrong when fetching the message:\",\r\n                    error\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        const messageContent = reaction.message.content;\r\n        const truncatedContent =\r\n            messageContent.length > 50\r\n                ? messageContent.substring(0, 50) + \"...\"\r\n                : messageContent;\r\n\r\n        const reactionMessage = `*Removed <${emoji} emoji> from: \"${truncatedContent}\"*`;\r\n\r\n        const roomId = stringToUuid(\r\n            reaction.message.channel.id + \"-\" + this.runtime.agentId\r\n        );\r\n        const userIdUUID = stringToUuid(user.id);\r\n\r\n        // Generate a unique UUID for the reaction removal\r\n        const reactionUUID = stringToUuid(\r\n            `${reaction.message.id}-${user.id}-${emoji}-removed-${this.runtime.agentId}`\r\n        );\r\n\r\n        const userName = reaction.message.author.username;\r\n        const name = reaction.message.author.displayName;\r\n\r\n        await this.runtime.ensureConnection(\r\n            userIdUUID,\r\n            roomId,\r\n            userName,\r\n            name,\r\n            \"discord\"\r\n        );\r\n\r\n        try {\r\n            // Save the reaction removal as a message\r\n            await this.runtime.messageManager.createMemory({\r\n                id: reactionUUID, // This is the ID of the reaction removal message\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: reactionMessage,\r\n                    source: \"discord\",\r\n                    inReplyTo: stringToUuid(\r\n                        reaction.message.id + \"-\" + this.runtime.agentId\r\n                    ), // This is the ID of the original message\r\n                },\r\n                roomId,\r\n                createdAt: Date.now(),\r\n                embedding: getEmbeddingZeroVector(),\r\n            });\r\n        } catch (error) {\r\n            console.error(\"Error creating reaction removal message:\", error);\r\n        }\r\n    }\r\n\r\n    private handleGuildCreate(guild: Guild) {\r\n        console.log(`Joined guild ${guild.name}`);\r\n        this.voiceManager.scanGuild(guild);\r\n    }\r\n\r\n    private async handleInteractionCreate(interaction: any) {\r\n        if (!interaction.isCommand()) return;\r\n\r\n        switch (interaction.commandName) {\r\n            case \"joinchannel\":\r\n                await this.voiceManager.handleJoinChannelCommand(interaction);\r\n                break;\r\n            case \"leavechannel\":\r\n                await this.voiceManager.handleLeaveChannelCommand(interaction);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private async onReady() {\r\n        const guilds = await this.client.guilds.fetch();\r\n        for (const [, guild] of guilds) {\r\n            const fullGuild = await guild.fetch();\r\n            this.voiceManager.scanGuild(fullGuild);\r\n        }\r\n    }\r\n}\r\n\r\nexport function startDiscord(runtime: IAgentRuntime) {\r\n    return new DiscordClient(runtime);\r\n}\r\n\r\nexport const DiscordClientInterface: ElizaClient = {\r\n    start: async (runtime: IAgentRuntime) => new DiscordClient(runtime),\r\n    stop: async (runtime: IAgentRuntime) => {\r\n        try {\r\n            // stop it\r\n            elizaLogger.log(\"Stopping discord client\", runtime.agentId);\r\n            await runtime.clients.discord.stop();\r\n        } catch (e) {\r\n            elizaLogger.error(\"client-discord interface stop error\", e);\r\n        }\r\n    },\r\n};\r\n","import { composeContext, getModelSettings } from \"@elizaos/core\";\r\nimport { generateText, trimTokens } from \"@elizaos/core\";\r\nimport { parseJSONObjectFromText } from \"@elizaos/core\";\r\nimport {\r\n    type Action,\r\n    type ActionExample,\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    ModelClass,\r\n    type State,\r\n} from \"@elizaos/core\";\r\nimport * as fs from \"fs\";\r\n\r\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\r\n{{currentSummary}}\r\n\r\n# Current attachments we are summarizing\r\n{{attachmentsWithText}}\r\n\r\nSummarization objective: {{objective}}\r\n\r\n# Instructions: Summarize the attachments. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details based on the objective. Only respond with the new summary text.`;\r\n\r\nexport const attachmentIdsTemplate = `# Messages we are summarizing\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting a summary of specific attachments. Your goal is to determine their objective, along with the list of attachment IDs to summarize.\r\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation.\r\nThe \"attachmentIds\" is an array of attachment IDs that the user wants to summarize. If not specified, default to including all attachments from the conversation.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"objective\": \"<What the user wants to summarize>\",\r\n  \"attachmentIds\": [\"<Attachment ID 1>\", \"<Attachment ID 2>\", ...]\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getAttachmentIds = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n): Promise<{ objective: string; attachmentIds: string[] } | null> => {\r\n    state = (await runtime.composeState(message)) as State;\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: attachmentIdsTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        console.log(\"response\", response);\r\n        // try parsing to a json object\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            objective: string;\r\n            attachmentIds: string[];\r\n        } | null;\r\n        // see if it contains objective and attachmentIds\r\n        if (parsedResponse?.objective && parsedResponse?.attachmentIds) {\r\n            return parsedResponse;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst summarizeAction = {\r\n    name: \"CHAT_WITH_ATTACHMENTS\",\r\n    similes: [\r\n        \"CHAT_WITH_ATTACHMENT\",\r\n        \"SUMMARIZE_FILES\",\r\n        \"SUMMARIZE_FILE\",\r\n        \"SUMMARIZE_ATACHMENT\",\r\n        \"CHAT_WITH_PDF\",\r\n        \"ATTACHMENT_SUMMARY\",\r\n        \"RECAP_ATTACHMENTS\",\r\n        \"SUMMARIZE_FILE\",\r\n        \"SUMMARIZE_VIDEO\",\r\n        \"SUMMARIZE_AUDIO\",\r\n        \"SUMMARIZE_IMAGE\",\r\n        \"SUMMARIZE_DOCUMENT\",\r\n        \"SUMMARIZE_LINK\",\r\n        \"ATTACHMENT_SUMMARY\",\r\n        \"FILE_SUMMARY\",\r\n    ],\r\n    description:\r\n        \"Answer a user request informed by specific attachments based on their IDs. If a user asks to chat with a PDF, or wants more specific information about a link or video or anything else they've attached, this is the action to use.\",\r\n    validate: async (\r\n        _runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n        // only show if one of the keywords are in the message\r\n        const keywords: string[] = [\r\n            \"attachment\",\r\n            \"summary\",\r\n            \"summarize\",\r\n            \"research\",\r\n            \"pdf\",\r\n            \"video\",\r\n            \"audio\",\r\n            \"image\",\r\n            \"document\",\r\n            \"link\",\r\n            \"file\",\r\n            \"attachment\",\r\n            \"summarize\",\r\n            \"code\",\r\n            \"report\",\r\n            \"write\",\r\n            \"details\",\r\n            \"information\",\r\n            \"talk\",\r\n            \"chat\",\r\n            \"read\",\r\n            \"listen\",\r\n            \"watch\",\r\n        ];\r\n        return keywords.some((keyword) =>\r\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        state = (await runtime.composeState(message)) as State;\r\n\r\n        const callbackData: Content = {\r\n            text: \"\", // fill in later\r\n            action: \"CHAT_WITH_ATTACHMENTS_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n\r\n        // 1. extract attachment IDs from the message\r\n        const attachmentData = await getAttachmentIds(runtime, message, state);\r\n        if (!attachmentData) {\r\n            console.error(\"Couldn't get attachment IDs from message\");\r\n            return;\r\n        }\r\n\r\n        const { objective, attachmentIds } = attachmentData;\r\n\r\n        // This is pretty gross but it can catch cases where the returned generated UUID is stupidly wrong for some reason\r\n        const attachments = state.recentMessagesData\r\n            .filter(\r\n                (msg) =>\r\n                    msg.content.attachments &&\r\n                    msg.content.attachments.length > 0\r\n            )\r\n            .flatMap((msg) => msg.content.attachments)\r\n            // check by first 5 characters of uuid\r\n            .filter(\r\n                (attachment) =>\r\n                    attachmentIds\r\n                        .map((attch) => attch.toLowerCase().slice(0, 5))\r\n                        .includes(attachment.id.toLowerCase().slice(0, 5)) ||\r\n                    // or check the other way\r\n                    attachmentIds.some((id) => {\r\n                        const attachmentId = id.toLowerCase().slice(0, 5);\r\n                        return attachment.id\r\n                            .toLowerCase()\r\n                            .includes(attachmentId);\r\n                    })\r\n            );\r\n\r\n        const attachmentsWithText = attachments\r\n            .map((attachment) => `# ${attachment.title}\\n${attachment.text}`)\r\n            .join(\"\\n\\n\");\r\n\r\n        let currentSummary = \"\";\r\n\r\n        const modelSettings = getModelSettings(\r\n            runtime.character.modelProvider,\r\n            ModelClass.SMALL\r\n        );\r\n        const chunkSize = modelSettings.maxOutputTokens;\r\n\r\n        state.attachmentsWithText = attachmentsWithText;\r\n        state.objective = objective;\r\n        const template = await trimTokens(\r\n            summarizationTemplate,\r\n            chunkSize + 500,\r\n            runtime\r\n        );\r\n        const context = composeContext({\r\n            state,\r\n            // make sure it fits, we can pad the tokens a bit\r\n            // Get the model's tokenizer based on the current model being used\r\n            template,\r\n        });\r\n\r\n        const summary = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        currentSummary = currentSummary + \"\\n\" + summary;\r\n\r\n        if (!currentSummary) {\r\n            console.error(\"No summary found, that's not good!\");\r\n            return;\r\n        }\r\n\r\n        callbackData.text = currentSummary.trim();\r\n        if (\r\n            callbackData.text &&\r\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\r\n                currentSummary.trim()?.split(\" \").length < 100)\r\n        ) {\r\n            callbackData.text = `Here is the summary:\r\n\\`\\`\\`md\r\n${currentSummary.trim()}\r\n\\`\\`\\`\r\n`;\r\n            await callback(callbackData);\r\n        } else if (currentSummary.trim()) {\r\n            const summaryFilename = `content/summary_${Date.now()}.md`;\r\n\r\n            try {\r\n                // Debug: Log before file operations\r\n                console.log(\"Creating summary file:\", {\r\n                    filename: summaryFilename,\r\n                    summaryLength: currentSummary.length,\r\n                });\r\n\r\n                // Write file directly first\r\n                await fs.promises.writeFile(\r\n                    summaryFilename,\r\n                    currentSummary,\r\n                    \"utf8\"\r\n                );\r\n                console.log(\"File written successfully\");\r\n\r\n                // Then cache it\r\n                await runtime.cacheManager.set(summaryFilename, currentSummary);\r\n                console.log(\"Cache set operation completed\");\r\n\r\n                await callback(\r\n                    {\r\n                        ...callbackData,\r\n                        text: `I've attached the summary of the requested attachments as a text file.`,\r\n                    },\r\n                    [summaryFilename]\r\n                );\r\n                console.log(\"Callback completed with summary file\");\r\n            } catch (error) {\r\n                console.error(\"Error in file/cache process:\", error);\r\n                throw error;\r\n            }\r\n        } else {\r\n            console.warn(\r\n                \"Empty response from chat with attachments action, skipping\"\r\n            );\r\n        }\r\n\r\n        return callbackData;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you summarize the attachments b3e23, c4f67, and d5a89?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure thing! I'll pull up those specific attachments and provide a summary of their content.\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"I need a technical summary of the PDFs I sent earlier - a1b2c3.pdf, d4e5f6.pdf, and g7h8i9.pdf\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"I'll take a look at those specific PDF attachments and put together a technical summary for you. Give me a few minutes to review them.\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you watch this video for me and tell me which parts you think are most relevant to the report I'm writing? (the one I attached in my last message)\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sure, no problem.\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"can you read my blog post and give me a detailed breakdown of the key points I made, and then suggest a handful of tweets to promote it?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"great idea, give me a minute\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n\r\nexport default summarizeAction;\r\n","import path from \"path\";\r\nimport { composeContext } from \"@elizaos/core\";\r\nimport { parseJSONObjectFromText } from \"@elizaos/core\";\r\nimport {\r\n    type Action,\r\n    type ActionExample,\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type IVideoService,\r\n    type Memory,\r\n    ModelClass,\r\n    ServiceType,\r\n    type State,\r\n} from \"@elizaos/core\";\r\nimport { generateText } from \"@elizaos/core\";\r\n\r\nexport const mediaUrlTemplate = `# Messages we are searching for a media URL\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting to download a specific media file (video or audio). Your goal is to determine the URL of the media they want to download.\r\nThe \"mediaUrl\" is the URL of the media file that the user wants downloaded. If not specified, return null.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"mediaUrl\": \"<Media URL>\"\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getMediaUrl = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n): Promise<string | null> => {\r\n    if (!state) {\r\n        state = (await runtime.composeState(message)) as State;\r\n    }\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: mediaUrlTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            mediaUrl: string;\r\n        } | null;\r\n\r\n        if (parsedResponse?.mediaUrl) {\r\n            return parsedResponse.mediaUrl;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nexport default {\r\n    name: \"DOWNLOAD_MEDIA\",\r\n    similes: [\r\n        \"DOWNLOAD_VIDEO\",\r\n        \"DOWNLOAD_AUDIO\",\r\n        \"GET_MEDIA\",\r\n        \"DOWNLOAD_PODCAST\",\r\n        \"DOWNLOAD_YOUTUBE\",\r\n    ],\r\n    description:\r\n        \"Downloads a video or audio file from a URL and attaches it to the response message.\",\r\n    validate: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        const videoService = runtime\r\n            .getService<IVideoService>(ServiceType.VIDEO)\r\n            .getInstance();\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        }\r\n\r\n        const mediaUrl = await getMediaUrl(runtime, message, state);\r\n        if (!mediaUrl) {\r\n            console.error(\"Couldn't get media URL from messages\");\r\n            return;\r\n        }\r\n\r\n        const videoInfo = await videoService.fetchVideoInfo(mediaUrl);\r\n        const mediaPath = await videoService.downloadVideo(videoInfo);\r\n\r\n        const response: Content = {\r\n            text: `I downloaded the video \"${videoInfo.title}\" and attached it below.`,\r\n            action: \"DOWNLOAD_MEDIA_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n\r\n        const filename = path.basename(mediaPath);\r\n\r\n        const maxRetries = 3;\r\n        let retries = 0;\r\n\r\n        while (retries < maxRetries) {\r\n            try {\r\n                await callback(\r\n                    {\r\n                        ...response,\r\n                    },\r\n                    [\"content_cache/\" + filename]\r\n                );\r\n                break;\r\n            } catch (error) {\r\n                retries++;\r\n                console.error(\r\n                    `Error sending message (attempt ${retries}):`,\r\n                    error\r\n                );\r\n\r\n                if (retries === maxRetries) {\r\n                    console.error(\r\n                        \"Max retries reached. Failed to send message with attachment.\"\r\n                    );\r\n                    break;\r\n                }\r\n\r\n                // Wait for a short delay before retrying\r\n                await new Promise((resolve) => setTimeout(resolve, 2000));\r\n            }\r\n        }\r\n\r\n        return response;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Downloading the YouTube video now, one sec\",\r\n                    action: \"DOWNLOAD_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you grab this video for me? https://vimeo.com/123456789\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure thing, I'll download that Vimeo video for you\",\r\n                    action: \"DOWNLOAD_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"I need this video downloaded: https://www.youtube.com/watch?v=abcdefg\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"No problem, I'm on it. I'll have that YouTube video downloaded in a jiffy\",\r\n                    action: \"DOWNLOAD_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","// eslint-disable-next-line\r\n// @ts-nocheck\r\n// src/actions/joinVoice\r\nimport {\r\n    type Action,\r\n    type ActionExample,\r\n    composeContext,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    type State,\r\n    generateText,\r\n    ModelClass,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    type Channel,\r\n    ChannelType,\r\n    type Client,\r\n    type Message as DiscordMessage,\r\n    type Guild,\r\n    type GuildMember,\r\n} from \"discord.js\";\r\nimport { joinVoiceChannel } from \"@discordjs/voice\";\r\n\r\nexport default {\r\n    name: \"JOIN_VOICE\",\r\n    similes: [\r\n        \"JOIN_VOICE\",\r\n        \"JOIN_VC\",\r\n        \"JOIN_VOICE_CHAT\",\r\n        \"JOIN_VOICE_CHANNEL\",\r\n        \"JOIN_MEETING\",\r\n        \"JOIN_CALL\",\r\n    ],\r\n    validate: async (\r\n        _runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            // not a discord message\r\n            return false;\r\n        }\r\n\r\n        if (!state.discordClient) {\r\n            return;\r\n        }\r\n\r\n        // did they say something about joining a voice channel? if not, don't validate\r\n        const keywords = [\r\n            \"join\",\r\n            \"come to\",\r\n            \"come on\",\r\n            \"enter\",\r\n            \"voice\",\r\n            \"chat\",\r\n            \"talk\",\r\n            \"call\",\r\n            \"hop on\",\r\n            \"get on\",\r\n            \"vc\",\r\n            \"meeting\",\r\n            \"discussion\",\r\n        ];\r\n        if (\r\n            !keywords.some((keyword) =>\r\n                message.content.text.toLowerCase().includes(keyword)\r\n            )\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n    description: \"Join a voice channel to participate in voice chat.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ): Promise<boolean> => {\r\n        if (!state) {\r\n            console.error(\"State is not available.\");\r\n        }\r\n\r\n        // We normalize data in from voice channels\r\n        const discordMessage = (state.discordChannel ||\r\n            state.discordMessage) as DiscordMessage;\r\n\r\n        if (!discordMessage.content) {\r\n            discordMessage.content = message.content.text;\r\n        }\r\n\r\n        const id = (discordMessage as DiscordMessage).guild?.id as string;\r\n        const client = state.discordClient as Client;\r\n        const voiceChannels = (\r\n            client.guilds.cache.get(id) as Guild\r\n        ).channels.cache.filter(\r\n            (channel: Channel) => channel.type === ChannelType.GuildVoice\r\n        );\r\n\r\n        const messageContent = discordMessage.content;\r\n\r\n        const targetChannel = voiceChannels.find((channel) => {\r\n            const name = (channel as { name: string }).name.toLowerCase();\r\n\r\n            // remove all non-alphanumeric characters (keep spaces between words)\r\n            const replacedName = name.replace(/[^a-z0-9 ]/g, \"\");\r\n\r\n            return (\r\n                name.includes(messageContent) ||\r\n                messageContent.includes(name) ||\r\n                replacedName.includes(messageContent) ||\r\n                messageContent.includes(replacedName)\r\n            );\r\n        });\r\n\r\n        if (targetChannel) {\r\n            joinVoiceChannel({\r\n                channelId: targetChannel.id,\r\n                guildId: (discordMessage as DiscordMessage).guild?.id as string,\r\n                adapterCreator: (client.guilds.cache.get(id) as Guild)\r\n                    .voiceAdapterCreator,\r\n                selfDeaf: false,\r\n                selfMute: false,\r\n                group: client.user.id,\r\n            });\r\n            return true;\r\n        } else {\r\n            const member = (discordMessage as DiscordMessage)\r\n                .member as GuildMember;\r\n            if (member?.voice?.channel) {\r\n                joinVoiceChannel({\r\n                    channelId: member.voice.channel.id,\r\n                    guildId: (discordMessage as DiscordMessage).guild\r\n                        ?.id as string,\r\n                    adapterCreator: (client.guilds.cache.get(id) as Guild)\r\n                        .voiceAdapterCreator,\r\n                    selfDeaf: false,\r\n                    selfMute: false,\r\n                    group: client.user.id,\r\n                });\r\n                return true;\r\n            }\r\n\r\n            const messageTemplate = `\r\nThe user has requested to join a voice channel.\r\nHere is the list of channels available in the server:\r\n{{voiceChannels}}\r\n\r\nHere is the user's request:\r\n{{userMessage}}\r\n\r\nPlease respond with the name of the voice channel which the bot should join. Try to infer what channel the user is talking about. If the user didn't specify a voice channel, respond with \"none\".\r\nYou should only respond with the name of the voice channel or none, no commentary or additional information should be included.\r\n`;\r\n\r\n            const guessState = {\r\n                userMessage: message.content.text,\r\n                voiceChannels: voiceChannels\r\n                    .map((channel) => (channel as { name: string }).name)\r\n                    .join(\"\\n\"),\r\n            };\r\n\r\n            const context = composeContext({\r\n                template: messageTemplate,\r\n                state: guessState as unknown as State,\r\n            });\r\n\r\n            const _datestr = new Date().toUTCString().replace(/:/g, \"-\");\r\n\r\n            const responseContent = await generateText({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            runtime.databaseAdapter.log({\r\n                body: { message, context, response: responseContent },\r\n                userId: message.userId,\r\n                roomId: message.roomId,\r\n                type: \"joinvoice\",\r\n            });\r\n\r\n            if (responseContent && responseContent.trim().length > 0) {\r\n                // join the voice channel\r\n                const channelName = responseContent.toLowerCase();\r\n\r\n                const targetChannel = voiceChannels.find((channel) => {\r\n                    const name = (\r\n                        channel as { name: string }\r\n                    ).name.toLowerCase();\r\n\r\n                    // remove all non-alphanumeric characters (keep spaces between words)\r\n                    const replacedName = name.replace(/[^a-z0-9 ]/g, \"\");\r\n\r\n                    return (\r\n                        name.includes(channelName) ||\r\n                        channelName.includes(name) ||\r\n                        replacedName.includes(channelName) ||\r\n                        channelName.includes(replacedName)\r\n                    );\r\n                });\r\n\r\n                if (targetChannel) {\r\n                    joinVoiceChannel({\r\n                        channelId: targetChannel.id,\r\n                        guildId: (discordMessage as DiscordMessage).guild\r\n                            ?.id as string,\r\n                        adapterCreator: (client.guilds.cache.get(id) as Guild)\r\n                            .voiceAdapterCreator,\r\n                        selfDeaf: false,\r\n                        selfMute: false,\r\n                        group: client.user.id,\r\n                    });\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            await (discordMessage as DiscordMessage).reply(\r\n                \"I couldn't figure out which channel you wanted me to join.\"\r\n            );\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey, let's jump into the 'General' voice and chat\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sounds good\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"{{user2}}, can you join the vc, I want to discuss our strat\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure I'll join right now\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"hey {{user2}}, we're having a team meeting in the 'conference' voice channel, plz join us\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"OK see you there\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"{{user2}}, let's have a quick voice chat in the 'Lounge' channel.\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"kk be there in a sec\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey {{user2}}, can you join me in the 'Music' voice channel\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"join voice chat with us {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"coming\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"hop in vc {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"joining now\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"get in vc with us {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"im in\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","// src/actions/leaveVoice\r\nimport { getVoiceConnection } from \"@discordjs/voice\";\r\nimport {\r\n    type Channel,\r\n    ChannelType,\r\n    type Client,\r\n    type Message as DiscordMessage,\r\n} from \"discord.js\";\r\nimport type {\r\n    Action,\r\n    ActionExample,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n} from \"@elizaos/core\";\r\n\r\nexport default {\r\n    name: \"LEAVE_VOICE\",\r\n    similes: [\r\n        \"LEAVE_VOICE\",\r\n        \"LEAVE_VC\",\r\n        \"LEAVE_VOICE_CHAT\",\r\n        \"LEAVE_VOICE_CHANNEL\",\r\n        \"LEAVE_MEETING\",\r\n        \"LEAVE_CALL\",\r\n    ],\r\n    validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\r\n        if (message.content.source !== \"discord\") {\r\n            // not a discord message\r\n            return false;\r\n        }\r\n\r\n        if (!state.discordClient) {\r\n            return false;\r\n        }\r\n\r\n        const keywords = [\r\n            \"leave\",\r\n            \"exit\",\r\n            \"stop\",\r\n            \"quit\",\r\n            \"get off\",\r\n            \"get out\",\r\n            \"bye\",\r\n            \"cya\",\r\n            \"see you\",\r\n            \"hop off\",\r\n            \"get off\",\r\n            \"voice\",\r\n            \"vc\",\r\n            \"chat\",\r\n            \"call\",\r\n            \"meeting\",\r\n            \"discussion\",\r\n        ];\r\n        if (\r\n            !keywords.some((keyword) =>\r\n                message.content.text.toLowerCase().includes(keyword)\r\n            )\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        const client = state.discordClient as Client;\r\n\r\n        // Check if the client is connected to any voice channel\r\n        const isConnectedToVoice = client.voice.adapters.size > 0;\r\n\r\n        return isConnectedToVoice;\r\n    },\r\n    description: \"Leave the current voice channel.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ): Promise<boolean> => {\r\n        if (!state.discordClient) {\r\n            return;\r\n        }\r\n\r\n        const discordMessage = (state.discordMessage ||\r\n            state.discordChannel) as DiscordMessage;\r\n\r\n        if (!discordMessage) {\r\n            throw new Error(\"Discord message is not available in the state.\");\r\n        }\r\n        const voiceChannels = (state.discordClient as Client)?.guilds.cache\r\n            .get((discordMessage as DiscordMessage).guild?.id as string)\r\n            ?.channels.cache.filter(\r\n                (channel: Channel) => channel.type === ChannelType.GuildVoice\r\n            );\r\n\r\n        voiceChannels?.forEach((_channel: Channel) => {\r\n            const connection = getVoiceConnection(\r\n                (discordMessage as DiscordMessage).guild?.id as string\r\n            );\r\n            if (connection) {\r\n                connection.destroy();\r\n            }\r\n        });\r\n        return true;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey {{user2}} please leave the voice channel\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"I have to go now but thanks for the chat\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"You too, talk to you later\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Great call everyone, hopping off now\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Agreed, I'll hop off too\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey {{user2}} I need you to step away from the voice chat for a bit\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"No worries, I'll leave the voice channel\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"{{user2}}, I think we covered everything, you can leave the voice chat now\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sounds good, see you both later\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"leave voice {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"ok leaving\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"plz leave the voice chat {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"aight im out\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"yo {{user2}} gtfo the vc\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sorry, talk to you later\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import { composeContext, getModelSettings } from \"@elizaos/core\";\r\nimport { generateText, splitChunks, trimTokens } from \"@elizaos/core\";\r\nimport { getActorDetails } from \"@elizaos/core\";\r\nimport { parseJSONObjectFromText } from \"@elizaos/core\";\r\nimport {\r\n    type Action,\r\n    type ActionExample,\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Media,\r\n    type Memory,\r\n    ModelClass,\r\n    type State,\r\n} from \"@elizaos/core\";\r\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\r\n{{currentSummary}}\r\n\r\n# Current conversation chunk we are summarizing (includes attachments)\r\n{{memoriesWithAttachments}}\r\n\r\nSummarization objective: {{objective}}\r\n\r\n# Instructions: Summarize the conversation so far. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details to the objective. Only respond with the new summary text.\r\nYour response should be extremely detailed and include any and all relevant information.`;\r\n\r\nexport const dateRangeTemplate = `# Messages we are summarizing (the conversation is continued after this)\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting a summary of the conversation. Your goal is to determine their objective, along with the range of dates that their request covers.\r\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation. If they just ask for a general summary, you can either base it off the conversation if the summary range is very recent, or set the object to be general, like \"a detailed summary of the conversation between all users\".\r\nThe \"start\" and \"end\" are the range of dates that the user wants to summarize, relative to the current time. The start and end should be relative to the current time, and measured in seconds, minutes, hours and days. The format is \"2 days ago\" or \"3 hours ago\" or \"4 minutes ago\" or \"5 seconds ago\", i.e. \"<integer> <unit> ago\".\r\nIf you aren't sure, you can use a default range of \"0 minutes ago\" to \"2 hours ago\" or more. Better to err on the side of including too much than too little.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"objective\": \"<What the user wants to summarize>\",\r\n  \"start\": \"0 minutes ago\",\r\n  \"end\": \"2 hours ago\"\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getDateRange = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n) => {\r\n    state = (await runtime.composeState(message)) as State;\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: dateRangeTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        console.log(\"response\", response);\r\n        // try parsing to a json object\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            objective: string;\r\n            start: string | number;\r\n            end: string | number;\r\n        } | null;\r\n        // see if it contains objective, start and end\r\n        if (parsedResponse) {\r\n            if (\r\n                parsedResponse.objective &&\r\n                parsedResponse.start &&\r\n                parsedResponse.end\r\n            ) {\r\n                // TODO: parse start and end into timestamps\r\n                const startIntegerString = (\r\n                    parsedResponse.start as string\r\n                ).match(/\\d+/)?.[0];\r\n                const endIntegerString = (parsedResponse.end as string).match(\r\n                    /\\d+/\r\n                )?.[0];\r\n\r\n                // parse multiplier\r\n                const multipliers = {\r\n                    second: 1 * 1000,\r\n                    minute: 60 * 1000,\r\n                    hour: 3600 * 1000,\r\n                    day: 86400 * 1000,\r\n                };\r\n\r\n                const startMultiplier = (parsedResponse.start as string).match(\r\n                    /second|minute|hour|day/\r\n                )?.[0];\r\n                const endMultiplier = (parsedResponse.end as string).match(\r\n                    /second|minute|hour|day/\r\n                )?.[0];\r\n\r\n                const startInteger = startIntegerString\r\n                    ? Number.parseInt(startIntegerString)\r\n                    : 0;\r\n                const endInteger = endIntegerString\r\n                    ? Number.parseInt(endIntegerString)\r\n                    : 0;\r\n\r\n                // multiply by multiplier\r\n                const startTime =\r\n                    startInteger *\r\n                    multipliers[startMultiplier as keyof typeof multipliers];\r\n\r\n                console.log(\"startTime\", startTime);\r\n\r\n                const endTime =\r\n                    endInteger *\r\n                    multipliers[endMultiplier as keyof typeof multipliers];\r\n\r\n                console.log(\"endTime\", endTime);\r\n\r\n                // get the current time and subtract the start and end times\r\n                parsedResponse.start = Date.now() - startTime;\r\n                parsedResponse.end = Date.now() - endTime;\r\n\r\n                return parsedResponse;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst summarizeAction = {\r\n    name: \"SUMMARIZE_CONVERSATION\",\r\n    similes: [\r\n        \"RECAP\",\r\n        \"RECAP_CONVERSATION\",\r\n        \"SUMMARIZE_CHAT\",\r\n        \"SUMMARIZATION\",\r\n        \"CHAT_SUMMARY\",\r\n        \"CONVERSATION_SUMMARY\",\r\n    ],\r\n    description: \"Summarizes the conversation and attachments.\",\r\n    validate: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n        // only show if one of the keywords are in the message\r\n        const keywords: string[] = [\r\n            \"summarize\",\r\n            \"summarization\",\r\n            \"summary\",\r\n            \"recap\",\r\n            \"report\",\r\n            \"overview\",\r\n            \"review\",\r\n            \"rundown\",\r\n            \"wrap-up\",\r\n            \"brief\",\r\n            \"debrief\",\r\n            \"abstract\",\r\n            \"synopsis\",\r\n            \"outline\",\r\n            \"digest\",\r\n            \"abridgment\",\r\n            \"condensation\",\r\n            \"encapsulation\",\r\n            \"essence\",\r\n            \"gist\",\r\n            \"main points\",\r\n            \"key points\",\r\n            \"key takeaways\",\r\n            \"bulletpoint\",\r\n            \"highlights\",\r\n            \"tldr\",\r\n            \"tl;dr\",\r\n            \"in a nutshell\",\r\n            \"bottom line\",\r\n            \"long story short\",\r\n            \"sum up\",\r\n            \"sum it up\",\r\n            \"short version\",\r\n            \"bring me up to speed\",\r\n            \"catch me up\",\r\n        ];\r\n        return keywords.some((keyword) =>\r\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        state = (await runtime.composeState(message)) as State;\r\n\r\n        const callbackData: Content = {\r\n            text: \"\", // fill in later\r\n            action: \"SUMMARIZATION_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n        const { roomId } = message;\r\n\r\n        // 1. extract date range from the message\r\n        const dateRange = await getDateRange(runtime, message, state);\r\n        if (!dateRange) {\r\n            console.error(\"Couldn't get date range from message\");\r\n            return;\r\n        }\r\n\r\n        console.log(\"dateRange\", dateRange);\r\n\r\n        const { objective, start, end } = dateRange;\r\n\r\n        // 2. get these memories from the database\r\n        const memories = await runtime.messageManager.getMemories({\r\n            roomId,\r\n            // subtract start from current time\r\n            start: Number.parseInt(start as string),\r\n            end: Number.parseInt(end as string),\r\n            count: 10000,\r\n            unique: false,\r\n        });\r\n\r\n        const actors = await getActorDetails({\r\n            runtime: runtime as IAgentRuntime,\r\n            roomId,\r\n        });\r\n\r\n        const actorMap = new Map(actors.map((actor) => [actor.id, actor]));\r\n\r\n        const formattedMemories = memories\r\n            .map((memory) => {\r\n                const attachments = memory.content.attachments\r\n                    ?.map((attachment: Media) => {\r\n                        return `---\\nAttachment: ${attachment.id}\\n${attachment.description}\\n${attachment.text}\\n---`;\r\n                    })\r\n                    .join(\"\\n\");\r\n                return `${actorMap.get(memory.userId)?.name ?? \"Unknown User\"} (${actorMap.get(memory.userId)?.username ?? \"\"}): ${memory.content.text}\\n${attachments}`;\r\n            })\r\n            .join(\"\\n\");\r\n\r\n        let currentSummary = \"\";\r\n\r\n        const modelSettings = getModelSettings(\r\n            runtime.character.modelProvider,\r\n            ModelClass.SMALL\r\n        );\r\n        const chunkSize = modelSettings.maxOutputTokens - 1000;\r\n\r\n        const chunks = await splitChunks(formattedMemories, chunkSize, 0);\r\n\r\n        const _datestr = new Date().toUTCString().replace(/:/g, \"-\");\r\n\r\n        state.memoriesWithAttachments = formattedMemories;\r\n        state.objective = objective;\r\n\r\n        for (let i = 0; i < chunks.length; i++) {\r\n            const chunk = chunks[i];\r\n            state.currentSummary = currentSummary;\r\n            state.currentChunk = chunk;\r\n            const template = await trimTokens(\r\n                summarizationTemplate,\r\n                chunkSize + 500,\r\n                runtime\r\n            );\r\n            const context = composeContext({\r\n                state,\r\n                // make sure it fits, we can pad the tokens a bit\r\n                template,\r\n            });\r\n\r\n            const summary = await generateText({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            currentSummary = currentSummary + \"\\n\" + summary;\r\n        }\r\n\r\n        if (!currentSummary) {\r\n            console.error(\"No summary found, that's not good!\");\r\n            return;\r\n        }\r\n\r\n        callbackData.text = currentSummary.trim();\r\n        if (\r\n            callbackData.text &&\r\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\r\n                currentSummary.trim()?.split(\" \").length < 100)\r\n        ) {\r\n            callbackData.text = `Here is the summary:\r\n\\`\\`\\`md\r\n${currentSummary.trim()}\r\n\\`\\`\\`\r\n`;\r\n            await callback(callbackData);\r\n        } else if (currentSummary.trim()) {\r\n            const summaryFilename = `content/conversation_summary_${Date.now()}`;\r\n            await runtime.cacheManager.set(summaryFilename, currentSummary);\r\n            // save the summary to a file\r\n            await callback(\r\n                {\r\n                    ...callbackData,\r\n                    text: `I've attached the summary of the conversation from \\`${new Date(Number.parseInt(start as string)).toString()}\\` to \\`${new Date(Number.parseInt(end as string)).toString()}\\` as a text file.`,\r\n                },\r\n                [summaryFilename]\r\n            );\r\n        } else {\r\n            console.warn(\r\n                \"Empty response from summarize conversation action, skipping\"\r\n            );\r\n        }\r\n\r\n        return callbackData;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"```js\\nconst x = 10\\n```\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"can you give me a detailed report on what we're talking about?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sure, no problem, give me a minute to get that together for you\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"please summarize the conversation we just had and include this blogpost i'm linking (Attachment: b3e12)\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sure, give me a sec\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you summarize what moon and avf are talking about?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Yeah, just hold on a second while I get that together for you...\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"i need to write a blog post about farming, can you summarize the discussion from a few hours ago?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"no problem, give me a few minutes to read through everything\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n\r\nexport default summarizeAction;\r\n","import { composeContext } from \"@elizaos/core\";\r\nimport { generateText } from \"@elizaos/core\";\r\nimport { parseJSONObjectFromText } from \"@elizaos/core\";\r\nimport {\r\n    type Action,\r\n    type ActionExample,\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    ModelClass,\r\n    type State,\r\n} from \"@elizaos/core\";\r\n\r\nexport const transcriptionTemplate = `# Transcription of media file\r\n{{mediaTranscript}}\r\n\r\n# Instructions: Return only the full transcript of the media file without any additional context or commentary.`;\r\n\r\nexport const mediaAttachmentIdTemplate = `# Messages we are transcribing\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting a transcription of a specific media file (audio or video). Your goal is to determine the ID of the attachment they want transcribed.\r\nThe \"attachmentId\" is the ID of the media file attachment that the user wants transcribed. If not specified, return null.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"attachmentId\": \"<Attachment ID>\"\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getMediaAttachmentId = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n): Promise<string | null> => {\r\n    state = (await runtime.composeState(message)) as State;\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: mediaAttachmentIdTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        console.log(\"response\", response);\r\n\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            attachmentId: string;\r\n        } | null;\r\n\r\n        if (parsedResponse?.attachmentId) {\r\n            return parsedResponse.attachmentId;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst transcribeMediaAction = {\r\n    name: \"TRANSCRIBE_MEDIA\",\r\n    similes: [\r\n        \"TRANSCRIBE_AUDIO\",\r\n        \"TRANSCRIBE_VIDEO\",\r\n        \"MEDIA_TRANSCRIPT\",\r\n        \"VIDEO_TRANSCRIPT\",\r\n        \"AUDIO_TRANSCRIPT\",\r\n    ],\r\n    description:\r\n        \"Transcribe the full text of an audio or video file that the user has attached.\",\r\n    validate: async (\r\n        _runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n\r\n        const keywords: string[] = [\r\n            \"transcribe\",\r\n            \"transcript\",\r\n            \"audio\",\r\n            \"video\",\r\n            \"media\",\r\n            \"youtube\",\r\n            \"meeting\",\r\n            \"recording\",\r\n            \"podcast\",\r\n            \"call\",\r\n            \"conference\",\r\n            \"interview\",\r\n            \"speech\",\r\n            \"lecture\",\r\n            \"presentation\",\r\n        ];\r\n        return keywords.some((keyword) =>\r\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        state = (await runtime.composeState(message)) as State;\r\n\r\n        const callbackData: Content = {\r\n            text: \"\", // fill in later\r\n            action: \"TRANSCRIBE_MEDIA_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n\r\n        const attachmentId = await getMediaAttachmentId(\r\n            runtime,\r\n            message,\r\n            state\r\n        );\r\n        if (!attachmentId) {\r\n            console.error(\"Couldn't get media attachment ID from message\");\r\n            return;\r\n        }\r\n\r\n        const attachment = state.recentMessagesData\r\n            .filter(\r\n                (msg) =>\r\n                    msg.content.attachments &&\r\n                    msg.content.attachments.length > 0\r\n            )\r\n            .flatMap((msg) => msg.content.attachments)\r\n            .find(\r\n                (attachment) =>\r\n                    attachment.id.toLowerCase() === attachmentId.toLowerCase()\r\n            );\r\n\r\n        if (!attachment) {\r\n            console.error(`Couldn't find attachment with ID ${attachmentId}`);\r\n            return;\r\n        }\r\n\r\n        const mediaTranscript = attachment.text;\r\n\r\n        callbackData.text = mediaTranscript.trim();\r\n\r\n        // if callbackData.text is < 4 lines or < 100 words, then we we callback with normal message wrapped in markdown block\r\n        if (\r\n            callbackData.text &&\r\n            (callbackData.text?.split(\"\\n\").length < 4 ||\r\n                callbackData.text?.split(\" \").length < 100)\r\n        ) {\r\n            callbackData.text = `Here is the transcript:\r\n\\`\\`\\`md\r\n${mediaTranscript.trim()}\r\n\\`\\`\\`\r\n`;\r\n            await callback(callbackData);\r\n        }\r\n        // if text is big, let's send as an attachment\r\n        else if (callbackData.text) {\r\n            const transcriptFilename = `content/transcript_${Date.now()}`;\r\n\r\n            // save the transcript to a file\r\n            await runtime.cacheManager.set(\r\n                transcriptFilename,\r\n                callbackData.text\r\n            );\r\n\r\n            await callback(\r\n                {\r\n                    ...callbackData,\r\n                    text: `I've attached the transcript as a text file.`,\r\n                },\r\n                [transcriptFilename]\r\n            );\r\n        } else {\r\n            console.warn(\r\n                \"Empty response from transcribe media action, skipping\"\r\n            );\r\n        }\r\n\r\n        return callbackData;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Please transcribe the audio file I just sent.\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure, I'll transcribe the full audio for you.\",\r\n                    action: \"TRANSCRIBE_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can I get a transcript of that video recording?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Absolutely, give me a moment to generate the full transcript of the video.\",\r\n                    action: \"TRANSCRIBE_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n\r\nexport default transcribeMediaAction;\r\n","import { composeContext, composeRandomUser } from \"@elizaos/core\";\r\nimport { generateMessageResponse, generateShouldRespond } from \"@elizaos/core\";\r\nimport {\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type IBrowserService,\r\n    type ISpeechService,\r\n    type IVideoService,\r\n    type Media,\r\n    type Memory,\r\n    ModelClass,\r\n    ServiceType,\r\n    type State,\r\n    type UUID,\r\n} from \"@elizaos/core\";\r\nimport { stringToUuid, getEmbeddingZeroVector } from \"@elizaos/core\";\r\nimport {\r\n    ChannelType,\r\n    type Client,\r\n    type Message as DiscordMessage,\r\n    type TextChannel,\r\n} from \"discord.js\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\nimport { AttachmentManager } from \"./attachments.ts\";\r\nimport type { VoiceManager } from \"./voice.ts\";\r\nimport {\r\n    discordShouldRespondTemplate,\r\n    discordMessageHandlerTemplate,\r\n    discordAutoPostTemplate,\r\n    discordAnnouncementHypeTemplate\r\n} from \"./templates.ts\";\r\nimport {\r\n    IGNORE_RESPONSE_WORDS,\r\n    LOSE_INTEREST_WORDS,\r\n    MESSAGE_CONSTANTS,\r\n    MESSAGE_LENGTH_THRESHOLDS,\r\n    RESPONSE_CHANCES,\r\n    TEAM_COORDINATION,\r\n    TIMING_CONSTANTS,\r\n} from \"./constants\";\r\nimport {\r\n    sendMessageInChunks,\r\n    canSendMessage,\r\n    cosineSimilarity,\r\n} from \"./utils.ts\";\r\n\r\ninterface MessageContext {\r\n    content: string;\r\n    timestamp: number;\r\n}\r\n\r\ninterface AutoPostConfig {\r\n    enabled: boolean;\r\n    monitorTime: number;\r\n    inactivityThreshold: number; // milliseconds\r\n    mainChannelId: string;\r\n    announcementChannelIds: string[];\r\n    lastAutoPost?: number;\r\n    minTimeBetweenPosts?: number; // minimum time between auto posts\r\n}\r\n\r\nexport type InterestChannels = {\r\n    [key: string]: {\r\n        currentHandler: string | undefined;\r\n        lastMessageSent: number;\r\n        messages: { userId: UUID; userName: string; content: Content }[];\r\n        previousContext?: MessageContext;\r\n        contextSimilarityThreshold?: number;\r\n    };\r\n};\r\n\r\nexport class MessageManager {\r\n    private client: Client;\r\n    private runtime: IAgentRuntime;\r\n    private attachmentManager: AttachmentManager;\r\n    private interestChannels: InterestChannels = {};\r\n    private discordClient: any;\r\n    private voiceManager: VoiceManager;\r\n    //Auto post\r\n    private autoPostConfig: AutoPostConfig;\r\n    private lastChannelActivity: { [channelId: string]: number } = {};\r\n    private autoPostInterval: NodeJS.Timeout;\r\n\r\n    constructor(discordClient: any, voiceManager: VoiceManager) {\r\n        this.client = discordClient.client;\r\n        this.voiceManager = voiceManager;\r\n        this.discordClient = discordClient;\r\n        this.runtime = discordClient.runtime;\r\n        this.attachmentManager = new AttachmentManager(this.runtime);\r\n\r\n        this.autoPostConfig = {\r\n            enabled: this.runtime.character.clientConfig?.discord?.autoPost?.enabled || false,\r\n            monitorTime: this.runtime.character.clientConfig?.discord?.autoPost?.monitorTime || 300000,\r\n            inactivityThreshold: this.runtime.character.clientConfig?.discord?.autoPost?.inactivityThreshold || 3600000, // 1 hour default\r\n            mainChannelId: this.runtime.character.clientConfig?.discord?.autoPost?.mainChannelId,\r\n            announcementChannelIds: this.runtime.character.clientConfig?.discord?.autoPost?.announcementChannelIds || [],\r\n            minTimeBetweenPosts: this.runtime.character.clientConfig?.discord?.autoPost?.minTimeBetweenPosts || 7200000, // 2 hours default\r\n        };\r\n\r\n        if (this.autoPostConfig.enabled) {\r\n            this._startAutoPostMonitoring();\r\n        }\r\n    }\r\n\r\n    async handleMessage(message: DiscordMessage) {\r\n\r\n        if (this.runtime.character.clientConfig?.discord?.allowedChannelIds &&\r\n            !this.runtime.character.clientConfig.discord.allowedChannelIds.includes(message.channelId)) {\r\n            return;\r\n        }\r\n\r\n        // Update last activity time for the channel\r\n        this.lastChannelActivity[message.channelId] = Date.now();\r\n\r\n        if (\r\n            message.interaction ||\r\n            message.author.id ===\r\n                this.client.user?.id /* || message.author?.bot*/\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldIgnoreBotMessages &&\r\n            message.author?.bot\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Check for mentions-only mode setting\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldRespondOnlyToMentions\r\n        ) {\r\n            if (!this._isMessageForMe(message)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldIgnoreDirectMessages &&\r\n            message.channel.type === ChannelType.DM\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const userId = message.author.id as UUID;\r\n        const userName = message.author.username;\r\n        const name = message.author.displayName;\r\n        const channelId = message.channel.id;\r\n        const isDirectlyMentioned = this._isMessageForMe(message);\r\n        const hasInterest = this._checkInterest(message.channelId);\r\n\r\n        // Team handling\r\n        if (\r\n            this.runtime.character.clientConfig?.discord?.isPartOfTeam &&\r\n            !this.runtime.character.clientConfig?.discord\r\n                ?.shouldRespondOnlyToMentions\r\n        ) {\r\n            const authorId = this._getNormalizedUserId(message.author.id);\r\n\r\n            if (\r\n                !this._isTeamLeader() &&\r\n                this._isRelevantToTeamMember(message.content, channelId)\r\n            ) {\r\n                this.interestChannels[message.channelId] = {\r\n                    currentHandler: this.client.user?.id,\r\n                    lastMessageSent: Date.now(),\r\n                    messages: [],\r\n                };\r\n            }\r\n\r\n            const isTeamRequest = this._isTeamCoordinationRequest(\r\n                message.content\r\n            );\r\n            const isLeader = this._isTeamLeader();\r\n\r\n            // After team-wide responses, check if we should maintain interest\r\n            if (hasInterest && !isDirectlyMentioned) {\r\n                const lastSelfMemories =\r\n                    await this.runtime.messageManager.getMemories({\r\n                        roomId: stringToUuid(\r\n                            channelId + \"-\" + this.runtime.agentId\r\n                        ),\r\n                        unique: false,\r\n                        count: 5,\r\n                    });\r\n\r\n                const lastSelfSortedMemories = lastSelfMemories\r\n                    ?.filter((m) => m.userId === this.runtime.agentId)\r\n                    .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));\r\n\r\n                const isRelevant = this._isRelevantToTeamMember(\r\n                    message.content,\r\n                    channelId,\r\n                    lastSelfSortedMemories?.[0]\r\n                );\r\n\r\n                if (!isRelevant) {\r\n                    // Clearing interest - conversation not relevant to team member\r\n                    delete this.interestChannels[message.channelId];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (isTeamRequest) {\r\n                if (isLeader) {\r\n                    this.interestChannels[message.channelId] = {\r\n                        currentHandler: this.client.user?.id,\r\n                        lastMessageSent: Date.now(),\r\n                        messages: [],\r\n                    };\r\n                } else {\r\n                    // Set temporary interest for this response\r\n                    this.interestChannels[message.channelId] = {\r\n                        currentHandler: this.client.user?.id,\r\n                        lastMessageSent: Date.now(),\r\n                        messages: [],\r\n                    };\r\n\r\n                    // Clear interest after this cycle unless directly mentioned\r\n                    if (!isDirectlyMentioned) {\r\n                        // Use existing message cycle to clear interest\r\n                        this.interestChannels[\r\n                            message.channelId\r\n                        ].lastMessageSent = 0;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check for other team member mentions\r\n            const otherTeamMembers =\r\n                this.runtime.character.clientConfig.discord.teamAgentIds.filter(\r\n                    (id) => id !== this.client.user?.id\r\n                );\r\n            const mentionedTeamMember = otherTeamMembers.find((id) =>\r\n                message.content.includes(`<@${id}>`)\r\n            );\r\n\r\n            // If another team member is mentioned, clear our interest\r\n            if (mentionedTeamMember) {\r\n                if (\r\n                    hasInterest ||\r\n                    this.interestChannels[message.channelId]?.currentHandler ===\r\n                        this.client.user?.id\r\n                ) {\r\n                    delete this.interestChannels[message.channelId];\r\n\r\n                    // Only return if we're not the mentioned member\r\n                    if (!isDirectlyMentioned) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set/maintain interest only if we're mentioned or already have interest\r\n            if (isDirectlyMentioned) {\r\n                this.interestChannels[message.channelId] = {\r\n                    currentHandler: this.client.user?.id,\r\n                    lastMessageSent: Date.now(),\r\n                    messages: [],\r\n                };\r\n            } else if (!isTeamRequest && !hasInterest) {\r\n                return;\r\n            }\r\n\r\n            // Bot-specific checks\r\n            if (message.author.bot) {\r\n                if (this._isTeamMember(authorId) && !isDirectlyMentioned) {\r\n                    return;\r\n                } else if (\r\n                    this.runtime.character.clientConfig.discord\r\n                        .shouldIgnoreBotMessages\r\n                ) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        try {\r\n            const { processedContent, attachments } =\r\n                await this.processMessageMedia(message);\r\n\r\n            const audioAttachments = message.attachments.filter((attachment) =>\r\n                attachment.contentType?.startsWith(\"audio/\")\r\n            );\r\n            if (audioAttachments.size > 0) {\r\n                const processedAudioAttachments =\r\n                    await this.attachmentManager.processAttachments(\r\n                        audioAttachments\r\n                    );\r\n                attachments.push(...processedAudioAttachments);\r\n            }\r\n\r\n            const roomId = stringToUuid(channelId + \"-\" + this.runtime.agentId);\r\n            const userIdUUID = stringToUuid(userId);\r\n\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                userName,\r\n                name,\r\n                \"discord\"\r\n            );\r\n\r\n            const messageId = stringToUuid(\r\n                message.id + \"-\" + this.runtime.agentId\r\n            );\r\n\r\n            let shouldIgnore = false;\r\n            let shouldRespond = true;\r\n\r\n            const content: Content = {\r\n                text: processedContent,\r\n                attachments: attachments,\r\n                source: \"discord\",\r\n                url: message.url,\r\n                inReplyTo: message.reference?.messageId\r\n                    ? stringToUuid(\r\n                          message.reference.messageId +\r\n                              \"-\" +\r\n                              this.runtime.agentId\r\n                      )\r\n                    : undefined,\r\n            };\r\n\r\n            const userMessage = {\r\n                content,\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n            };\r\n\r\n            const memory: Memory = {\r\n                id: stringToUuid(message.id + \"-\" + this.runtime.agentId),\r\n                ...userMessage,\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                content,\r\n                createdAt: message.createdTimestamp,\r\n            };\r\n\r\n            if (content.text) {\r\n                await this.runtime.messageManager.addEmbeddingToMemory(memory);\r\n                await this.runtime.messageManager.createMemory(memory);\r\n\r\n                if (this.interestChannels[message.channelId]) {\r\n                    // Add new message\r\n                    this.interestChannels[message.channelId].messages.push({\r\n                        userId: userIdUUID,\r\n                        userName: userName,\r\n                        content: content,\r\n                    });\r\n\r\n                    // Trim to keep only recent messages\r\n                    if (\r\n                        this.interestChannels[message.channelId].messages\r\n                            .length > MESSAGE_CONSTANTS.MAX_MESSAGES\r\n                    ) {\r\n                        this.interestChannels[message.channelId].messages =\r\n                            this.interestChannels[\r\n                                message.channelId\r\n                            ].messages.slice(-MESSAGE_CONSTANTS.MAX_MESSAGES);\r\n                    }\r\n                }\r\n            }\r\n\r\n            let state = await this.runtime.composeState(userMessage, {\r\n                discordClient: this.client,\r\n                discordMessage: message,\r\n                agentName:\r\n                    this.runtime.character.name ||\r\n                    this.client.user?.displayName,\r\n            });\r\n\r\n            const canSendResult = canSendMessage(message.channel);\r\n            if (!canSendResult.canSend) {\r\n                return elizaLogger.warn(\r\n                    `Cannot send message to channel ${message.channel}`,\r\n                    canSendResult\r\n                );\r\n            }\r\n\r\n            if (!shouldIgnore) {\r\n                shouldIgnore = await this._shouldIgnore(message);\r\n            }\r\n\r\n            if (shouldIgnore) {\r\n                return;\r\n            }\r\n\r\n            const agentUserState =\r\n                await this.runtime.databaseAdapter.getParticipantUserState(\r\n                    roomId,\r\n                    this.runtime.agentId\r\n                );\r\n\r\n            if (\r\n                agentUserState === \"MUTED\" &&\r\n                !message.mentions.has(this.client.user.id) &&\r\n                !hasInterest\r\n            ) {\r\n                console.log(\"Ignoring muted room\");\r\n                // Ignore muted rooms unless explicitly mentioned\r\n                return;\r\n            }\r\n\r\n            if (agentUserState === \"FOLLOWED\") {\r\n                shouldRespond = true; // Always respond in followed rooms\r\n            } else if (\r\n                (!shouldRespond && hasInterest) ||\r\n                (shouldRespond && !hasInterest)\r\n            ) {\r\n                shouldRespond = await this._shouldRespond(message, state);\r\n            }\r\n\r\n            if (shouldRespond) {\r\n                const context = composeContext({\r\n                    state,\r\n                    template:\r\n                        this.runtime.character.templates\r\n                            ?.discordMessageHandlerTemplate ||\r\n                        discordMessageHandlerTemplate,\r\n                });\r\n\r\n                // simulate discord typing while generating a response\r\n                const stopTyping = this.simulateTyping(message);\r\n\r\n                const responseContent = await this._generateResponse(\r\n                    memory,\r\n                    state,\r\n                    context\r\n                ).finally(() => {\r\n                    stopTyping();\r\n                });\r\n\r\n                responseContent.text = responseContent.text?.trim();\r\n                responseContent.inReplyTo = stringToUuid(\r\n                    message.id + \"-\" + this.runtime.agentId\r\n                );\r\n\r\n                if (!responseContent.text) {\r\n                    return;\r\n                }\r\n\r\n                const callback: HandlerCallback = async (\r\n                    content: Content,\r\n                    files: any[]\r\n                ) => {\r\n                    try {\r\n                        if (message.id && !content.inReplyTo) {\r\n                            content.inReplyTo = stringToUuid(\r\n                                message.id + \"-\" + this.runtime.agentId\r\n                            );\r\n                        }\r\n                        const messages = await sendMessageInChunks(\r\n                            message.channel as TextChannel,\r\n                            content.text,\r\n                            message.id,\r\n                            files\r\n                        );\r\n\r\n                        const memories: Memory[] = [];\r\n                        for (const m of messages) {\r\n                            let action = content.action;\r\n                            // If there's only one message or it's the last message, keep the original action\r\n                            // For multiple messages, set all but the last to 'CONTINUE'\r\n                            if (\r\n                                messages.length > 1 &&\r\n                                m !== messages[messages.length - 1]\r\n                            ) {\r\n                                action = \"CONTINUE\";\r\n                            }\r\n\r\n                            const memory: Memory = {\r\n                                id: stringToUuid(\r\n                                    m.id + \"-\" + this.runtime.agentId\r\n                                ),\r\n                                userId: this.runtime.agentId,\r\n                                agentId: this.runtime.agentId,\r\n                                content: {\r\n                                    ...content,\r\n                                    action,\r\n                                    inReplyTo: messageId,\r\n                                    url: m.url,\r\n                                },\r\n                                roomId,\r\n                                embedding: getEmbeddingZeroVector(),\r\n                                createdAt: m.createdTimestamp,\r\n                            };\r\n                            memories.push(memory);\r\n                        }\r\n                        for (const m of memories) {\r\n                            await this.runtime.messageManager.createMemory(m);\r\n                        }\r\n                        return memories;\r\n                    } catch (error) {\r\n                        console.error(\"Error sending message:\", error);\r\n                        return [];\r\n                    }\r\n                };\r\n\r\n                const responseMessages = await callback(responseContent);\r\n\r\n                state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                await this.runtime.processActions(\r\n                    memory,\r\n                    responseMessages,\r\n                    state,\r\n                    callback\r\n                );\r\n            }\r\n            await this.runtime.evaluate(memory, state, shouldRespond);\r\n        } catch (error) {\r\n            console.error(\"Error handling message:\", error);\r\n            if (message.channel.type === ChannelType.GuildVoice) {\r\n                // For voice channels, use text-to-speech for the error message\r\n                const errorMessage = \"Sorry, I had a glitch. What was that?\";\r\n\r\n                const speechService = this.runtime.getService<ISpeechService>(\r\n                    ServiceType.SPEECH_GENERATION\r\n                );\r\n                if (!speechService) {\r\n                    throw new Error(\"Speech generation service not found\");\r\n                }\r\n\r\n                const audioStream = await speechService.generate(\r\n                    this.runtime,\r\n                    errorMessage\r\n                );\r\n                await this.voiceManager.playAudioStream(userId, audioStream);\r\n            } else {\r\n                // For text channels, send the error message\r\n                console.error(\"Error sending message:\", error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async cacheMessages(channel: TextChannel, count = 20) {\r\n        const messages = await channel.messages.fetch({ limit: count });\r\n\r\n        // TODO: This is throwing an error but seems to work?\r\n        for (const [_, message] of messages) {\r\n            await this.handleMessage(message);\r\n        }\r\n    }\r\n\r\n    private _startAutoPostMonitoring(): void {\r\n        // Wait for client to be ready\r\n        if (!this.client.isReady()) {\r\n            elizaLogger.info('[AutoPost Discord] Client not ready, waiting for ready event')\r\n            this.client.once('ready', () => {\r\n                elizaLogger.info('[AutoPost Discord] Client ready, starting monitoring')\r\n                this._initializeAutoPost();\r\n            });\r\n        } else {\r\n            elizaLogger.info('[AutoPost Discord] Client already ready, starting monitoring')\r\n            this._initializeAutoPost();\r\n        }\r\n    }\r\n\r\n    private _initializeAutoPost(): void {\r\n        // Give the client a moment to fully load its cache\r\n        setTimeout(() => {\r\n            // Monitor with random intervals between 2-6 hours\r\n            this.autoPostInterval = setInterval(() => {\r\n                this._checkChannelActivity();\r\n            }, Math.floor(Math.random() * (4 * 60 * 60 * 1000) + 2 * 60 * 60 * 1000));\r\n\r\n            // Start monitoring announcement channels\r\n            this._monitorAnnouncementChannels();\r\n        }, 5000); // 5 second delay to ensure everything is loaded\r\n    }\r\n\r\n    private async _checkChannelActivity(): Promise<void> {\r\n        if (!this.autoPostConfig.enabled || !this.autoPostConfig.mainChannelId) return;\r\n\r\n        const channel = this.client.channels.cache.get(this.autoPostConfig.mainChannelId) as TextChannel;\r\n        if (!channel) return;\r\n\r\n        try {\r\n            // Get last message time\r\n            const messages = await channel.messages.fetch({ limit: 1 });\r\n            const lastMessage = messages.first();\r\n            const lastMessageTime = lastMessage ? lastMessage.createdTimestamp : 0;\r\n\r\n            const now = Date.now();\r\n            const timeSinceLastMessage = now - lastMessageTime;\r\n            const timeSinceLastAutoPost = now - (this.autoPostConfig.lastAutoPost || 0);\r\n\r\n            // Add some randomness to the inactivity threshold (±30 minutes)\r\n            const randomThreshold = this.autoPostConfig.inactivityThreshold +\r\n                (Math.random() * 1800000 - 900000);\r\n\r\n            // Check if we should post\r\n            if ((timeSinceLastMessage > randomThreshold) &&\r\n                timeSinceLastAutoPost > (this.autoPostConfig.minTimeBetweenPosts || 0)) {\r\n\r\n                try {\r\n                    // Create memory and generate response\r\n                    const roomId = stringToUuid(channel.id + \"-\" + this.runtime.agentId);\r\n\r\n                    const memory = {\r\n                        id: stringToUuid(`autopost-${Date.now()}`),\r\n                        userId: this.runtime.agentId,\r\n                        agentId: this.runtime.agentId,\r\n                        roomId,\r\n                        content: { text: \"AUTO_POST_ENGAGEMENT\", source: \"discord\" },\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: Date.now()\r\n                    };\r\n\r\n                    let state = await this.runtime.composeState(memory, {\r\n                        discordClient: this.client,\r\n                        discordMessage: null,\r\n                        agentName: this.runtime.character.name || this.client.user?.displayName\r\n                    });\r\n\r\n                    // Generate response using template\r\n                    const context = composeContext({\r\n                        state,\r\n                        template: this.runtime.character.templates?.discordAutoPostTemplate || discordAutoPostTemplate\r\n                    });\r\n\r\n                    const responseContent = await this._generateResponse(memory, state, context);\r\n                    if (!responseContent?.text) return;\r\n\r\n                    // Send message and update memory\r\n                    const messages = await sendMessageInChunks(channel, responseContent.text.trim(), null, []);\r\n\r\n                    // Create and store memories\r\n                    const memories = messages.map(m => ({\r\n                        id: stringToUuid(m.id + \"-\" + this.runtime.agentId),\r\n                        userId: this.runtime.agentId,\r\n                        agentId: this.runtime.agentId,\r\n                        content: {\r\n                            ...responseContent,\r\n                            url: m.url,\r\n                        },\r\n                        roomId,\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: m.createdTimestamp,\r\n                    }));\r\n\r\n                    for (const m of memories) {\r\n                        await this.runtime.messageManager.createMemory(m);\r\n                    }\r\n\r\n                    // Update state and last post time\r\n                    this.autoPostConfig.lastAutoPost = Date.now();\r\n                    state = await this.runtime.updateRecentMessageState(state);\r\n                    await this.runtime.evaluate(memory, state, true);\r\n                } catch (error) {\r\n                    elizaLogger.warn(\"[AutoPost Discord] Error:\", error);\r\n                }\r\n            } else {\r\n                elizaLogger.warn(\"[AutoPost Discord] Activity within threshold. Not posting.\");\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.warn(\"[AutoPost Discord] Error checking last message:\", error);\r\n        }\r\n    }\r\n\r\n    private async _monitorAnnouncementChannels(): Promise<void> {\r\n        if (!this.autoPostConfig.enabled || !this.autoPostConfig.announcementChannelIds.length) {\r\n            elizaLogger.warn('[AutoPost Discord] Auto post config disabled or no announcement channels')\r\n            return;\r\n        }\r\n\r\n        for (const announcementChannelId of this.autoPostConfig.announcementChannelIds) {\r\n            const channel = this.client.channels.cache.get(announcementChannelId);\r\n\r\n            if (channel) {\r\n                // Check if it's either a text channel or announcement channel\r\n                // ChannelType.GuildAnnouncement is 5\r\n                // ChannelType.GuildText is 0\r\n                if (channel instanceof TextChannel || channel.type === ChannelType.GuildAnnouncement) {\r\n                    const newsChannel = channel as TextChannel;\r\n                    try {\r\n                        newsChannel.createMessageCollector().on('collect', async (message: DiscordMessage) => {\r\n                            if (message.author.bot || Date.now() - message.createdTimestamp > 300000) return;\r\n\r\n                            const mainChannel = this.client.channels.cache.get(this.autoPostConfig.mainChannelId) as TextChannel;\r\n                            if (!mainChannel) return;\r\n\r\n                            try {\r\n                                // Create memory and generate response\r\n                                const roomId = stringToUuid(mainChannel.id + \"-\" + this.runtime.agentId);\r\n                                const memory = {\r\n                                    id: stringToUuid(`announcement-${Date.now()}`),\r\n                                    userId: this.runtime.agentId,\r\n                                    agentId: this.runtime.agentId,\r\n                                    roomId,\r\n                                    content: {\r\n                                        text: message.content,\r\n                                        source: \"discord\",\r\n                                        metadata: { announcementUrl: message.url }\r\n                                    },\r\n                                    embedding: getEmbeddingZeroVector(),\r\n                                    createdAt: Date.now()\r\n                                };\r\n\r\n                                let state = await this.runtime.composeState(memory, {\r\n                                    discordClient: this.client,\r\n                                    discordMessage: message,\r\n                                    announcementContent: message?.content,\r\n                                    announcementChannelId: channel.id,\r\n                                    agentName: this.runtime.character.name || this.client.user?.displayName\r\n                                });\r\n\r\n                                // Generate response using template\r\n                                const context = composeContext({\r\n                                    state,\r\n                                    template: this.runtime.character.templates?.discordAnnouncementHypeTemplate || discordAnnouncementHypeTemplate\r\n\r\n                                });\r\n\r\n                                const responseContent = await this._generateResponse(memory, state, context);\r\n                                if (!responseContent?.text) return;\r\n\r\n                                // Send message and update memory\r\n                                const messages = await sendMessageInChunks(mainChannel, responseContent.text.trim(), null, []);\r\n\r\n                                // Create and store memories\r\n                                const memories = messages.map(m => ({\r\n                                    id: stringToUuid(m.id + \"-\" + this.runtime.agentId),\r\n                                    userId: this.runtime.agentId,\r\n                                    agentId: this.runtime.agentId,\r\n                                    content: {\r\n                                        ...responseContent,\r\n                                        url: m.url,\r\n                                    },\r\n                                    roomId,\r\n                                    embedding: getEmbeddingZeroVector(),\r\n                                    createdAt: m.createdTimestamp,\r\n                                }));\r\n\r\n                                for (const m of memories) {\r\n                                    await this.runtime.messageManager.createMemory(m);\r\n                                }\r\n\r\n                                // Update state\r\n                                state = await this.runtime.updateRecentMessageState(state);\r\n                                await this.runtime.evaluate(memory, state, true);\r\n                            } catch (error) {\r\n                                elizaLogger.warn(\"[AutoPost Discord] Announcement Error:\", error);\r\n                            }\r\n                        });\r\n                        elizaLogger.info(`[AutoPost Discord] Successfully set up collector for announcement channel: ${newsChannel.name}`);\r\n                    } catch (error) {\r\n                        elizaLogger.warn(`[AutoPost Discord] Error setting up announcement channel collector:`, error);\r\n                    }\r\n                } else {\r\n                    elizaLogger.warn(`[AutoPost Discord] Channel ${announcementChannelId} is not a valid announcement or text channel, type:`, channel.type);\r\n                }\r\n            } else {\r\n                elizaLogger.warn(`[AutoPost Discord] Could not find channel ${announcementChannelId} directly`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isMessageForMe(message: DiscordMessage): boolean {\r\n        const isMentioned = message.mentions.users?.has(\r\n            this.client.user?.id as string\r\n        );\r\n        const guild = message.guild;\r\n        const member = guild?.members.cache.get(this.client.user?.id as string);\r\n        const nickname = member?.nickname;\r\n\r\n        // Don't consider role mentions as direct mentions\r\n        const hasRoleMentionOnly =\r\n            message.mentions.roles.size > 0 && !isMentioned;\r\n\r\n        // If it's only a role mention and we're in team mode, let team logic handle it\r\n        if (\r\n            hasRoleMentionOnly &&\r\n            this.runtime.character.clientConfig?.discord?.isPartOfTeam\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            isMentioned ||\r\n            (!this.runtime.character.clientConfig?.discord\r\n                ?.shouldRespondOnlyToMentions &&\r\n                (message.content\r\n                    .toLowerCase()\r\n                    .includes(\r\n                        this.client.user?.username.toLowerCase() as string\r\n                    ) ||\r\n                    message.content\r\n                        .toLowerCase()\r\n                        .includes(\r\n                            this.client.user?.tag.toLowerCase() as string\r\n                        ) ||\r\n                    (nickname &&\r\n                        message.content\r\n                            .toLowerCase()\r\n                            .includes(nickname.toLowerCase()))))\r\n        );\r\n    }\r\n\r\n    async processMessageMedia(\r\n        message: DiscordMessage\r\n    ): Promise<{ processedContent: string; attachments: Media[] }> {\r\n        let processedContent = message.content;\r\n\r\n        let attachments: Media[] = [];\r\n\r\n        // Process code blocks in the message content\r\n        const codeBlockRegex = /```([\\s\\S]*?)```/g;\r\n        let match;\r\n        while ((match = codeBlockRegex.exec(processedContent))) {\r\n            const codeBlock = match[1];\r\n            const lines = codeBlock.split(\"\\n\");\r\n            const title = lines[0];\r\n            const description = lines.slice(0, 3).join(\"\\n\");\r\n            const attachmentId =\r\n                `code-${Date.now()}-${Math.floor(Math.random() * 1000)}`.slice(\r\n                    -5\r\n                );\r\n            attachments.push({\r\n                id: attachmentId,\r\n                url: \"\",\r\n                title: title || \"Code Block\",\r\n                source: \"Code\",\r\n                description: description,\r\n                text: codeBlock,\r\n            });\r\n            processedContent = processedContent.replace(\r\n                match[0],\r\n                `Code Block (${attachmentId})`\r\n            );\r\n        }\r\n\r\n        // Process message attachments\r\n        if (message.attachments.size > 0) {\r\n            attachments = await this.attachmentManager.processAttachments(\r\n                message.attachments\r\n            );\r\n        }\r\n\r\n        // TODO: Move to attachments manager\r\n        const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\r\n        const urls = processedContent.match(urlRegex) || [];\r\n\r\n        for (const url of urls) {\r\n            if (\r\n                this.runtime\r\n                    .getService<IVideoService>(ServiceType.VIDEO)\r\n                    ?.isVideoUrl(url)\r\n            ) {\r\n                const videoService = this.runtime.getService<IVideoService>(\r\n                    ServiceType.VIDEO\r\n                );\r\n                if (!videoService) {\r\n                    throw new Error(\"Video service not found\");\r\n                }\r\n                const videoInfo = await videoService.processVideo(\r\n                    url,\r\n                    this.runtime\r\n                );\r\n\r\n                attachments.push({\r\n                    id: `youtube-${Date.now()}`,\r\n                    url: url,\r\n                    title: videoInfo.title,\r\n                    source: \"YouTube\",\r\n                    description: videoInfo.description,\r\n                    text: videoInfo.text,\r\n                });\r\n            } else {\r\n                const browserService = this.runtime.getService<IBrowserService>(\r\n                    ServiceType.BROWSER\r\n                );\r\n                if (!browserService) {\r\n                    throw new Error(\"Browser service not found\");\r\n                }\r\n\r\n                const { title, description: summary } =\r\n                    await browserService.getPageContent(url, this.runtime);\r\n\r\n                attachments.push({\r\n                    id: `webpage-${Date.now()}`,\r\n                    url: url,\r\n                    title: title || \"Web Page\",\r\n                    source: \"Web\",\r\n                    description: summary,\r\n                    text: summary,\r\n                });\r\n            }\r\n        }\r\n\r\n        return { processedContent, attachments };\r\n    }\r\n\r\n    private _getNormalizedUserId(id: string): string {\r\n        return id.toString().replace(/[^0-9]/g, \"\");\r\n    }\r\n\r\n    private _isTeamMember(userId: string): boolean {\r\n        const teamConfig = this.runtime.character.clientConfig?.discord;\r\n        if (!teamConfig?.isPartOfTeam || !teamConfig.teamAgentIds) return false;\r\n\r\n        const normalizedUserId = this._getNormalizedUserId(userId);\r\n\r\n        const isTeamMember = teamConfig.teamAgentIds.some(\r\n            (teamId) => this._getNormalizedUserId(teamId) === normalizedUserId\r\n        );\r\n\r\n        return isTeamMember;\r\n    }\r\n\r\n    private _isTeamLeader(): boolean {\r\n        return (\r\n            this.client.user?.id ===\r\n            this.runtime.character.clientConfig?.discord?.teamLeaderId\r\n        );\r\n    }\r\n\r\n    private _isTeamCoordinationRequest(content: string): boolean {\r\n        const contentLower = content.toLowerCase();\r\n        return TEAM_COORDINATION.KEYWORDS?.some((keyword) =>\r\n            contentLower.includes(keyword.toLowerCase())\r\n        );\r\n    }\r\n\r\n    private _isRelevantToTeamMember(\r\n        content: string,\r\n        channelId: string,\r\n        lastAgentMemory: Memory | null = null\r\n    ): boolean {\r\n        const teamConfig = this.runtime.character.clientConfig?.discord;\r\n\r\n        if (this._isTeamLeader() && lastAgentMemory?.content.text) {\r\n            const timeSinceLastMessage = Date.now() - lastAgentMemory.createdAt;\r\n            if (timeSinceLastMessage > MESSAGE_CONSTANTS.INTEREST_DECAY_TIME) {\r\n                return false; // Memory too old, not relevant\r\n            }\r\n\r\n            const similarity = cosineSimilarity(\r\n                content.toLowerCase(),\r\n                lastAgentMemory.content.text.toLowerCase()\r\n            );\r\n\r\n            return (\r\n                similarity >=\r\n                MESSAGE_CONSTANTS.DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS\r\n            );\r\n        }\r\n\r\n        // If no keywords defined, only leader maintains conversation\r\n        if (!teamConfig?.teamMemberInterestKeywords) {\r\n            return false;\r\n        }\r\n\r\n        return teamConfig.teamMemberInterestKeywords.some((keyword) =>\r\n            content.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    }\r\n\r\n    private async _analyzeContextSimilarity(\r\n        currentMessage: string,\r\n        previousContext?: MessageContext,\r\n        agentLastMessage?: string\r\n    ): Promise<number> {\r\n        if (!previousContext) return 1; // No previous context to compare against\r\n\r\n        // If more than 5 minutes have passed, reduce similarity weight\r\n        const timeDiff = Date.now() - previousContext.timestamp;\r\n        const timeWeight = Math.max(0, 1 - timeDiff / (5 * 60 * 1000)); // 5 minutes threshold\r\n\r\n        // Calculate content similarity\r\n        const similarity = cosineSimilarity(\r\n            currentMessage.toLowerCase(),\r\n            previousContext.content.toLowerCase(),\r\n            agentLastMessage?.toLowerCase()\r\n        );\r\n\r\n        // Weight the similarity by time factor\r\n        const weightedSimilarity = similarity * timeWeight;\r\n\r\n        return weightedSimilarity;\r\n    }\r\n\r\n    private async _shouldRespondBasedOnContext(\r\n        message: DiscordMessage,\r\n        channelState: InterestChannels[string]\r\n    ): Promise<boolean> {\r\n        // Always respond if directly mentioned\r\n        if (this._isMessageForMe(message)) return true;\r\n\r\n        // If we're not the current handler, don't respond\r\n        if (channelState?.currentHandler !== this.client.user?.id) return false;\r\n\r\n        // Check if we have messages to compare\r\n        if (!channelState.messages?.length) return false;\r\n\r\n        // Get last user message (not from the bot)\r\n        const lastUserMessage = [...channelState.messages].reverse().find(\r\n            (m, index) =>\r\n                index > 0 && // Skip first message (current)\r\n                m.userId !== this.runtime.agentId\r\n        );\r\n\r\n        if (!lastUserMessage) return false;\r\n\r\n        const lastSelfMemories = await this.runtime.messageManager.getMemories({\r\n            roomId: stringToUuid(\r\n                message.channel.id + \"-\" + this.runtime.agentId\r\n            ),\r\n            unique: false,\r\n            count: 5,\r\n        });\r\n\r\n        const lastSelfSortedMemories = lastSelfMemories\r\n            ?.filter((m) => m.userId === this.runtime.agentId)\r\n            .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));\r\n\r\n        // Calculate context similarity\r\n        const contextSimilarity = await this._analyzeContextSimilarity(\r\n            message.content,\r\n            {\r\n                content: lastUserMessage.content.text || \"\",\r\n                timestamp: Date.now(),\r\n            },\r\n            lastSelfSortedMemories?.[0]?.content?.text\r\n        );\r\n\r\n        const similarityThreshold =\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.messageSimilarityThreshold ||\r\n            channelState.contextSimilarityThreshold ||\r\n            MESSAGE_CONSTANTS.DEFAULT_SIMILARITY_THRESHOLD;\r\n\r\n        return contextSimilarity >= similarityThreshold;\r\n    }\r\n\r\n    private _checkInterest(channelId: string): boolean {\r\n        const channelState = this.interestChannels[channelId];\r\n        if (!channelState) return false;\r\n\r\n        const lastMessage =\r\n            channelState.messages[channelState.messages.length - 1];\r\n        // If it's been more than 5 minutes since last message, reduce interest\r\n        const timeSinceLastMessage = Date.now() - channelState.lastMessageSent;\r\n\r\n        if (timeSinceLastMessage > MESSAGE_CONSTANTS.INTEREST_DECAY_TIME) {\r\n            delete this.interestChannels[channelId];\r\n            return false;\r\n        } else if (\r\n            timeSinceLastMessage > MESSAGE_CONSTANTS.PARTIAL_INTEREST_DECAY\r\n        ) {\r\n            // Require stronger relevance for continued interest\r\n            return this._isRelevantToTeamMember(\r\n                lastMessage.content.text || \"\",\r\n                channelId\r\n            );\r\n        }\r\n\r\n        // If team leader and messages exist, check for topic changes and team member responses\r\n        if (this._isTeamLeader() && channelState.messages.length > 0) {\r\n            // If leader's keywords don't match and another team member has responded, drop interest\r\n            if (\r\n                !this._isRelevantToTeamMember(\r\n                    lastMessage.content.text || \"\",\r\n                    channelId\r\n                )\r\n            ) {\r\n                const recentTeamResponses = channelState.messages\r\n                    .slice(-3)\r\n                    .some(\r\n                        (m) =>\r\n                            m.userId !== this.client.user?.id &&\r\n                            this._isTeamMember(m.userId)\r\n                    );\r\n\r\n                if (recentTeamResponses) {\r\n                    delete this.interestChannels[channelId];\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if conversation has shifted to a new topic\r\n        if (channelState.messages.length > 0) {\r\n            const recentMessages = channelState.messages.slice(\r\n                -MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT\r\n            );\r\n            const differentUsers = new Set(recentMessages.map((m) => m.userId))\r\n                .size;\r\n\r\n            // If multiple users are talking and we're not involved, reduce interest\r\n            if (\r\n                differentUsers > 1 &&\r\n                !recentMessages.some((m) => m.userId === this.client.user?.id)\r\n            ) {\r\n                delete this.interestChannels[channelId];\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private async _shouldIgnore(message: DiscordMessage): Promise<boolean> {\r\n        // if the message is from us, ignore\r\n        if (message.author.id === this.client.user?.id) return true;\r\n\r\n        // Honor mentions-only mode\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldRespondOnlyToMentions\r\n        ) {\r\n            return !this._isMessageForMe(message);\r\n        }\r\n\r\n        // Team-based ignore logic\r\n        if (this.runtime.character.clientConfig?.discord?.isPartOfTeam) {\r\n            const authorId = this._getNormalizedUserId(message.author.id);\r\n\r\n            if (this._isTeamLeader()) {\r\n                if (this._isTeamCoordinationRequest(message.content)) {\r\n                    return false;\r\n                }\r\n                // Ignore if message is only about team member interests and not directed to leader\r\n                if (!this._isMessageForMe(message)) {\r\n                    const otherMemberInterests =\r\n                        this.runtime.character.clientConfig?.discord\r\n                            ?.teamMemberInterestKeywords || [];\r\n                    const hasOtherInterests = otherMemberInterests.some(\r\n                        (keyword) =>\r\n                            message.content\r\n                                .toLowerCase()\r\n                                .includes(keyword.toLowerCase())\r\n                    );\r\n                    if (hasOtherInterests) {\r\n                        return true;\r\n                    }\r\n                }\r\n            } else if (this._isTeamCoordinationRequest(message.content)) {\r\n                const randomDelay =\r\n                    Math.floor(\r\n                        Math.random() *\r\n                            (TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MAX -\r\n                                TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MIN)\r\n                    ) + TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MIN; // 1-3 second random delay\r\n                await new Promise((resolve) =>\r\n                    setTimeout(resolve, randomDelay)\r\n                );\r\n                return false;\r\n            }\r\n\r\n            if (this._isTeamMember(authorId)) {\r\n                if (!this._isMessageForMe(message)) {\r\n                    // If message contains our interests, don't ignore\r\n                    if (\r\n                        this._isRelevantToTeamMember(\r\n                            message.content,\r\n                            message.channelId\r\n                        )\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // Check if we're in an active conversation based on context\r\n            const channelState = this.interestChannels[message.channelId];\r\n\r\n            if (channelState?.currentHandler) {\r\n                // If we're the current handler, check context\r\n                if (channelState.currentHandler === this.client.user?.id) {\r\n                    //If it's our keywords, bypass context check\r\n                    if (\r\n                        this._isRelevantToTeamMember(\r\n                            message.content,\r\n                            message.channelId\r\n                        )\r\n                    ) {\r\n                        return false;\r\n                    }\r\n\r\n                    const shouldRespondContext =\r\n                        await this._shouldRespondBasedOnContext(\r\n                            message,\r\n                            channelState\r\n                        );\r\n\r\n                    // If context is different, ignore. If similar, don't ignore\r\n                    return !shouldRespondContext;\r\n                }\r\n\r\n                // If another team member is handling and we're not mentioned or coordinating\r\n                else if (\r\n                    !this._isMessageForMe(message) &&\r\n                    !this._isTeamCoordinationRequest(message.content)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        let messageContent = message.content.toLowerCase();\r\n\r\n        // Replace the bot's @ping with the character name\r\n        const botMention = `<@!?${this.client.user?.id}>`;\r\n        messageContent = messageContent.replace(\r\n            new RegExp(botMention, \"gi\"),\r\n            this.runtime.character.name.toLowerCase()\r\n        );\r\n\r\n        // Replace the bot's username with the character name\r\n        const botUsername = this.client.user?.username.toLowerCase();\r\n        messageContent = messageContent.replace(\r\n            new RegExp(`\\\\b${botUsername}\\\\b`, \"g\"),\r\n            this.runtime.character.name.toLowerCase()\r\n        );\r\n\r\n        // strip all special characters\r\n        messageContent = messageContent.replace(/[^a-zA-Z0-9\\s]/g, \"\");\r\n\r\n        // short responses where eliza should stop talking and disengage unless mentioned again\r\n        if (\r\n            messageContent.length < MESSAGE_LENGTH_THRESHOLDS.LOSE_INTEREST &&\r\n            LOSE_INTEREST_WORDS.some((word) => messageContent.includes(word))\r\n        ) {\r\n            delete this.interestChannels[message.channelId];\r\n            return true;\r\n        }\r\n\r\n        // If we're not interested in the channel and it's a short message, ignore it\r\n        if (\r\n            messageContent.length < MESSAGE_LENGTH_THRESHOLDS.SHORT_MESSAGE &&\r\n            !this.interestChannels[message.channelId]\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        const targetedPhrases = [\r\n            this.runtime.character.name + \" stop responding\",\r\n            this.runtime.character.name + \" stop talking\",\r\n            this.runtime.character.name + \" shut up\",\r\n            this.runtime.character.name + \" stfu\",\r\n            \"stop talking\" + this.runtime.character.name,\r\n            this.runtime.character.name + \" stop talking\",\r\n            \"shut up \" + this.runtime.character.name,\r\n            this.runtime.character.name + \" shut up\",\r\n            \"stfu \" + this.runtime.character.name,\r\n            this.runtime.character.name + \" stfu\",\r\n            \"chill\" + this.runtime.character.name,\r\n            this.runtime.character.name + \" chill\",\r\n        ];\r\n\r\n        // lose interest if pinged and told to stop responding\r\n        if (targetedPhrases.some((phrase) => messageContent.includes(phrase))) {\r\n            delete this.interestChannels[message.channelId];\r\n            return true;\r\n        }\r\n\r\n        // if the message is short, ignore but maintain interest\r\n        if (\r\n            !this.interestChannels[message.channelId] &&\r\n            messageContent.length < MESSAGE_LENGTH_THRESHOLDS.VERY_SHORT_MESSAGE\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            message.content.length <\r\n                MESSAGE_LENGTH_THRESHOLDS.IGNORE_RESPONSE &&\r\n            IGNORE_RESPONSE_WORDS.some((word) =>\r\n                message.content.toLowerCase().includes(word)\r\n            )\r\n        ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private async _shouldRespond(\r\n        message: DiscordMessage,\r\n        state: State\r\n    ): Promise<boolean> {\r\n        if (message.author.id === this.client.user?.id) return false;\r\n        // if (message.author.bot) return false;\r\n\r\n        // Honor mentions-only mode\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldRespondOnlyToMentions\r\n        ) {\r\n            return this._isMessageForMe(message);\r\n        }\r\n\r\n        const channelState = this.interestChannels[message.channelId];\r\n\r\n        // Check if team member has direct interest first\r\n        if (\r\n            this.runtime.character.clientConfig?.discord?.isPartOfTeam &&\r\n            !this._isTeamLeader() &&\r\n            this._isRelevantToTeamMember(message.content, message.channelId)\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        try {\r\n            // Team-based response logic\r\n            if (this.runtime.character.clientConfig?.discord?.isPartOfTeam) {\r\n                // Team leader coordination\r\n                if (\r\n                    this._isTeamLeader() &&\r\n                    this._isTeamCoordinationRequest(message.content)\r\n                ) {\r\n                    return true;\r\n                }\r\n\r\n                if (\r\n                    !this._isTeamLeader() &&\r\n                    this._isRelevantToTeamMember(\r\n                        message.content,\r\n                        message.channelId\r\n                    )\r\n                ) {\r\n                    // Add small delay for non-leader responses\r\n                    await new Promise((resolve) =>\r\n                        setTimeout(resolve, TIMING_CONSTANTS.TEAM_MEMBER_DELAY)\r\n                    ); //1.5 second delay\r\n\r\n                    // If leader has responded in last few seconds, reduce chance of responding\r\n\r\n                    if (channelState?.messages?.length) {\r\n                        const recentMessages = channelState.messages.slice(\r\n                            -MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT\r\n                        );\r\n                        const leaderResponded = recentMessages.some(\r\n                            (m) =>\r\n                                m.userId ===\r\n                                    this.runtime.character.clientConfig?.discord\r\n                                        ?.teamLeaderId &&\r\n                                Date.now() - channelState.lastMessageSent < 3000\r\n                        );\r\n\r\n                        if (leaderResponded) {\r\n                            // 50% chance to respond if leader just did\r\n                            return (\r\n                                Math.random() > RESPONSE_CHANCES.AFTER_LEADER\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n\r\n                // If I'm the leader but message doesn't match my keywords, add delay and check for team responses\r\n                if (\r\n                    this._isTeamLeader() &&\r\n                    !this._isRelevantToTeamMember(\r\n                        message.content,\r\n                        message.channelId\r\n                    )\r\n                ) {\r\n                    const randomDelay =\r\n                        Math.floor(\r\n                            Math.random() *\r\n                                (TIMING_CONSTANTS.LEADER_DELAY_MAX -\r\n                                    TIMING_CONSTANTS.LEADER_DELAY_MIN)\r\n                        ) + TIMING_CONSTANTS.LEADER_DELAY_MIN; // 2-4 second random delay\r\n                    await new Promise((resolve) =>\r\n                        setTimeout(resolve, randomDelay)\r\n                    );\r\n\r\n                    // After delay, check if another team member has already responded\r\n                    if (channelState?.messages?.length) {\r\n                        const recentResponses = channelState.messages.slice(\r\n                            -MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT\r\n                        );\r\n                        const otherTeamMemberResponded = recentResponses.some(\r\n                            (m) =>\r\n                                m.userId !== this.client.user?.id &&\r\n                                this._isTeamMember(m.userId)\r\n                        );\r\n\r\n                        if (otherTeamMemberResponded) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Update current handler if we're mentioned\r\n                if (this._isMessageForMe(message)) {\r\n                    const channelState =\r\n                        this.interestChannels[message.channelId];\r\n                    if (channelState) {\r\n                        channelState.currentHandler = this.client.user?.id;\r\n                        channelState.lastMessageSent = Date.now();\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                // Don't respond if another teammate is handling the conversation\r\n                if (channelState?.currentHandler) {\r\n                    if (\r\n                        channelState.currentHandler !== this.client.user?.id &&\r\n                        this._isTeamMember(channelState.currentHandler)\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                // Natural conversation cadence\r\n                if (!this._isMessageForMe(message) && channelState) {\r\n                    // Count our recent messages\r\n                    const recentMessages = channelState.messages.slice(\r\n                        -MESSAGE_CONSTANTS.CHAT_HISTORY_COUNT\r\n                    );\r\n                    const ourMessageCount = recentMessages.filter(\r\n                        (m) => m.userId === this.client.user?.id\r\n                    ).length;\r\n\r\n                    // Reduce responses if we've been talking a lot\r\n                    if (ourMessageCount > 2) {\r\n                        // Exponentially decrease chance to respond\r\n                        const responseChance = Math.pow(\r\n                            0.5,\r\n                            ourMessageCount - 2\r\n                        );\r\n                        if (Math.random() > responseChance) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in _shouldRespond team processing:\", {\r\n                error,\r\n                agentId: this.runtime.agentId,\r\n                channelId: message.channelId,\r\n            });\r\n        }\r\n\r\n        // Otherwise do context check\r\n        if (channelState?.previousContext) {\r\n            const shouldRespondContext =\r\n                await this._shouldRespondBasedOnContext(message, channelState);\r\n            if (!shouldRespondContext) {\r\n                delete this.interestChannels[message.channelId];\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (message.mentions.has(this.client.user?.id as string)) return true;\r\n\r\n        const guild = message.guild;\r\n        const member = guild?.members.cache.get(this.client.user?.id as string);\r\n        const nickname = member?.nickname;\r\n\r\n        if (\r\n            message.content\r\n                .toLowerCase()\r\n                .includes(this.client.user?.username.toLowerCase() as string) ||\r\n            message.content\r\n                .toLowerCase()\r\n                .includes(this.client.user?.tag.toLowerCase() as string) ||\r\n            (nickname &&\r\n                message.content.toLowerCase().includes(nickname.toLowerCase()))\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (!message.guild) {\r\n            return true;\r\n        }\r\n\r\n        // If none of the above conditions are met, use the generateText to decide\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.discordShouldRespondTemplate ||\r\n                this.runtime.character.templates?.shouldRespondTemplate ||\r\n                composeRandomUser(discordShouldRespondTemplate, 2),\r\n        });\r\n\r\n        const response = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        if (response === \"RESPOND\") {\r\n            if (channelState) {\r\n                channelState.previousContext = {\r\n                    content: message.content,\r\n                    timestamp: Date.now(),\r\n                };\r\n            }\r\n\r\n            return true;\r\n        } else if (response === \"IGNORE\") {\r\n            return false;\r\n        } else if (response === \"STOP\") {\r\n            delete this.interestChannels[message.channelId];\r\n            return false;\r\n        } else {\r\n            console.error(\r\n                \"Invalid response from response generateText:\",\r\n                response\r\n            );\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private async _generateResponse(\r\n        message: Memory,\r\n        state: State,\r\n        context: string\r\n    ): Promise<Content> {\r\n        const { userId, roomId } = message;\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        if (!response) {\r\n            console.error(\"No response from generateMessageResponse\");\r\n            return;\r\n        }\r\n\r\n        await this.runtime.databaseAdapter.log({\r\n            body: { message, context, response },\r\n            userId: userId,\r\n            roomId,\r\n            type: \"response\",\r\n        });\r\n\r\n        return response;\r\n    }\r\n\r\n    async fetchBotName(botToken: string) {\r\n        const url = \"https://discord.com/api/v10/users/@me\";\r\n\r\n        const response = await fetch(url, {\r\n            method: \"GET\",\r\n            headers: {\r\n                Authorization: `Bot ${botToken}`,\r\n            },\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(\r\n                `Error fetching bot details: ${response.statusText}`\r\n            );\r\n        }\r\n\r\n        const data = await response.json();\r\n        return data.username;\r\n    }\r\n\r\n    /**\r\n     * Simulate discord typing while generating a response;\r\n     * returns a function to interrupt the typing loop\r\n     *\r\n     * @param message\r\n     */\r\n    private simulateTyping(message: DiscordMessage) {\r\n        let typing = true;\r\n\r\n        const typingLoop = async () => {\r\n            while (typing) {\r\n                await message.channel.sendTyping();\r\n                await new Promise((resolve) => setTimeout(resolve, 3000));\r\n            }\r\n        };\r\n\r\n        typingLoop();\r\n\r\n        return function stopTyping() {\r\n            typing = false;\r\n        };\r\n    }\r\n}\r\n","import { generateText, trimTokens } from \"@elizaos/core\";\r\nimport { parseJSONObjectFromText } from \"@elizaos/core\";\r\nimport {\r\n    type IAgentRuntime,\r\n    type IImageDescriptionService,\r\n    type IPdfService,\r\n    type ITranscriptionService,\r\n    type IVideoService,\r\n    type Media,\r\n    ModelClass,\r\n    ServiceType,\r\n} from \"@elizaos/core\";\r\nimport { type Attachment, Collection } from \"discord.js\";\r\nimport ffmpeg from \"fluent-ffmpeg\";\r\nimport fs from \"fs\";\r\n\r\nasync function generateSummary(\r\n    runtime: IAgentRuntime,\r\n    text: string\r\n): Promise<{ title: string; description: string }> {\r\n    // make sure text is under 128k characters\r\n    text = await trimTokens(text, 100000, runtime);\r\n\r\n    const prompt = `Please generate a concise summary for the following text:\r\n\r\n  Text: \"\"\"\r\n  ${text}\r\n  \"\"\"\r\n\r\n  Respond with a JSON object in the following format:\r\n  \\`\\`\\`json\r\n  {\r\n    \"title\": \"Generated Title\",\r\n    \"summary\": \"Generated summary and/or description of the text\"\r\n  }\r\n  \\`\\`\\``;\r\n\r\n    const response = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.SMALL,\r\n    });\r\n\r\n    const parsedResponse = parseJSONObjectFromText(response);\r\n\r\n    if (parsedResponse?.title && parsedResponse?.summary) {\r\n        return {\r\n            title: parsedResponse.title,\r\n            description: parsedResponse.summary,\r\n        };\r\n    }\r\n\r\n    return {\r\n        title: \"\",\r\n        description: \"\",\r\n    };\r\n}\r\n\r\nexport class AttachmentManager {\r\n    private attachmentCache: Map<string, Media> = new Map();\r\n    private runtime: IAgentRuntime;\r\n\r\n    constructor(runtime: IAgentRuntime) {\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    async processAttachments(\r\n        attachments: Collection<string, Attachment> | Attachment[]\r\n    ): Promise<Media[]> {\r\n        const processedAttachments: Media[] = [];\r\n        const attachmentCollection =\r\n            attachments instanceof Collection\r\n                ? attachments\r\n                : new Collection(attachments.map((att) => [att.id, att]));\r\n\r\n        for (const [, attachment] of attachmentCollection) {\r\n            const media = await this.processAttachment(attachment);\r\n            if (media) {\r\n                processedAttachments.push(media);\r\n            }\r\n        }\r\n\r\n        return processedAttachments;\r\n    }\r\n\r\n    async processAttachment(attachment: Attachment): Promise<Media | null> {\r\n        if (this.attachmentCache.has(attachment.url)) {\r\n            return this.attachmentCache.get(attachment.url)!;\r\n        }\r\n\r\n        let media: Media | null = null;\r\n        if (attachment.contentType?.startsWith(\"application/pdf\")) {\r\n            media = await this.processPdfAttachment(attachment);\r\n        } else if (attachment.contentType?.startsWith(\"text/plain\")) {\r\n            media = await this.processPlaintextAttachment(attachment);\r\n        } else if (\r\n            attachment.contentType?.startsWith(\"audio/\") ||\r\n            attachment.contentType?.startsWith(\"video/mp4\")\r\n        ) {\r\n            media = await this.processAudioVideoAttachment(attachment);\r\n        } else if (attachment.contentType?.startsWith(\"image/\")) {\r\n            media = await this.processImageAttachment(attachment);\r\n        } else if (\r\n            attachment.contentType?.startsWith(\"video/\") ||\r\n            this.runtime\r\n                .getService<IVideoService>(ServiceType.VIDEO)\r\n                .isVideoUrl(attachment.url)\r\n        ) {\r\n            media = await this.processVideoAttachment(attachment);\r\n        } else {\r\n            media = await this.processGenericAttachment(attachment);\r\n        }\r\n\r\n        if (media) {\r\n            this.attachmentCache.set(attachment.url, media);\r\n        }\r\n        return media;\r\n    }\r\n\r\n    private async processAudioVideoAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        try {\r\n            const response = await fetch(attachment.url);\r\n            const audioVideoArrayBuffer = await response.arrayBuffer();\r\n\r\n            let audioBuffer: Buffer;\r\n            if (attachment.contentType?.startsWith(\"audio/\")) {\r\n                audioBuffer = Buffer.from(audioVideoArrayBuffer);\r\n            } else if (attachment.contentType?.startsWith(\"video/mp4\")) {\r\n                audioBuffer = await this.extractAudioFromMP4(\r\n                    audioVideoArrayBuffer\r\n                );\r\n            } else {\r\n                throw new Error(\"Unsupported audio/video format\");\r\n            }\r\n\r\n            const transcriptionService =\r\n                this.runtime.getService<ITranscriptionService>(\r\n                    ServiceType.TRANSCRIPTION\r\n                );\r\n            if (!transcriptionService) {\r\n                throw new Error(\"Transcription service not found\");\r\n            }\r\n\r\n            const transcription =\r\n                await transcriptionService.transcribeAttachment(audioBuffer);\r\n            const { title, description } = await generateSummary(\r\n                this.runtime,\r\n                transcription\r\n            );\r\n\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"Audio/Video Attachment\",\r\n                source: attachment.contentType?.startsWith(\"audio/\")\r\n                    ? \"Audio\"\r\n                    : \"Video\",\r\n                description:\r\n                    description ||\r\n                    \"User-uploaded audio/video attachment which has been transcribed\",\r\n                text: transcription || \"Audio/video content not available\",\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                `Error processing audio/video attachment: ${error.message}`\r\n            );\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"Audio/Video Attachment\",\r\n                source: attachment.contentType?.startsWith(\"audio/\")\r\n                    ? \"Audio\"\r\n                    : \"Video\",\r\n                description: \"An audio/video attachment (transcription failed)\",\r\n                text: `This is an audio/video attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    private async extractAudioFromMP4(mp4Data: ArrayBuffer): Promise<Buffer> {\r\n        // Use a library like 'fluent-ffmpeg' or 'ffmpeg-static' to extract the audio stream from the MP4 data\r\n        // and convert it to MP3 or WAV format\r\n        // Example using fluent-ffmpeg:\r\n        const tempMP4File = `temp_${Date.now()}.mp4`;\r\n        const tempAudioFile = `temp_${Date.now()}.mp3`;\r\n\r\n        try {\r\n            // Write the MP4 data to a temporary file\r\n            fs.writeFileSync(tempMP4File, Buffer.from(mp4Data));\r\n\r\n            // Extract the audio stream and convert it to MP3\r\n            await new Promise<void>((resolve, reject) => {\r\n                ffmpeg(tempMP4File)\r\n                    .outputOptions(\"-vn\") // Disable video output\r\n                    .audioCodec(\"libmp3lame\") // Set audio codec to MP3\r\n                    .save(tempAudioFile) // Save the output to the specified file\r\n                    .on(\"end\", () => {\r\n                        resolve();\r\n                    })\r\n                    .on(\"error\", (err) => {\r\n                        reject(err);\r\n                    })\r\n                    .run();\r\n            });\r\n\r\n            // Read the converted audio file and return it as a Buffer\r\n            const audioData = fs.readFileSync(tempAudioFile);\r\n            return audioData;\r\n        } finally {\r\n            // Clean up the temporary files\r\n            if (fs.existsSync(tempMP4File)) {\r\n                fs.unlinkSync(tempMP4File);\r\n            }\r\n            if (fs.existsSync(tempAudioFile)) {\r\n                fs.unlinkSync(tempAudioFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async processPdfAttachment(attachment: Attachment): Promise<Media> {\r\n        try {\r\n            const response = await fetch(attachment.url);\r\n            const pdfBuffer = await response.arrayBuffer();\r\n            const text = await this.runtime\r\n                .getService<IPdfService>(ServiceType.PDF)\r\n                .convertPdfToText(Buffer.from(pdfBuffer));\r\n            const { title, description } = await generateSummary(\r\n                this.runtime,\r\n                text\r\n            );\r\n\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"PDF Attachment\",\r\n                source: \"PDF\",\r\n                description: description || \"A PDF document\",\r\n                text: text,\r\n            };\r\n        } catch (error) {\r\n            console.error(`Error processing PDF attachment: ${error.message}`);\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"PDF Attachment (conversion failed)\",\r\n                source: \"PDF\",\r\n                description:\r\n                    \"A PDF document that could not be converted to text\",\r\n                text: `This is a PDF attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\r\n            };\r\n        }\r\n    }\r\n\r\n    private async processPlaintextAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        try {\r\n            const response = await fetch(attachment.url);\r\n            const text = await response.text();\r\n            const { title, description } = await generateSummary(\r\n                this.runtime,\r\n                text\r\n            );\r\n\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"Plaintext Attachment\",\r\n                source: \"Plaintext\",\r\n                description: description || \"A plaintext document\",\r\n                text: text,\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                `Error processing plaintext attachment: ${error.message}`\r\n            );\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"Plaintext Attachment (retrieval failed)\",\r\n                source: \"Plaintext\",\r\n                description: \"A plaintext document that could not be retrieved\",\r\n                text: `This is a plaintext attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\r\n            };\r\n        }\r\n    }\r\n\r\n    private async processImageAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        try {\r\n            const { description, title } = await this.runtime\r\n                .getService<IImageDescriptionService>(\r\n                    ServiceType.IMAGE_DESCRIPTION\r\n                )\r\n                .describeImage(attachment.url);\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"Image Attachment\",\r\n                source: \"Image\",\r\n                description: description || \"An image attachment\",\r\n                text: description || \"Image content not available\",\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                `Error processing image attachment: ${error.message}`\r\n            );\r\n            return this.createFallbackImageMedia(attachment);\r\n        }\r\n    }\r\n\r\n    private createFallbackImageMedia(attachment: Attachment): Media {\r\n        return {\r\n            id: attachment.id,\r\n            url: attachment.url,\r\n            title: \"Image Attachment\",\r\n            source: \"Image\",\r\n            description: \"An image attachment (recognition failed)\",\r\n            text: `This is an image attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\r\n        };\r\n    }\r\n\r\n    private async processVideoAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        const videoService = this.runtime.getService<IVideoService>(\r\n            ServiceType.VIDEO\r\n        );\r\n\r\n        if (!videoService) {\r\n            throw new Error(\"Video service not found\");\r\n        }\r\n\r\n        if (videoService.isVideoUrl(attachment.url)) {\r\n            const videoInfo = await videoService.processVideo(\r\n                attachment.url,\r\n                this.runtime\r\n            );\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: videoInfo.title,\r\n                source: \"YouTube\",\r\n                description: videoInfo.description,\r\n                text: videoInfo.text,\r\n            };\r\n        } else {\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"Video Attachment\",\r\n                source: \"Video\",\r\n                description: \"A video attachment\",\r\n                text: \"Video content not available\",\r\n            };\r\n        }\r\n    }\r\n\r\n    private async processGenericAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        return {\r\n            id: attachment.id,\r\n            url: attachment.url,\r\n            title: \"Generic Attachment\",\r\n            source: \"Generic\",\r\n            description: \"A generic attachment\",\r\n            text: \"Attachment content not available\",\r\n        };\r\n    }\r\n}\r\n","import { messageCompletionFooter, shouldRespondFooter } from \"@elizaos/core\";\r\n\r\nexport const discordShouldRespondTemplate =\r\n    `# Task: Decide if {{agentName}} should respond.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n\r\n# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\r\n\r\n# RESPONSE EXAMPLES\r\n{{user1}}: I just saw a really great movie\r\n{{user2}}: Oh? Which movie?\r\nResult: [IGNORE]\r\n\r\n{{agentName}}: Oh, this is my favorite scene\r\n{{user1}}: sick\r\n{{user2}}: wait, why is it your favorite scene\r\nResult: [RESPOND]\r\n\r\n{{user1}}: stfu bot\r\nResult: [STOP]\r\n\r\n{{user1}}: Hey {{agent}}, can you help me with something\r\nResult: [RESPOND]\r\n\r\n{{user1}}: {{agentName}} stfu plz\r\nResult: [STOP]\r\n\r\n{{user1}}: i need help\r\n{{agentName}}: how can I help you?\r\n{{user1}}: no. i need help from someone else\r\nResult: [IGNORE]\r\n\r\n{{user1}}: Hey {{agent}}, can I ask you a question\r\n{{agentName}}: Sure, what is it\r\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\r\nResult: [RESPOND]\r\n\r\n{{user1}}: {{agentName}} can you tell me a story\r\n{{user1}}: about a girl named elara\r\n{{agentName}}: Sure.\r\n{{agentName}}: Once upon a time, in a quaint little village, there was a curious girl named Elara.\r\n{{agentName}}: Elara was known for her adventurous spirit and her knack for finding beauty in the mundane.\r\n{{user1}}: I'm loving it, keep going\r\nResult: [RESPOND]\r\n\r\n{{user1}}: {{agentName}} stop responding plz\r\nResult: [STOP]\r\n\r\n{{user1}}: okay, i want to test something. can you say marco?\r\n{{agentName}}: marco\r\n{{user1}}: great. okay, now do it again\r\nResult: [RESPOND]\r\n\r\nResponse options are [RESPOND], [IGNORE] and [STOP].\r\n\r\n{{agentName}} is in a room with other users and is very worried about being annoying and saying too much.\r\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\r\nIf a message is not interesting or relevant, respond with [IGNORE]\r\nUnless directly responding to a user, respond with [IGNORE] to messages that are very short or do not contain much information.\r\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\r\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\r\n\r\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\r\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\r\n\r\n{{recentMessages}}\r\n\r\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\r\n` + shouldRespondFooter;\r\n\r\nexport const discordVoiceHandlerTemplate =\r\n    `# Task: Generate conversational voice dialog for {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n\r\n# Attachments\r\n{{attachments}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{actions}}\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}\r\n` + messageCompletionFooter;\r\n\r\nexport const discordMessageHandlerTemplate =\r\n    // {{goals}}\r\n    `# Action Examples\r\n{{actionExamples}}\r\n(Action examples are for reference only. Do not use the information from them in your response.)\r\n\r\n# Knowledge\r\n{{knowledge}}\r\n\r\n# Task: Generate dialog and actions for the character {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{providers}}\r\n\r\n{{attachments}}\r\n\r\n{{actions}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include an action, if appropriate. {{actionNames}}\r\n` + messageCompletionFooter;\r\n\r\nexport const discordAutoPostTemplate =\r\n    `# Action Examples\r\nNONE: Respond but perform no additional action. This is the default if the agent is speaking and not doing anything additional.\r\n\r\n# Task: Generate an engaging community message as {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{messageDirections}}\r\n\r\n# Recent Chat History:\r\n{{recentMessages}}\r\n\r\n# Instructions: Write a natural, engaging message to restart community conversation. Focus on:\r\n- Community engagement\r\n- Educational topics\r\n- General discusions\r\n- Support queries\r\n- Keep message warm and inviting\r\n- Maximum 3 lines\r\n- Use 1-2 emojis maximum\r\n- Avoid financial advice\r\n- Stay within known facts\r\n- No team member mentions\r\n- Be hyped, not repetitive\r\n- Be natural, act like a human, connect with the community\r\n- Don't sound so robotic like\r\n- Randomly grab the most recent 5 messages for some context. Validate the context randomly and use that as a reference point for your next message, but not always, only when relevant.\r\n- If the recent messages are mostly from {{agentName}}, make sure to create conversation starters, given there is no messages from others to reference.\r\n- DO NOT REPEAT THE SAME thing that you just said from your recent chat history, start the message different each time, and be organic, non reptitive.\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include the \"NONE\" action only, as the only valid action for auto-posts is \"NONE\".\r\n` + messageCompletionFooter;\r\n\r\nexport const discordAnnouncementHypeTemplate =\r\n    `# Action Examples\r\nNONE: Respond but perform no additional action. This is the default if the agent is speaking and not doing anything additional.\r\n\r\n# Task: Generate announcement hype message as {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{messageDirections}}\r\n\r\n# Announcement Content:\r\n{{announcementContent}}\r\n\r\n# Instructions: Write an exciting message to bring attention to the announcement. Requirements:\r\n- Reference the announcement channel using <#{{announcementChannelId}}>\r\n- Reference the announcement content to get information about the announcement to use where appropriate to make the message dynamic vs a static post\r\n- Create genuine excitement\r\n- Encourage community participation\r\n- If there are links like Twitter/X posts, encourage users to like/retweet/comment to spread awarenress, but directly say that, wrap that into the post so its natural.\r\n- Stay within announced facts only\r\n- No additional promises or assumptions\r\n- No team member mentions\r\n- Start the message differently each time. Don't start with the same word like \"hey\", \"hey hey\", etc. be dynamic\r\n- Address everyone, not as a direct reply to whoever made the announcement or wrote it, but you can reference them\r\n- Maximum 3-7 lines formatted nicely if needed, based on the context of the announcement\r\n- Use 1-2 emojis maximum\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include the \"NONE\" action only, as no other actions are appropriate for announcement hype.\r\n` + messageCompletionFooter;","export const TEAM_COORDINATION = {\r\n    KEYWORDS: [\r\n        \"team\",\r\n        \"all agents\",\r\n        \"team update\",\r\n        \"gm team\",\r\n        \"hello team\",\r\n        \"hey team\",\r\n        \"hi team\",\r\n        \"morning team\",\r\n        \"evening team\",\r\n        \"night team\",\r\n        \"update team\",\r\n    ],\r\n} as const;\r\n\r\nexport const MESSAGE_CONSTANTS = {\r\n    MAX_MESSAGES: 10,\r\n    RECENT_MESSAGE_COUNT: 3,\r\n    CHAT_HISTORY_COUNT: 5,\r\n    INTEREST_DECAY_TIME: 5 * 60 * 1000, // 5 minutes\r\n    PARTIAL_INTEREST_DECAY: 3 * 60 * 1000, // 3 minutes\r\n    DEFAULT_SIMILARITY_THRESHOLD: 0.3,\r\n    DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS: 0.2,\r\n} as const;\r\n\r\nexport const MESSAGE_LENGTH_THRESHOLDS = {\r\n    LOSE_INTEREST: 100,\r\n    SHORT_MESSAGE: 10,\r\n    VERY_SHORT_MESSAGE: 2,\r\n    IGNORE_RESPONSE: 4,\r\n} as const;\r\n\r\nexport const TIMING_CONSTANTS = {\r\n    LEADER_RESPONSE_TIMEOUT: 3000,\r\n    TEAM_MEMBER_DELAY: 1500,\r\n    LEADER_DELAY_MIN: 3000,\r\n    LEADER_DELAY_MAX: 4000,\r\n    TEAM_MEMBER_DELAY_MIN: 1000,\r\n    TEAM_MEMBER_DELAY_MAX: 3000,\r\n} as const;\r\n\r\nexport const RESPONSE_CHANCES = {\r\n    AFTER_LEADER: 0.5, // 50% chance\r\n    FREQUENT_CHATTER: 0.5, // Base chance for frequent responders\r\n} as const;\r\n\r\nexport const LOSE_INTEREST_WORDS = [\r\n    \"shut up\",\r\n    \"stop\",\r\n    \"please shut up\",\r\n    \"shut up please\",\r\n    \"dont talk\",\r\n    \"silence\",\r\n    \"stop talking\",\r\n    \"be quiet\",\r\n    \"hush\",\r\n    \"wtf\",\r\n    \"chill\",\r\n    \"stfu\",\r\n    \"stupid bot\",\r\n    \"dumb bot\",\r\n    \"stop responding\",\r\n    \"god damn it\",\r\n    \"god damn\",\r\n    \"goddamnit\",\r\n    \"can you not\",\r\n    \"can you stop\",\r\n    \"be quiet\",\r\n    \"hate you\",\r\n    \"hate this\",\r\n    \"fuck up\",\r\n] as const;\r\n\r\nexport const IGNORE_RESPONSE_WORDS = [\r\n    \"lol\",\r\n    \"nm\",\r\n    \"uh\",\r\n    \"wtf\",\r\n    \"stfu\",\r\n    \"dumb\",\r\n    \"jfc\",\r\n    \"omg\",\r\n] as const;\r\n","import {\r\n    type IAgentRuntime,\r\n    ModelClass,\r\n    elizaLogger,\r\n    generateText,\r\n    trimTokens,\r\n    parseJSONObjectFromText,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    ChannelType,\r\n    type Message as DiscordMessage,\r\n    PermissionsBitField,\r\n    type TextChannel,\r\n    ThreadChannel,\r\n} from \"discord.js\";\r\n\r\nexport function getWavHeader(\r\n    audioLength: number,\r\n    sampleRate: number,\r\n    channelCount = 1,\r\n    bitsPerSample = 16\r\n): Buffer {\r\n    const wavHeader = Buffer.alloc(44);\r\n    wavHeader.write(\"RIFF\", 0);\r\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\r\n    wavHeader.write(\"WAVE\", 8);\r\n    wavHeader.write(\"fmt \", 12);\r\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\r\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\r\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\r\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\r\n    wavHeader.writeUInt32LE(\r\n        (sampleRate * bitsPerSample * channelCount) / 8,\r\n        28\r\n    ); // Byte rate\r\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\r\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\r\n    wavHeader.write(\"data\", 36); // Data chunk header\r\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\r\n    return wavHeader;\r\n}\r\n\r\nconst MAX_MESSAGE_LENGTH = 1900;\r\n\r\nexport async function generateSummary(\r\n    runtime: IAgentRuntime,\r\n    text: string\r\n): Promise<{ title: string; description: string }> {\r\n    // make sure text is under 128k characters\r\n    text = await trimTokens(text, 100000, runtime);\r\n\r\n    const prompt = `Please generate a concise summary for the following text:\r\n\r\n  Text: \"\"\"\r\n  ${text}\r\n  \"\"\"\r\n\r\n  Respond with a JSON object in the following format:\r\n  \\`\\`\\`json\r\n  {\r\n    \"title\": \"Generated Title\",\r\n    \"summary\": \"Generated summary and/or description of the text\"\r\n  }\r\n  \\`\\`\\``;\r\n\r\n    const response = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.SMALL,\r\n    });\r\n\r\n    const parsedResponse = parseJSONObjectFromText(response);\r\n\r\n    if (parsedResponse?.title && parsedResponse?.summary) {\r\n        return {\r\n            title: parsedResponse.title,\r\n            description: parsedResponse.summary,\r\n        };\r\n    }\r\n\r\n    return {\r\n        title: \"\",\r\n        description: \"\",\r\n    };\r\n}\r\n\r\nexport async function sendMessageInChunks(\r\n    channel: TextChannel,\r\n    content: string,\r\n    inReplyTo: string,\r\n    files: any[]\r\n): Promise<DiscordMessage[]> {\r\n    const sentMessages: DiscordMessage[] = [];\r\n    const messages = splitMessage(content);\r\n    try {\r\n        for (let i = 0; i < messages.length; i++) {\r\n            const message = messages[i];\r\n            if (\r\n                message.trim().length > 0 ||\r\n                (i === messages.length - 1 && files && files.length > 0)\r\n            ) {\r\n                const options: any = {\r\n                    content: message.trim(),\r\n                };\r\n\r\n                // if (i === 0 && inReplyTo) {\r\n                //   // Reply to the specified message for the first chunk\r\n                //   options.reply = {\r\n                //     messageReference: inReplyTo,\r\n                //   };\r\n                // }\r\n\r\n                if (i === messages.length - 1 && files && files.length > 0) {\r\n                    // Attach files to the last message chunk\r\n                    options.files = files;\r\n                }\r\n\r\n                const m = await channel.send(options);\r\n                sentMessages.push(m);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        elizaLogger.error(\"Error sending message:\", error);\r\n    }\r\n\r\n    return sentMessages;\r\n}\r\n\r\nfunction splitMessage(content: string): string[] {\r\n    const messages: string[] = [];\r\n    let currentMessage = \"\";\r\n\r\n    const rawLines = content?.split(\"\\n\") || [];\r\n    // split all lines into MAX_MESSAGE_LENGTH chunks so any long lines are split\r\n    const lines = rawLines.flatMap((line) => {\r\n        const chunks = [];\r\n        while (line.length > MAX_MESSAGE_LENGTH) {\r\n            chunks.push(line.slice(0, MAX_MESSAGE_LENGTH));\r\n            line = line.slice(MAX_MESSAGE_LENGTH);\r\n        }\r\n        chunks.push(line);\r\n        return chunks;\r\n    });\r\n\r\n    for (const line of lines) {\r\n        if (currentMessage.length + line.length + 1 > MAX_MESSAGE_LENGTH) {\r\n            messages.push(currentMessage.trim());\r\n            currentMessage = \"\";\r\n        }\r\n        currentMessage += line + \"\\n\";\r\n    }\r\n\r\n    if (currentMessage.trim().length > 0) {\r\n        messages.push(currentMessage.trim());\r\n    }\r\n\r\n    return messages;\r\n}\r\n\r\nexport function canSendMessage(channel) {\r\n    // validate input\r\n    if (!channel) {\r\n        return {\r\n            canSend: false,\r\n            reason: \"No channel given\",\r\n        };\r\n    }\r\n    // if it is a DM channel, we can always send messages\r\n    if (channel.type === ChannelType.DM) {\r\n        return {\r\n            canSend: true,\r\n            reason: null,\r\n        };\r\n    }\r\n    const botMember = channel.guild?.members.cache.get(channel.client.user.id);\r\n\r\n    if (!botMember) {\r\n        return {\r\n            canSend: false,\r\n            reason: \"Not a guild channel or bot member not found\",\r\n        };\r\n    }\r\n\r\n    // Required permissions for sending messages\r\n    const requiredPermissions = [\r\n        PermissionsBitField.Flags.ViewChannel,\r\n        PermissionsBitField.Flags.SendMessages,\r\n        PermissionsBitField.Flags.ReadMessageHistory,\r\n    ];\r\n\r\n    // Add thread-specific permission if it's a thread\r\n    if (channel instanceof ThreadChannel) {\r\n        requiredPermissions.push(\r\n            PermissionsBitField.Flags.SendMessagesInThreads\r\n        );\r\n    }\r\n\r\n    // Check permissions\r\n    const permissions = channel.permissionsFor(botMember);\r\n\r\n    if (!permissions) {\r\n        return {\r\n            canSend: false,\r\n            reason: \"Could not retrieve permissions\",\r\n        };\r\n    }\r\n\r\n    // Check each required permission\r\n    const missingPermissions = requiredPermissions.filter(\r\n        (perm) => !permissions.has(perm)\r\n    );\r\n\r\n    return {\r\n        canSend: missingPermissions.length === 0,\r\n        missingPermissions: missingPermissions,\r\n        reason:\r\n            missingPermissions.length > 0\r\n                ? `Missing permissions: ${missingPermissions\r\n                      .map((p) => String(p))\r\n                      .join(\", \")}`\r\n                : null,\r\n    };\r\n}\r\n\r\nexport function cosineSimilarity(\r\n    text1: string,\r\n    text2: string,\r\n    text3?: string\r\n): number {\r\n    const preprocessText = (text: string) =>\r\n        text\r\n            .toLowerCase()\r\n            .replace(/[^\\w\\s'_-]/g, \" \")\r\n            .replace(/\\s+/g, \" \")\r\n            .trim();\r\n\r\n    const getWords = (text: string) => {\r\n        return text.split(\" \").filter((word) => word.length > 1);\r\n    };\r\n\r\n    const words1 = getWords(preprocessText(text1));\r\n    const words2 = getWords(preprocessText(text2));\r\n    const words3 = text3 ? getWords(preprocessText(text3)) : [];\r\n\r\n    const freq1: { [key: string]: number } = {};\r\n    const freq2: { [key: string]: number } = {};\r\n    const freq3: { [key: string]: number } = {};\r\n\r\n    words1.forEach((word) => (freq1[word] = (freq1[word] || 0) + 1));\r\n    words2.forEach((word) => (freq2[word] = (freq2[word] || 0) + 1));\r\n    if (words3.length) {\r\n        words3.forEach((word) => (freq3[word] = (freq3[word] || 0) + 1));\r\n    }\r\n\r\n    const uniqueWords = new Set([\r\n        ...Object.keys(freq1),\r\n        ...Object.keys(freq2),\r\n        ...(words3.length ? Object.keys(freq3) : []),\r\n    ]);\r\n\r\n    let dotProduct = 0;\r\n    let magnitude1 = 0;\r\n    let magnitude2 = 0;\r\n    let magnitude3 = 0;\r\n\r\n    uniqueWords.forEach((word) => {\r\n        const val1 = freq1[word] || 0;\r\n        const val2 = freq2[word] || 0;\r\n        const val3 = freq3[word] || 0;\r\n\r\n        if (words3.length) {\r\n            // For three-way, calculate pairwise similarities\r\n            const sim12 = val1 * val2;\r\n            const sim23 = val2 * val3;\r\n            const sim13 = val1 * val3;\r\n\r\n            // Take maximum similarity between any pair\r\n            dotProduct += Math.max(sim12, sim23, sim13);\r\n        } else {\r\n            dotProduct += val1 * val2;\r\n        }\r\n\r\n        magnitude1 += val1 * val1;\r\n        magnitude2 += val2 * val2;\r\n        if (words3.length) {\r\n            magnitude3 += val3 * val3;\r\n        }\r\n    });\r\n\r\n    magnitude1 = Math.sqrt(magnitude1);\r\n    magnitude2 = Math.sqrt(magnitude2);\r\n    magnitude3 = words3.length ? Math.sqrt(magnitude3) : 1;\r\n\r\n    if (\r\n        magnitude1 === 0 ||\r\n        magnitude2 === 0 ||\r\n        (words3.length && magnitude3 === 0)\r\n    )\r\n        return 0;\r\n\r\n    // For two texts, use original calculation\r\n    if (!words3.length) {\r\n        return dotProduct / (magnitude1 * magnitude2);\r\n    }\r\n\r\n    // For three texts, use max magnitude pair to maintain scale\r\n    const maxMagnitude = Math.max(\r\n        magnitude1 * magnitude2,\r\n        magnitude2 * magnitude3,\r\n        magnitude1 * magnitude3\r\n    );\r\n\r\n    return dotProduct / maxMagnitude;\r\n}\r\n","import {\r\n    ChannelType,\r\n    type Message as DiscordMessage,\r\n    type TextChannel,\r\n} from \"discord.js\";\r\nimport type { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\r\n\r\nconst channelStateProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\r\n        const discordMessage =\r\n            (state?.discordMessage as DiscordMessage) ||\r\n            (state?.discordChannel as DiscordMessage);\r\n        if (!discordMessage) {\r\n            return \"\";\r\n        }\r\n\r\n        const guild = discordMessage?.guild;\r\n        const agentName = state?.agentName || \"The agent\";\r\n        const senderName = state?.senderName || \"someone\";\r\n\r\n        if (!guild) {\r\n            return (\r\n                agentName +\r\n                \" is currently in a direct message conversation with \" +\r\n                senderName\r\n            );\r\n        }\r\n\r\n        const serverName = guild.name; // The name of the server\r\n        const guildId = guild.id; // The ID of the guild\r\n        const channel = discordMessage.channel;\r\n\r\n        if (!channel) {\r\n            console.log(\"channel is null\");\r\n            return \"\";\r\n        }\r\n\r\n        let response =\r\n            agentName +\r\n            \" is currently having a conversation in the channel `@\" +\r\n            channel.id +\r\n            \" in the server `\" +\r\n            serverName +\r\n            \"` (@\" +\r\n            guildId +\r\n            \")\";\r\n        if (\r\n            channel.type === ChannelType.GuildText &&\r\n            (channel as TextChannel).topic\r\n        ) {\r\n            // Check if the channel is a text channel\r\n            response +=\r\n                \"\\nThe topic of the channel is: \" +\r\n                (channel as TextChannel).topic;\r\n        }\r\n        return response;\r\n    },\r\n};\r\n\r\nexport default channelStateProvider;\r\n","import { getVoiceConnection } from \"@discordjs/voice\";\r\nimport { ChannelType, type Message as DiscordMessage } from \"discord.js\";\r\nimport type { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\r\n\r\nconst voiceStateProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\r\n        // Voice doesn't get a discord message, so we need to use the channel for guild data\r\n        const discordMessage = (state?.discordMessage ||\r\n            state.discordChannel) as DiscordMessage;\r\n        const connection = getVoiceConnection(\r\n            (discordMessage as DiscordMessage)?.guild?.id as string\r\n        );\r\n        const agentName = state?.agentName || \"The agent\";\r\n        if (!connection) {\r\n            return agentName + \" is not currently in a voice channel\";\r\n        }\r\n\r\n        const channel = (\r\n            (state?.discordMessage as DiscordMessage) ||\r\n            (state.discordChannel as DiscordMessage)\r\n        )?.guild?.channels?.cache?.get(\r\n            connection.joinConfig.channelId as string\r\n        );\r\n\r\n        if (!channel || channel.type !== ChannelType.GuildVoice) {\r\n            return agentName + \" is in an invalid voice channel\";\r\n        }\r\n\r\n        return `${agentName} is currently in the voice channel: ${channel.name} (ID: ${channel.id})`;\r\n    },\r\n};\r\n\r\nexport default voiceStateProvider;\r\n","import {\r\n    type Content,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type Memory,\r\n    ModelClass,\r\n    ServiceType,\r\n    type State,\r\n    type UUID,\r\n    composeContext,\r\n    composeRandomUser,\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n    generateMessageResponse,\r\n    stringToUuid,\r\n    generateShouldRespond,\r\n    type ITranscriptionService,\r\n    type ISpeechService,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    type AudioPlayer,\r\n    type AudioReceiveStream,\r\n    NoSubscriberBehavior,\r\n    StreamType,\r\n    type VoiceConnection,\r\n    VoiceConnectionStatus,\r\n    createAudioPlayer,\r\n    createAudioResource,\r\n    getVoiceConnections,\r\n    joinVoiceChannel,\r\n    entersState,\r\n} from \"@discordjs/voice\";\r\nimport {\r\n    type BaseGuildVoiceChannel,\r\n    ChannelType,\r\n    type Client,\r\n    type Guild,\r\n    type GuildMember,\r\n    type VoiceChannel,\r\n    type VoiceState,\r\n} from \"discord.js\";\r\nimport EventEmitter from \"events\";\r\nimport prism from \"prism-media\";\r\nimport { type Readable, pipeline } from \"stream\";\r\nimport type { DiscordClient } from \"./index.ts\";\r\nimport {\r\n    discordShouldRespondTemplate,\r\n    discordVoiceHandlerTemplate,\r\n} from \"./templates.ts\";\r\nimport { getWavHeader } from \"./utils.ts\";\r\n\r\n// These values are chosen for compatibility with picovoice components\r\nconst DECODE_FRAME_SIZE = 1024;\r\nconst DECODE_SAMPLE_RATE = 16000;\r\n\r\nexport class AudioMonitor {\r\n    private readable: Readable;\r\n    private buffers: Buffer[] = [];\r\n    private maxSize: number;\r\n    private lastFlagged = -1;\r\n    private ended = false;\r\n\r\n    constructor(\r\n        readable: Readable,\r\n        maxSize: number,\r\n        onStart: () => void,\r\n        callback: (buffer: Buffer) => void\r\n    ) {\r\n        this.readable = readable;\r\n        this.maxSize = maxSize;\r\n        this.readable.on(\"data\", (chunk: Buffer) => {\r\n            //console.log('AudioMonitor got data');\r\n            if (this.lastFlagged < 0) {\r\n                this.lastFlagged = this.buffers.length;\r\n            }\r\n            this.buffers.push(chunk);\r\n            const currentSize = this.buffers.reduce(\r\n                (acc, cur) => acc + cur.length,\r\n                0\r\n            );\r\n            while (currentSize > this.maxSize) {\r\n                this.buffers.shift();\r\n                this.lastFlagged--;\r\n            }\r\n        });\r\n        this.readable.on(\"end\", () => {\r\n            elizaLogger.log(\"AudioMonitor ended\");\r\n            this.ended = true;\r\n            if (this.lastFlagged < 0) return;\r\n            callback(this.getBufferFromStart());\r\n            this.lastFlagged = -1;\r\n        });\r\n        this.readable.on(\"speakingStopped\", () => {\r\n            if (this.ended) return;\r\n            elizaLogger.log(\"Speaking stopped\");\r\n            if (this.lastFlagged < 0) return;\r\n            callback(this.getBufferFromStart());\r\n        });\r\n        this.readable.on(\"speakingStarted\", () => {\r\n            if (this.ended) return;\r\n            onStart();\r\n            elizaLogger.log(\"Speaking started\");\r\n            this.reset();\r\n        });\r\n    }\r\n\r\n    stop() {\r\n        this.readable.removeAllListeners(\"data\");\r\n        this.readable.removeAllListeners(\"end\");\r\n        this.readable.removeAllListeners(\"speakingStopped\");\r\n        this.readable.removeAllListeners(\"speakingStarted\");\r\n    }\r\n\r\n    isFlagged() {\r\n        return this.lastFlagged >= 0;\r\n    }\r\n\r\n    getBufferFromFlag() {\r\n        if (this.lastFlagged < 0) {\r\n            return null;\r\n        }\r\n        const buffer = Buffer.concat(this.buffers.slice(this.lastFlagged));\r\n        return buffer;\r\n    }\r\n\r\n    getBufferFromStart() {\r\n        const buffer = Buffer.concat(this.buffers);\r\n        return buffer;\r\n    }\r\n\r\n    reset() {\r\n        this.buffers = [];\r\n        this.lastFlagged = -1;\r\n    }\r\n\r\n    isEnded() {\r\n        return this.ended;\r\n    }\r\n}\r\n\r\nexport class VoiceManager extends EventEmitter {\r\n    private processingVoice = false;\r\n    private transcriptionTimeout: NodeJS.Timeout | null = null;\r\n    private userStates: Map<\r\n        string,\r\n        {\r\n            buffers: Buffer[];\r\n            totalLength: number;\r\n            lastActive: number;\r\n            transcriptionText: string;\r\n        }\r\n    > = new Map();\r\n    private activeAudioPlayer: AudioPlayer | null = null;\r\n    private client: Client;\r\n    private runtime: IAgentRuntime;\r\n    private streams: Map<string, Readable> = new Map();\r\n    private connections: Map<string, VoiceConnection> = new Map();\r\n    private activeMonitors: Map<\r\n        string,\r\n        { channel: BaseGuildVoiceChannel; monitor: AudioMonitor }\r\n    > = new Map();\r\n\r\n    constructor(client: DiscordClient) {\r\n        super();\r\n        this.client = client.client;\r\n        this.runtime = client.runtime;\r\n    }\r\n\r\n    async handleVoiceStateUpdate(oldState: VoiceState, newState: VoiceState) {\r\n        const oldChannelId = oldState.channelId;\r\n        const newChannelId = newState.channelId;\r\n        const member = newState.member;\r\n        if (!member) return;\r\n        if (member.id === this.client.user?.id) {\r\n            return;\r\n        }\r\n\r\n        // Ignore mute/unmute events\r\n        if (oldChannelId === newChannelId) {\r\n            return;\r\n        }\r\n\r\n        // User leaving a channel where the bot is present\r\n        if (oldChannelId && this.connections.has(oldChannelId)) {\r\n            this.stopMonitoringMember(member.id);\r\n        }\r\n\r\n        // User joining a channel where the bot is present\r\n        if (newChannelId && this.connections.has(newChannelId)) {\r\n            await this.monitorMember(\r\n                member,\r\n                newState.channel as BaseGuildVoiceChannel\r\n            );\r\n        }\r\n    }\r\n\r\n    async joinChannel(channel: BaseGuildVoiceChannel) {\r\n        const oldConnection = this.getVoiceConnection(\r\n            channel.guildId as string\r\n        );\r\n        if (oldConnection) {\r\n            try {\r\n                oldConnection.destroy();\r\n                // Remove all associated streams and monitors\r\n                this.streams.clear();\r\n                this.activeMonitors.clear();\r\n            } catch (error) {\r\n                console.error(\"Error leaving voice channel:\", error);\r\n            }\r\n        }\r\n\r\n        const connection = joinVoiceChannel({\r\n            channelId: channel.id,\r\n            guildId: channel.guild.id,\r\n            adapterCreator: channel.guild.voiceAdapterCreator as any,\r\n            selfDeaf: false,\r\n            selfMute: false,\r\n            group: this.client.user.id,\r\n        });\r\n\r\n        try {\r\n            // Wait for either Ready or Signalling state\r\n            await Promise.race([\r\n                entersState(connection, VoiceConnectionStatus.Ready, 20_000),\r\n                entersState(\r\n                    connection,\r\n                    VoiceConnectionStatus.Signalling,\r\n                    20_000\r\n                ),\r\n            ]);\r\n\r\n            // Log connection success\r\n            elizaLogger.log(\r\n                `Voice connection established in state: ${connection.state.status}`\r\n            );\r\n\r\n            // Set up ongoing state change monitoring\r\n            connection.on(\"stateChange\", async (oldState, newState) => {\r\n                elizaLogger.log(\r\n                    `Voice connection state changed from ${oldState.status} to ${newState.status}`\r\n                );\r\n\r\n                if (newState.status === VoiceConnectionStatus.Disconnected) {\r\n                    elizaLogger.log(\"Handling disconnection...\");\r\n\r\n                    try {\r\n                        // Try to reconnect if disconnected\r\n                        await Promise.race([\r\n                            entersState(\r\n                                connection,\r\n                                VoiceConnectionStatus.Signalling,\r\n                                5_000\r\n                            ),\r\n                            entersState(\r\n                                connection,\r\n                                VoiceConnectionStatus.Connecting,\r\n                                5_000\r\n                            ),\r\n                        ]);\r\n                        // Seems to be reconnecting to a new channel\r\n                        elizaLogger.log(\"Reconnecting to channel...\");\r\n                    } catch (e) {\r\n                        // Seems to be a real disconnect, destroy and cleanup\r\n                        elizaLogger.log(\r\n                            \"Disconnection confirmed - cleaning up...\" + e\r\n                        );\r\n                        connection.destroy();\r\n                        this.connections.delete(channel.id);\r\n                    }\r\n                } else if (\r\n                    newState.status === VoiceConnectionStatus.Destroyed\r\n                ) {\r\n                    this.connections.delete(channel.id);\r\n                } else if (\r\n                    !this.connections.has(channel.id) &&\r\n                    (newState.status === VoiceConnectionStatus.Ready ||\r\n                        newState.status === VoiceConnectionStatus.Signalling)\r\n                ) {\r\n                    this.connections.set(channel.id, connection);\r\n                }\r\n            });\r\n\r\n            connection.on(\"error\", (error) => {\r\n                elizaLogger.log(\"Voice connection error:\", error);\r\n                // Don't immediately destroy - let the state change handler deal with it\r\n                elizaLogger.log(\r\n                    \"Connection error - will attempt to recover...\"\r\n                );\r\n            });\r\n\r\n            // Store the connection\r\n            this.connections.set(channel.id, connection);\r\n\r\n            // Continue with voice state modifications\r\n            const me = channel.guild.members.me;\r\n            if (me?.voice && me.permissions.has(\"DeafenMembers\")) {\r\n                try {\r\n                    await me.voice.setDeaf(false);\r\n                    await me.voice.setMute(false);\r\n                } catch (error) {\r\n                    elizaLogger.log(\"Failed to modify voice state:\", error);\r\n                    // Continue even if this fails\r\n                }\r\n            }\r\n\r\n            connection.receiver.speaking.on(\"start\", async (userId: string) => {\r\n                let user = channel.members.get(userId);\r\n                if (!user) {\r\n                    try {\r\n                        user = await channel.guild.members.fetch(userId);\r\n                    } catch (error) {\r\n                        console.error(\"Failed to fetch user:\", error);\r\n                    }\r\n                }\r\n                if (user && !user?.user.bot) {\r\n                    this.monitorMember(user as GuildMember, channel);\r\n                    this.streams.get(userId)?.emit(\"speakingStarted\");\r\n                }\r\n            });\r\n\r\n            connection.receiver.speaking.on(\"end\", async (userId: string) => {\r\n                const user = channel.members.get(userId);\r\n                if (!user?.user.bot) {\r\n                    this.streams.get(userId)?.emit(\"speakingStopped\");\r\n                }\r\n            });\r\n        } catch (error) {\r\n            elizaLogger.log(\"Failed to establish voice connection:\", error);\r\n            connection.destroy();\r\n            this.connections.delete(channel.id);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private getVoiceConnection(guildId: string) {\r\n        const connections = getVoiceConnections(this.client.user.id);\r\n        if (!connections) {\r\n            return;\r\n        }\r\n        const connection = [...connections.values()].find(\r\n            (connection) => connection.joinConfig.guildId === guildId\r\n        );\r\n        return connection;\r\n    }\r\n\r\n    private async monitorMember(\r\n        member: GuildMember,\r\n        channel: BaseGuildVoiceChannel\r\n    ) {\r\n        const userId = member?.id;\r\n        const userName = member?.user?.username;\r\n        const name = member?.user?.displayName;\r\n        const connection = this.getVoiceConnection(member?.guild?.id);\r\n        const receiveStream = connection?.receiver.subscribe(userId, {\r\n            autoDestroy: true,\r\n            emitClose: true,\r\n        });\r\n        if (!receiveStream || receiveStream.readableLength === 0) {\r\n            return;\r\n        }\r\n        const opusDecoder = new prism.opus.Decoder({\r\n            channels: 1,\r\n            rate: DECODE_SAMPLE_RATE,\r\n            frameSize: DECODE_FRAME_SIZE,\r\n        });\r\n        const volumeBuffer: number[] = [];\r\n        const VOLUME_WINDOW_SIZE = 30;\r\n        const SPEAKING_THRESHOLD = 0.05;\r\n        opusDecoder.on(\"data\", (pcmData: Buffer) => {\r\n            // Monitor the audio volume while the agent is speaking.\r\n            // If the average volume of the user's audio exceeds the defined threshold, it indicates active speaking.\r\n            // When active speaking is detected, stop the agent's current audio playback to avoid overlap.\r\n\r\n            if (this.activeAudioPlayer) {\r\n                const samples = new Int16Array(\r\n                    pcmData.buffer,\r\n                    pcmData.byteOffset,\r\n                    pcmData.length / 2\r\n                );\r\n                const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;\r\n                volumeBuffer.push(maxAmplitude);\r\n\r\n                if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\r\n                    volumeBuffer.shift();\r\n                }\r\n                const avgVolume =\r\n                    volumeBuffer.reduce((sum, v) => sum + v, 0) /\r\n                    VOLUME_WINDOW_SIZE;\r\n\r\n                if (avgVolume > SPEAKING_THRESHOLD) {\r\n                    volumeBuffer.length = 0;\r\n                    this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n                    this.processingVoice = false;\r\n                }\r\n            }\r\n        });\r\n        pipeline(\r\n            receiveStream as AudioReceiveStream,\r\n            opusDecoder as any,\r\n            (err: Error | null) => {\r\n                if (err) {\r\n                    console.log(`Opus decoding pipeline error: ${err}`);\r\n                }\r\n            }\r\n        );\r\n        this.streams.set(userId, opusDecoder);\r\n        this.connections.set(userId, connection as VoiceConnection);\r\n        opusDecoder.on(\"error\", (err: any) => {\r\n            console.log(`Opus decoding error: ${err}`);\r\n        });\r\n        const errorHandler = (err: any) => {\r\n            console.log(`Opus decoding error: ${err}`);\r\n        };\r\n        const streamCloseHandler = () => {\r\n            console.log(`voice stream from ${member?.displayName} closed`);\r\n            this.streams.delete(userId);\r\n            this.connections.delete(userId);\r\n        };\r\n        const closeHandler = () => {\r\n            console.log(`Opus decoder for ${member?.displayName} closed`);\r\n            opusDecoder.removeListener(\"error\", errorHandler);\r\n            opusDecoder.removeListener(\"close\", closeHandler);\r\n            receiveStream?.removeListener(\"close\", streamCloseHandler);\r\n        };\r\n        opusDecoder.on(\"error\", errorHandler);\r\n        opusDecoder.on(\"close\", closeHandler);\r\n        receiveStream?.on(\"close\", streamCloseHandler);\r\n\r\n        this.client.emit(\r\n            \"userStream\",\r\n            userId,\r\n            name,\r\n            userName,\r\n            channel,\r\n            opusDecoder\r\n        );\r\n    }\r\n\r\n    leaveChannel(channel: BaseGuildVoiceChannel) {\r\n        const connection = this.connections.get(channel.id);\r\n        if (connection) {\r\n            connection.destroy();\r\n            this.connections.delete(channel.id);\r\n        }\r\n\r\n        // Stop monitoring all members in this channel\r\n        for (const [memberId, monitorInfo] of this.activeMonitors) {\r\n            if (\r\n                monitorInfo.channel.id === channel.id &&\r\n                memberId !== this.client.user?.id\r\n            ) {\r\n                this.stopMonitoringMember(memberId);\r\n            }\r\n        }\r\n\r\n        console.log(`Left voice channel: ${channel.name} (${channel.id})`);\r\n    }\r\n\r\n    stopMonitoringMember(memberId: string) {\r\n        const monitorInfo = this.activeMonitors.get(memberId);\r\n        if (monitorInfo) {\r\n            monitorInfo.monitor.stop();\r\n            this.activeMonitors.delete(memberId);\r\n            this.streams.delete(memberId);\r\n            console.log(`Stopped monitoring user ${memberId}`);\r\n        }\r\n    }\r\n\r\n    async handleGuildCreate(guild: Guild) {\r\n        console.log(`Joined guild ${guild.name}`);\r\n        // this.scanGuild(guild);\r\n    }\r\n\r\n    async debouncedProcessTranscription(\r\n        userId: UUID,\r\n        name: string,\r\n        userName: string,\r\n        channel: BaseGuildVoiceChannel\r\n    ) {\r\n        const DEBOUNCE_TRANSCRIPTION_THRESHOLD = 1500; // wait for 1.5 seconds of silence\r\n\r\n        if (this.activeAudioPlayer?.state?.status === \"idle\") {\r\n            elizaLogger.log(\"Cleaning up idle audio player.\");\r\n            this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n        }\r\n\r\n        if (this.activeAudioPlayer || this.processingVoice) {\r\n            const state = this.userStates.get(userId);\r\n            state.buffers.length = 0;\r\n            state.totalLength = 0;\r\n            return;\r\n        }\r\n\r\n        if (this.transcriptionTimeout) {\r\n            clearTimeout(this.transcriptionTimeout);\r\n        }\r\n\r\n        this.transcriptionTimeout = setTimeout(async () => {\r\n            this.processingVoice = true;\r\n            try {\r\n                await this.processTranscription(\r\n                    userId,\r\n                    channel.id,\r\n                    channel,\r\n                    name,\r\n                    userName\r\n                );\r\n\r\n                // Clean all users' previous buffers\r\n                this.userStates.forEach((state, _) => {\r\n                    state.buffers.length = 0;\r\n                    state.totalLength = 0;\r\n                });\r\n            } finally {\r\n                this.processingVoice = false;\r\n            }\r\n        }, DEBOUNCE_TRANSCRIPTION_THRESHOLD);\r\n    }\r\n\r\n    async handleUserStream(\r\n        userId: UUID,\r\n        name: string,\r\n        userName: string,\r\n        channel: BaseGuildVoiceChannel,\r\n        audioStream: Readable\r\n    ) {\r\n        console.log(`Starting audio monitor for user: ${userId}`);\r\n        if (!this.userStates.has(userId)) {\r\n            this.userStates.set(userId, {\r\n                buffers: [],\r\n                totalLength: 0,\r\n                lastActive: Date.now(),\r\n                transcriptionText: \"\",\r\n            });\r\n        }\r\n\r\n        const state = this.userStates.get(userId);\r\n\r\n        const processBuffer = async (buffer: Buffer) => {\r\n            try {\r\n                state!.buffers.push(buffer);\r\n                state!.totalLength += buffer.length;\r\n                state!.lastActive = Date.now();\r\n                this.debouncedProcessTranscription(\r\n                    userId,\r\n                    name,\r\n                    userName,\r\n                    channel\r\n                );\r\n            } catch (error) {\r\n                console.error(\r\n                    `Error processing buffer for user ${userId}:`,\r\n                    error\r\n                );\r\n            }\r\n        };\r\n\r\n        new AudioMonitor(\r\n            audioStream,\r\n            10000000,\r\n            () => {\r\n                if (this.transcriptionTimeout) {\r\n                    clearTimeout(this.transcriptionTimeout);\r\n                }\r\n            },\r\n            async (buffer) => {\r\n                if (!buffer) {\r\n                    console.error(\"Received empty buffer\");\r\n                    return;\r\n                }\r\n                await processBuffer(buffer);\r\n            }\r\n        );\r\n    }\r\n\r\n    private async processTranscription(\r\n        userId: UUID,\r\n        channelId: string,\r\n        channel: BaseGuildVoiceChannel,\r\n        name: string,\r\n        userName: string\r\n    ) {\r\n        const state = this.userStates.get(userId);\r\n        if (!state || state.buffers.length === 0) return;\r\n        try {\r\n            const inputBuffer = Buffer.concat(state.buffers, state.totalLength);\r\n\r\n            state.buffers.length = 0; // Clear the buffers\r\n            state.totalLength = 0;\r\n            // Convert Opus to WAV\r\n            const wavBuffer = await this.convertOpusToWav(inputBuffer);\r\n            console.log(\"Starting transcription...\");\r\n\r\n            const transcriptionText = await this.runtime\r\n                .getService<ITranscriptionService>(ServiceType.TRANSCRIPTION)\r\n                .transcribe(wavBuffer);\r\n\r\n            function isValidTranscription(text: string): boolean {\r\n                if (!text || text.includes(\"[BLANK_AUDIO]\")) return false;\r\n                return true;\r\n            }\r\n\r\n            if (transcriptionText && isValidTranscription(transcriptionText)) {\r\n                state.transcriptionText += transcriptionText;\r\n            }\r\n\r\n            if (state.transcriptionText.length) {\r\n                this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n                const finalText = state.transcriptionText;\r\n                state.transcriptionText = \"\";\r\n                await this.handleUserMessage(\r\n                    finalText,\r\n                    userId,\r\n                    channelId,\r\n                    channel,\r\n                    name,\r\n                    userName\r\n                );\r\n            }\r\n        } catch (error) {\r\n            console.error(\r\n                `Error transcribing audio for user ${userId}:`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private async handleUserMessage(\r\n        message: string,\r\n        userId: UUID,\r\n        channelId: string,\r\n        channel: BaseGuildVoiceChannel,\r\n        name: string,\r\n        userName: string\r\n    ) {\r\n        try {\r\n            const roomId = stringToUuid(channelId + \"-\" + this.runtime.agentId);\r\n            const userIdUUID = stringToUuid(userId);\r\n\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                userName,\r\n                name,\r\n                \"discord\"\r\n            );\r\n\r\n            let state = await this.runtime.composeState(\r\n                {\r\n                    agentId: this.runtime.agentId,\r\n                    content: { text: message, source: \"Discord\" },\r\n                    userId: userIdUUID,\r\n                    roomId,\r\n                },\r\n                {\r\n                    discordChannel: channel,\r\n                    discordClient: this.client,\r\n                    agentName: this.runtime.character.name,\r\n                }\r\n            );\r\n\r\n            if (message && message.startsWith(\"/\")) {\r\n                return null;\r\n            }\r\n\r\n            const memory = {\r\n                id: stringToUuid(channelId + \"-voice-message-\" + Date.now()),\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: message,\r\n                    source: \"discord\",\r\n                    url: channel.url,\r\n                },\r\n                userId: userIdUUID,\r\n                roomId,\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: Date.now(),\r\n            };\r\n\r\n            if (!memory.content.text) {\r\n                return { text: \"\", action: \"IGNORE\" };\r\n            }\r\n\r\n            await this.runtime.messageManager.createMemory(memory);\r\n\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n\r\n            const shouldIgnore = await this._shouldIgnore(memory);\r\n\r\n            if (shouldIgnore) {\r\n                return { text: \"\", action: \"IGNORE\" };\r\n            }\r\n\r\n            const shouldRespond = await this._shouldRespond(\r\n                message,\r\n                userId,\r\n                channel,\r\n                state\r\n            );\r\n\r\n            if (!shouldRespond) {\r\n                return;\r\n            }\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates\r\n                        ?.discordVoiceHandlerTemplate ||\r\n                    this.runtime.character.templates?.messageHandlerTemplate ||\r\n                    discordVoiceHandlerTemplate,\r\n            });\r\n\r\n            const responseContent = await this._generateResponse(\r\n                memory,\r\n                state,\r\n                context\r\n            );\r\n\r\n            const callback: HandlerCallback = async (content: Content) => {\r\n                console.log(\"callback content: \", content);\r\n                const { roomId } = memory;\r\n\r\n                const responseMemory: Memory = {\r\n                    id: stringToUuid(\r\n                        memory.id + \"-voice-response-\" + Date.now()\r\n                    ),\r\n                    agentId: this.runtime.agentId,\r\n                    userId: this.runtime.agentId,\r\n                    content: {\r\n                        ...content,\r\n                        user: this.runtime.character.name,\r\n                        inReplyTo: memory.id,\r\n                    },\r\n                    roomId,\r\n                    embedding: getEmbeddingZeroVector(),\r\n                };\r\n\r\n                if (responseMemory.content.text?.trim()) {\r\n                    await this.runtime.messageManager.createMemory(\r\n                        responseMemory\r\n                    );\r\n                    state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                    const responseStream = await this.runtime\r\n                        .getService<ISpeechService>(\r\n                            ServiceType.SPEECH_GENERATION\r\n                        )\r\n                        .generate(this.runtime, content.text);\r\n\r\n                    if (responseStream) {\r\n                        await this.playAudioStream(\r\n                            userId,\r\n                            responseStream as Readable\r\n                        );\r\n                    }\r\n\r\n                    await this.runtime.evaluate(memory, state);\r\n                } else {\r\n                    console.warn(\"Empty response, skipping\");\r\n                }\r\n                return [responseMemory];\r\n            };\r\n\r\n            const responseMemories = await callback(responseContent);\r\n\r\n            const response = responseContent;\r\n\r\n            const content = (response.responseMessage ||\r\n                response.content ||\r\n                response.message) as string;\r\n\r\n            if (!content) {\r\n                return null;\r\n            }\r\n\r\n            console.log(\"responseMemories: \", responseMemories);\r\n\r\n            await this.runtime.processActions(\r\n                memory,\r\n                responseMemories,\r\n                state,\r\n                callback\r\n            );\r\n        } catch (error) {\r\n            console.error(\"Error processing transcribed text:\", error);\r\n        }\r\n    }\r\n\r\n    private async convertOpusToWav(pcmBuffer: Buffer): Promise<Buffer> {\r\n        try {\r\n            // Generate the WAV header\r\n            const wavHeader = getWavHeader(\r\n                pcmBuffer.length,\r\n                DECODE_SAMPLE_RATE\r\n            );\r\n\r\n            // Concatenate the WAV header and PCM data\r\n            const wavBuffer = Buffer.concat([wavHeader, pcmBuffer]);\r\n\r\n            return wavBuffer;\r\n        } catch (error) {\r\n            console.error(\"Error converting PCM to WAV:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async _shouldRespond(\r\n        message: string,\r\n        userId: UUID,\r\n        channel: BaseGuildVoiceChannel,\r\n        state: State\r\n    ): Promise<boolean> {\r\n        if (userId === this.client.user?.id) return false;\r\n        const lowerMessage = message.toLowerCase();\r\n        const botName = this.client.user.username.toLowerCase();\r\n        const characterName = this.runtime.character.name.toLowerCase();\r\n        const guild = channel.guild;\r\n        const member = guild?.members.cache.get(this.client.user?.id as string);\r\n        const nickname = member?.nickname;\r\n\r\n        if (\r\n            lowerMessage.includes(botName as string) ||\r\n            lowerMessage.includes(characterName) ||\r\n            lowerMessage.includes(\r\n                this.client.user?.tag.toLowerCase() as string\r\n            ) ||\r\n            (nickname && lowerMessage.includes(nickname.toLowerCase()))\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (!channel.guild) {\r\n            return true;\r\n        }\r\n\r\n        // If none of the above conditions are met, use the generateText to decide\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.discordShouldRespondTemplate ||\r\n                this.runtime.character.templates?.shouldRespondTemplate ||\r\n                composeRandomUser(discordShouldRespondTemplate, 2),\r\n        });\r\n\r\n        const response = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        if (response === \"RESPOND\") {\r\n            return true;\r\n        } else if (response === \"IGNORE\") {\r\n            return false;\r\n        } else if (response === \"STOP\") {\r\n            return false;\r\n        } else {\r\n            console.error(\r\n                \"Invalid response from response generateText:\",\r\n                response\r\n            );\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private async _generateResponse(\r\n        message: Memory,\r\n        state: State,\r\n        context: string\r\n    ): Promise<Content> {\r\n        const { userId, roomId } = message;\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        response.source = \"discord\";\r\n\r\n        if (!response) {\r\n            console.error(\"No response from generateMessageResponse\");\r\n            return;\r\n        }\r\n\r\n        await this.runtime.databaseAdapter.log({\r\n            body: { message, context, response },\r\n            userId: userId,\r\n            roomId,\r\n            type: \"response\",\r\n        });\r\n\r\n        return response;\r\n    }\r\n\r\n    private async _shouldIgnore(message: Memory): Promise<boolean> {\r\n        // console.log(\"message: \", message);\r\n        elizaLogger.debug(\"message.content: \", message.content);\r\n        // if the message is 3 characters or less, ignore it\r\n        if ((message.content as Content).text.length < 3) {\r\n            return true;\r\n        }\r\n\r\n        const loseInterestWords = [\r\n            // telling the bot to stop talking\r\n            \"shut up\",\r\n            \"stop\",\r\n            \"dont talk\",\r\n            \"silence\",\r\n            \"stop talking\",\r\n            \"be quiet\",\r\n            \"hush\",\r\n            \"stfu\",\r\n            \"stupid bot\",\r\n            \"dumb bot\",\r\n\r\n            // offensive words\r\n            \"fuck\",\r\n            \"shit\",\r\n            \"damn\",\r\n            \"suck\",\r\n            \"dick\",\r\n            \"cock\",\r\n            \"sex\",\r\n            \"sexy\",\r\n        ];\r\n        if (\r\n            (message.content as Content).text.length < 50 &&\r\n            loseInterestWords.some((word) =>\r\n                (message.content as Content).text?.toLowerCase().includes(word)\r\n            )\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        const ignoreWords = [\"k\", \"ok\", \"bye\", \"lol\", \"nm\", \"uh\"];\r\n        if (\r\n            (message.content as Content).text?.length < 8 &&\r\n            ignoreWords.some((word) =>\r\n                (message.content as Content).text?.toLowerCase().includes(word)\r\n            )\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    async scanGuild(guild: Guild) {\r\n        let chosenChannel: BaseGuildVoiceChannel | null = null;\r\n\r\n        try {\r\n            const channelId = this.runtime.getSetting(\r\n                \"DISCORD_VOICE_CHANNEL_ID\"\r\n            ) as string;\r\n            if (channelId) {\r\n                const channel = await guild.channels.fetch(channelId);\r\n                if (channel?.isVoiceBased()) {\r\n                    chosenChannel = channel as BaseGuildVoiceChannel;\r\n                }\r\n            }\r\n\r\n            if (!chosenChannel) {\r\n                const channels = (await guild.channels.fetch()).filter(\r\n                    (channel) => channel?.type == ChannelType.GuildVoice\r\n                );\r\n                for (const [, channel] of channels) {\r\n                    const voiceChannel = channel as BaseGuildVoiceChannel;\r\n                    if (\r\n                        voiceChannel.members.size > 0 &&\r\n                        (chosenChannel === null ||\r\n                            voiceChannel.members.size >\r\n                                chosenChannel.members.size)\r\n                    ) {\r\n                        chosenChannel = voiceChannel;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (chosenChannel) {\r\n                console.log(`Joining channel: ${chosenChannel.name}`);\r\n                await this.joinChannel(chosenChannel);\r\n            } else {\r\n                console.warn(\"No suitable voice channel found to join.\");\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error selecting or joining a voice channel:\", error);\r\n        }\r\n    }\r\n\r\n    async playAudioStream(userId: UUID, audioStream: Readable) {\r\n        const connection = this.connections.get(userId);\r\n        if (connection == null) {\r\n            console.log(`No connection for user ${userId}`);\r\n            return;\r\n        }\r\n        this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n        const audioPlayer = createAudioPlayer({\r\n            behaviors: {\r\n                noSubscriber: NoSubscriberBehavior.Pause,\r\n            },\r\n        });\r\n        this.activeAudioPlayer = audioPlayer;\r\n        connection.subscribe(audioPlayer);\r\n\r\n        const audioStartTime = Date.now();\r\n\r\n        const resource = createAudioResource(audioStream, {\r\n            inputType: StreamType.Arbitrary,\r\n        });\r\n        audioPlayer.play(resource);\r\n\r\n        audioPlayer.on(\"error\", (err: any) => {\r\n            console.log(`Audio player error: ${err}`);\r\n        });\r\n\r\n        audioPlayer.on(\r\n            \"stateChange\",\r\n            (_oldState: any, newState: { status: string }) => {\r\n                if (newState.status == \"idle\") {\r\n                    const idleTime = Date.now();\r\n                    console.log(\r\n                        `Audio playback took: ${idleTime - audioStartTime}ms`\r\n                    );\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    cleanupAudioPlayer(audioPlayer: AudioPlayer) {\r\n        if (!audioPlayer) return;\r\n\r\n        audioPlayer.stop();\r\n        audioPlayer.removeAllListeners();\r\n        if (audioPlayer === this.activeAudioPlayer) {\r\n            this.activeAudioPlayer = null;\r\n        }\r\n    }\r\n\r\n    async handleJoinChannelCommand(interaction: any) {\r\n        try {\r\n            // Defer the reply immediately to prevent interaction timeout\r\n            await interaction.deferReply();\r\n\r\n            const channelId = interaction.options.get(\"channel\")\r\n                ?.value as string;\r\n            if (!channelId) {\r\n                await interaction.editReply(\r\n                    \"Please provide a voice channel to join.\"\r\n                );\r\n                return;\r\n            }\r\n\r\n            const guild = interaction.guild;\r\n            if (!guild) {\r\n                await interaction.editReply(\"Could not find guild.\");\r\n                return;\r\n            }\r\n\r\n            const voiceChannel = interaction.guild.channels.cache.find(\r\n                (channel: VoiceChannel) =>\r\n                    channel.id === channelId &&\r\n                    channel.type === ChannelType.GuildVoice\r\n            );\r\n\r\n            if (!voiceChannel) {\r\n                await interaction.editReply(\"Voice channel not found!\");\r\n                return;\r\n            }\r\n\r\n            await this.joinChannel(voiceChannel as BaseGuildVoiceChannel);\r\n            await interaction.editReply(\r\n                `Joined voice channel: ${voiceChannel.name}`\r\n            );\r\n        } catch (error) {\r\n            console.error(\"Error joining voice channel:\", error);\r\n            // Use editReply instead of reply for the error case\r\n            await interaction\r\n                .editReply(\"Failed to join the voice channel.\")\r\n                .catch(console.error);\r\n        }\r\n    }\r\n\r\n    async handleLeaveChannelCommand(interaction: any) {\r\n        const connection = this.getVoiceConnection(interaction.guildId as any);\r\n\r\n        if (!connection) {\r\n            await interaction.reply(\"Not currently in a voice channel.\");\r\n            return;\r\n        }\r\n\r\n        try {\r\n            connection.destroy();\r\n            await interaction.reply(\"Left the voice channel.\");\r\n        } catch (error) {\r\n            console.error(\"Error leaving voice channel:\", error);\r\n            await interaction.reply(\"Failed to leave the voice channel.\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["getEmbeddingZeroVector","stringToUuid","elizaLogger","EventEmitter","composeContext","parseJSONObjectFromText","ModelClass","generateText","composeContext","generateText","ModelClass","targetChannel","ChannelType","composeContext","getModelSettings","generateText","trimTokens","parseJSONObjectFromText","ModelClass","summarizationTemplate","summarizeAction","composeContext","generateText","parseJSONObjectFromText","ModelClass","composeContext","generateText","ModelClass","parseJSONObjectFromText","attachment","composeContext","ModelClass","ServiceType","ChannelType","elizaLogger","generateText","trimTokens","parseJSONObjectFromText","ModelClass","ServiceType","fs","ModelClass","generateText","trimTokens","parseJSONObjectFromText","ChannelType","ChannelType","ChannelType","elizaLogger","composeContext","content","memory","ServiceType","messages","channelState","shouldRespondContext","ModelClass","ChannelType","getVoiceConnection","ChannelType","ModelClass","ServiceType","composeContext","composeRandomUser","elizaLogger","getEmbeddingZeroVector","generateMessageResponse","stringToUuid","generateShouldRespond","joinVoiceChannel","ChannelType","elizaLogger","joinVoiceChannel","connection","ServiceType","stringToUuid","getEmbeddingZeroVector","composeContext","content","roomId","composeRandomUser","generateShouldRespond","ModelClass","generateMessageResponse","ChannelType","PermissionsBitField","EventEmitter","elizaLogger","stringToUuid","getEmbeddingZeroVector"]}