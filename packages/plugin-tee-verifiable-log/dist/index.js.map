{"version":3,"sources":["../src/index.ts","../src/providers/verifiableLogProvider.ts","../src/adapters/sqliteVerifiableDAO.ts","../src/types/logTypes.ts","../src/providers/dreriveProvider.ts"],"sourcesContent":["import { type IAgentRuntime, type Plugin, Service, ServiceType } from \"@elizaos/core\";\r\nimport { VerifiableLogProvider } from \"./providers/verifiableLogProvider.ts\";\r\nimport { SQLite3VerifiableDAO } from \"./adapters/sqliteVerifiableDAO.ts\";\r\nimport {\r\n    PageQuery,\r\n    VerifiableAgent,\r\n    type VerifiableDAO,\r\n    VerifiableLog,\r\n    VerifiableLogQuery,\r\n} from \"./types/logTypes.ts\";\r\n\r\nexport { PageQuery, VerifiableAgent, VerifiableLog, VerifiableLogQuery };\r\nexport { DeriveProvider } from \"./providers/dreriveProvider.ts\"\r\n\r\nexport class VerifiableLogService extends Service {\r\n    getInstance(): VerifiableLogService {\r\n        return this;\r\n    }\r\n\r\n    static get serviceType(): ServiceType {\r\n        return ServiceType.VERIFIABLE_LOGGING;\r\n    }\r\n\r\n    private verifiableLogProvider: VerifiableLogProvider;\r\n    private verifiableDAO: VerifiableDAO;\r\n\r\n    private teeMode: string;\r\n    private vlogOpen = false;\r\n\r\n    // Add abstract initialize method that must be implemented by derived classes\r\n    async initialize(runtime: IAgentRuntime): Promise<void> {\r\n        if (runtime.databaseAdapter.db === null) {\r\n            throw new Error(\"Database adapter is not initialized.\");\r\n        }\r\n        if (runtime.getSetting(\"TEE_MODE\") === null) {\r\n            throw new Error(\"TEE_MODE is not set.\");\r\n        }\r\n        if (runtime.getSetting(\"WALLET_SECRET_SALT\") === null) {\r\n            throw new Error(\"WALLET_SECRET_SALT is not set.\");\r\n        }\r\n        this.teeMode = runtime.getSetting(\"TEE_MODE\");\r\n        const value = runtime.getSetting(\"VLOG\");\r\n        const truthyValues = [\"yes\", \"true\", \"YES\", \"TRUE\", \"Yes\", \"True\", \"1\"];\r\n        this.vlogOpen = truthyValues.includes(value.toLowerCase());\r\n        this.verifiableDAO = new SQLite3VerifiableDAO(\r\n            runtime.databaseAdapter.db\r\n        );\r\n        this.verifiableLogProvider = new VerifiableLogProvider(\r\n            this.verifiableDAO,\r\n            this.teeMode\r\n        );\r\n        const isOK = await this.verifiableLogProvider.registerAgent(\r\n            { agentId: runtime?.agentId, agentName: runtime?.character?.name },\r\n            this.teeMode\r\n        );\r\n        if (!isOK) {\r\n            throw new Error(`Failed to register agent.${runtime.agentId}`);\r\n        }\r\n        return;\r\n    }\r\n\r\n    async log(params: {\r\n        agentId: string;\r\n        roomId: string;\r\n        userId: string;\r\n        type: string;\r\n        content: string;\r\n    }): Promise<boolean> {\r\n        if (this.vlogOpen) {\r\n            return this.verifiableLogProvider.log(params, this.teeMode);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    async generateAttestation(params: {\r\n        agentId: string;\r\n        publicKey: string;\r\n    }): Promise<string> {\r\n        if (this.vlogOpen) {\r\n            return this.verifiableLogProvider.generateAttestation(\r\n                params,\r\n            );\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    async listAgent(): Promise<VerifiableAgent[]> {\r\n        return this.verifiableDAO.listAgent();\r\n    }\r\n\r\n    async pageQueryLogs(\r\n        query: VerifiableLogQuery,\r\n        page: number,\r\n        pageSize: number\r\n    ): Promise<PageQuery<VerifiableLog[]>> {\r\n        return this.verifiableDAO.pageQueryLogs(query, page, pageSize);\r\n    }\r\n}\r\n\r\nexport const verifiableLogPlugin: Plugin = {\r\n    name: \"TeeVerifiableLog\",\r\n    description:\r\n        \"While Eliza operates within the TEE, it uses a derived key pair to sign its actions, ensuring that these actions are definitively executed by Eliza. Third-party users can remotely verify Eliza's public key to validate these actions\",\r\n    actions: [],\r\n    evaluators: [],\r\n    providers: [],\r\n    services: [new VerifiableLogService()],\r\n};\r\n","import { elizaLogger } from \"@elizaos/core\";\r\nimport type {\r\n    IVerifiableLogProvider,\r\n    VerifiableAgent,\r\n    VerifiableDAO,\r\n    VerifiableLog,\r\n} from \"../types/logTypes.ts\";\r\nimport {\r\n    DeriveKeyProvider,\r\n    RemoteAttestationProvider,\r\n    type RemoteAttestationQuote,\r\n} from \"@elizaos/plugin-tee\";\r\n\r\nexport class VerifiableLogProvider implements IVerifiableLogProvider {\r\n    private dao: VerifiableDAO;\r\n    private keyPath = \"/keys/verifiable_key\";\r\n    private remoteAttestationProvider: RemoteAttestationProvider;\r\n    private provider: DeriveKeyProvider;\r\n\r\n    constructor(dao: VerifiableDAO, teeMode: string) {\r\n        this.dao = dao;\r\n        this.remoteAttestationProvider = new RemoteAttestationProvider(teeMode);\r\n        this.provider = new DeriveKeyProvider(teeMode);\r\n    }\r\n\r\n    async log(\r\n        params: {\r\n            agentId: string;\r\n            roomId: string;\r\n            userId: string;\r\n            type: string;\r\n            content: string;\r\n        },\r\n        subject: string\r\n    ): Promise<boolean> {\r\n        let singed = \"\";\r\n\r\n        try {\r\n            const evmKeypair = await this.provider.deriveEcdsaKeypair(\r\n                this.keyPath,\r\n                subject,\r\n                params.agentId\r\n            );\r\n            const signature = await evmKeypair.keypair.signMessage({\r\n                message: params.content,\r\n            });\r\n            singed = signature.toString();\r\n\r\n            // evmKeypair can now be used for Ethereum operations\r\n        } catch (error) {\r\n            elizaLogger.error(\"EVM key derivation failed:\", error)\r\n            return false;\r\n        }\r\n        return this.dao.addLog(<VerifiableLog>{\r\n            agent_id: params.agentId,\r\n            room_id: params.roomId,\r\n            user_id: params.userId,\r\n            type: params.type,\r\n            content: params.content,\r\n            signature: singed,\r\n        });\r\n    }\r\n\r\n    async registerAgent(\r\n        params: {\r\n            agentId: string;\r\n            agentName: string;\r\n        },\r\n        subject: string\r\n    ): Promise<boolean> {\r\n        if (params.agentId === undefined) {\r\n            throw new Error(\"agentId is required\");\r\n        }\r\n\r\n        const agent = await this.dao.getAgent(params.agentId);\r\n        if (agent !== null) {\r\n            return true;\r\n        }\r\n        const evmKeypair = await this.provider.deriveEcdsaKeypair(\r\n            this.keyPath,\r\n            subject,\r\n            params.agentId\r\n        );\r\n\r\n        const publicKey = evmKeypair.keypair.publicKey;\r\n\r\n        return this.dao.addAgent(<VerifiableAgent>{\r\n            agent_id: params.agentId,\r\n            agent_name: params.agentName,\r\n            agent_keypair_path: this.keyPath,\r\n            agent_keypair_vlog_pk: publicKey,\r\n        });\r\n    }\r\n\r\n    async generateAttestation(\r\n        params: {\r\n            agentId: string;\r\n            publicKey: string;\r\n        }\r\n    ): Promise<string> {\r\n        if (params.agentId === undefined || params.publicKey === undefined) {\r\n            throw new Error(\"agentId and publicKey are required\");\r\n        }\r\n        try {\r\n            // Generate 32-byte report data (reportData) containing the hash value of the public key.\r\n            const reportData = JSON.stringify(params);\r\n            // Call the remote attestation interface.\r\n            const quote: RemoteAttestationQuote = await this.remoteAttestationProvider.generateAttestation(reportData);\r\n            return JSON.stringify(quote);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Failed to generate attestation quote:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","import type { Database } from \"better-sqlite3\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport {\r\n    type VerifiableLog,\r\n    type VerifiableAgent,\r\n    VerifiableDAO,\r\n    type VerifiableLogQuery,\r\n    type PageQuery,\r\n} from \"../types/logTypes.ts\";\r\n\r\nexport class SQLite3VerifiableDAO extends VerifiableDAO<Database> {\r\n    constructor(db: Database) {\r\n        super();\r\n        this.db = db;\r\n        // load(db);\r\n        // check if the tables exist, if not create them\r\n        const tables = db\r\n            .prepare(\r\n                \"SELECT name FROM sqlite_master WHERE type='table' AND name IN ('verifiable-logs', 'verifiable-agents');\"\r\n            )\r\n            .all();\r\n        if (tables.length !== 2) {\r\n            this.initializeSchema();\r\n        }\r\n    }\r\n\r\n    async initializeSchema(): Promise<void> {\r\n        this.db.exec(`\r\n            CREATE TABLE IF NOT EXISTS \"tee_verifiable_logs\"\r\n            (\r\n                \"id\"         TEXT PRIMARY KEY,\r\n                \"created_at\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                \"agent_id\"   TEXT NOT NULL,\r\n                \"room_id\"    TEXT NOT NULL,\r\n                \"user_id\"    TEXT,\r\n                \"type\"       TEXT,\r\n                \"content\"    TEXT NOT NULL,\r\n                \"signature\"  TEXT NOT NULL\r\n            );\r\n        `);\r\n\r\n        this.db.exec(`\r\n            CREATE TABLE IF NOT EXISTS \"tee_verifiable_agents\"\r\n            (\r\n                \"id\"                    TEXT PRIMARY KEY,\r\n                \"created_at\"            TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                \"agent_id\"              TEXT NOT NULL,\r\n                \"agent_name\"            TEXT,\r\n                \"agent_keypair_path\"    TEXT NOT NULL,\r\n                \"agent_keypair_vlog_pk\" TEXT NOT NULL,\r\n                UNIQUE (\"agent_id\")\r\n            );\r\n        `);\r\n    }\r\n\r\n    async addLog(log: VerifiableLog): Promise<boolean> {\r\n        const sql = `\r\n            INSERT INTO \"tee_verifiable_logs\" (\"id\", \"created_at\", \"agent_id\", \"room_id\", \"user_id\", \"type\", \"content\",\r\n                                           \"signature\")\r\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?);\r\n        `;\r\n        try {\r\n            this.db\r\n                .prepare(sql)\r\n                .run(\r\n                    log.id || uuidv4(),\r\n                    log.created_at || new Date().getTime(),\r\n                    log.agent_id,\r\n                    log.room_id,\r\n                    log.user_id,\r\n                    log.type,\r\n                    log.content,\r\n                    log.signature\r\n                );\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"SQLite3 Error adding log:\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async pageQueryLogs(\r\n        query: VerifiableLogQuery,\r\n        page: number,\r\n        pageSize: number\r\n    ): Promise<PageQuery<VerifiableLog[]>> {\r\n        const conditions: string[] = [];\r\n        const params: (string | number)[] = [];\r\n\r\n        if (query.idEq) {\r\n            conditions.push('id = ?');\r\n            params.push(query.idEq);\r\n        }\r\n        if (query.agentIdEq) {\r\n            conditions.push('agent_id = ?');\r\n            params.push(query.agentIdEq);\r\n        }\r\n        if (query.roomIdEq) {\r\n            conditions.push('room_id = ?');\r\n            params.push(query.roomIdEq);\r\n        }\r\n        if (query.userIdEq) {\r\n            conditions.push('user_id = ?');\r\n            params.push(query.userIdEq);\r\n        }\r\n        if (query.typeEq) {\r\n            conditions.push('type = ?');\r\n            params.push(query.typeEq);\r\n        }\r\n        if (query.contLike) {\r\n            conditions.push('content LIKE ?');\r\n            params.push(`%${query.contLike}%`);\r\n        }\r\n        if (query.signatureEq) {\r\n            conditions.push('signature = ?');\r\n            params.push(query.signatureEq);\r\n        }\r\n\r\n        const whereClause =\r\n            conditions.length > 0 ? `WHERE ${conditions.join(\" AND \")}` : \"\";\r\n\r\n        let currentPage = page;  // Create a new variable instead of reassigning parameter\r\n        if (currentPage < 1) {\r\n            currentPage = 1;\r\n        }\r\n        const offset = (currentPage - 1) * pageSize;\r\n        const limit = pageSize;\r\n\r\n\r\n        try {\r\n            const totalQuery = `SELECT COUNT(*) AS total\r\n                                FROM tee_verifiable_logs ${whereClause}`;\r\n            const stmt = this.db.prepare(totalQuery);\r\n            const totalResult = stmt.get(params) as { total: number };\r\n            const total = totalResult.total;\r\n\r\n            const dataQuery = `\r\n                SELECT *\r\n                FROM tee_verifiable_logs ${whereClause}\r\n                ORDER BY created_at DESC\r\n                LIMIT ? OFFSET ?\r\n            `;\r\n            const dataResult = this.db\r\n                .prepare(dataQuery)\r\n                .all(...params, limit, offset);\r\n\r\n            return {\r\n                page: page,\r\n                pageSize: pageSize,\r\n                total: total,\r\n                data: dataResult,\r\n            } as PageQuery<VerifiableLog[]>;\r\n        } catch (error) {\r\n            console.error(\"Error querying tee_verifiable_logs:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async addAgent(agent: VerifiableAgent): Promise<boolean> {\r\n        const sql = `\r\n            INSERT INTO \"tee_verifiable_agents\" (\"id\", \"created_at\", \"agent_id\",\"agent_name\",\"agent_keypair_path\", \"agent_keypair_vlog_pk\")\r\n            VALUES (?, ?, ?, ?, ?,?);\r\n        `;\r\n        try {\r\n            this.db\r\n                .prepare(sql)\r\n                .run(\r\n                    agent.id || uuidv4(),\r\n                    agent.created_at || new Date().getTime(),\r\n                    agent.agent_id,\r\n                    agent.agent_name||\"agent bot\",\r\n                    agent.agent_keypair_path,\r\n                    agent.agent_keypair_vlog_pk\r\n                );\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"SQLite3 Error adding agent:\", error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async getAgent(agentId: string): Promise<VerifiableAgent> {\r\n        const sql = `SELECT *\r\n                     FROM \"tee_verifiable_agents\"\r\n                     WHERE agent_id = ?`;\r\n        try {\r\n            const agent = this.db.prepare(sql).get(agentId);\r\n            if (agent) {\r\n                return agent as VerifiableAgent;\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            console.error(\"SQLite3 Error getting agent:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async listAgent(): Promise<VerifiableAgent[]> {\r\n        const sql = `SELECT *\r\n                     FROM \"tee_verifiable_agents\"`;\r\n        try {\r\n            const agents = this.db.prepare(sql).all();\r\n            return agents as VerifiableAgent[];\r\n        } catch (error) {\r\n            console.error(\"SQLite3 Error listing agent:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","export interface VerifiableLog {\r\n    id: string; // Primary Key UUID\r\n    created_at?: Date; // Default value: CURRENT_TIMESTAMP\r\n    agent_id: string; // Not null\r\n    room_id: string; // Not null\r\n    user_id: string; // Not null\r\n    type: string; // Not null\r\n    content: string; // Not null\r\n    signature: string; // Not null\r\n}\r\nexport interface VerifiableLogQuery {\r\n    idEq: string;\r\n    agentIdEq: string;\r\n    roomIdEq: string;\r\n    userIdEq: string;\r\n    typeEq: string;\r\n    contLike: string;\r\n    signatureEq: string;\r\n}\r\n\r\nexport interface VerifiableAgent {\r\n    id: string; // Primary Key\r\n    created_at?: Date; // Default value: CURRENT_TIMESTAMP\r\n    agent_id: string; // Not null\r\n    agent_name: string; // Not null\r\n    agent_keypair_path: string; // Not null\r\n    agent_keypair_vlog_pk: string; // Not null\r\n}\r\n\r\nexport interface PageQuery<Result = unknown> {\r\n    page: number;\r\n    pageSize: number;\r\n    total?: number;\r\n    data?: Result;\r\n}\r\n\r\nexport abstract class VerifiableDAO<DB = unknown> {\r\n    protected constructor() {}\r\n\r\n    /**\r\n     * The database instance.\r\n     */\r\n    db: DB;\r\n\r\n    /**\r\n     * Optional initialization method for the database adapter.\r\n     * @returns A Promise that resolves when initialization is complete.\r\n     */\r\n    abstract initializeSchema(): Promise<void>;\r\n\r\n    /**\r\n     * insert log to table\r\n     * @param log\r\n     */\r\n    abstract addLog(log: VerifiableLog): Promise<boolean>;\r\n\r\n    /**\r\n     * Performs a paginated query for VerifiableLogs based on the given criteria.\r\n     *\r\n     * @param agentQuery - The query parameters to filter the logs.\r\n     * @param page - The page number to retrieve (1-based).\r\n     * @param pageSize - The number of items per page.\r\n     * @returns A Promise that resolves to a PageQuery object containing an array of VerifiableLogs.\r\n     */\r\n    abstract pageQueryLogs(\r\n        agentQuery: VerifiableLogQuery,\r\n        page: number,\r\n        pageSize: number\r\n    ): Promise<PageQuery<VerifiableLog[]>>;\r\n\r\n    /**\r\n     * insert Verifiable Agent info to table\r\n     * @param agent\r\n     */\r\n    abstract addAgent(agent: VerifiableAgent): Promise<boolean>;\r\n\r\n    /**\r\n     * Retrieves a VerifiableAgent by its agentId.\r\n     *\r\n     * @param agentId - The unique identifier of the agent to retrieve.\r\n     * @returns A Promise that resolves to a VerifiableAgent object.\r\n     */\r\n    abstract getAgent(agentId: string): Promise<VerifiableAgent>;\r\n\r\n    /**\r\n     * Retrieves a list of all VerifiableAgents.\r\n     *\r\n     * @returns A Promise that resolves to an array of VerifiableAgent objects.\r\n     */\r\n    abstract listAgent(): Promise<VerifiableAgent[]>;\r\n}\r\n\r\nexport interface IVerifiableLogProvider {\r\n    /**\r\n     * Logs a message with the given parameters.\r\n     *\r\n     * @param params - The parameters for the log message.\r\n     * @param endpoint - Tee endpoint.\r\n     * @returns A Promise that resolves to a boolean indicating whether the log was successful.\r\n     */\r\n    log(\r\n        params: {\r\n            agentId: string;\r\n            roomId: string;\r\n            userId: string;\r\n            type: string;\r\n            content: string;\r\n        },\r\n        endpoint: string\r\n    ): Promise<boolean>;\r\n\r\n    /**\r\n     * Registers a new agent with the given parameters.\r\n     *\r\n     * @param params - The parameters for the agent registration.\r\n     * @param endpoint - Tee endpoint.\r\n     * @returns A Promise that resolves to a boolean indicating whether the registration was successful.\r\n     */\r\n    registerAgent(\r\n        params: {\r\n            agentId: string;\r\n        },\r\n        endpoint: string\r\n    ): Promise<boolean>;\r\n}\r\n","import { DeriveKeyProvider } from \"@elizaos/plugin-tee\";\r\nimport * as crypto from \"node:crypto\";  // Added node: protocol\r\n\r\nexport class DeriveProvider {\r\n    private provider: DeriveKeyProvider;\r\n\r\n    constructor(teeModel: string) {\r\n        this.provider = new DeriveKeyProvider(teeModel);\r\n    }\r\n\r\n    async deriveKeyPair(params: {\r\n        agentId: string;\r\n        bizModel: string;\r\n    }): Promise<Buffer> {\r\n        const keyPath = `/${params.agentId}/tee/keypair/${params.bizModel}`;\r\n        const seed = await this.provider.rawDeriveKey(keyPath, params.agentId);\r\n        const privateKey = crypto.createPrivateKey({\r\n            key: seed.key,\r\n            format: \"pem\",\r\n        });\r\n        const privateKeyDer = privateKey.export({\r\n            format: \"der\",\r\n            type: \"pkcs8\",\r\n        });\r\n        return crypto.createHash(\"sha256\").update(privateKeyDer).digest();\r\n    }\r\n\r\n    async encryptAgentData(\r\n        params: {\r\n            agentId: string;\r\n            bizModel: string;\r\n        },\r\n        plainText: string\r\n    ): Promise<{\r\n        success: boolean;\r\n        errorMsg: string;\r\n        ivHex: string;\r\n        encryptedData: string;\r\n    }> {\r\n        try {\r\n            const rawKey = await this.deriveKeyPair(params);\r\n            const { ivHex, encrypted } = this.encrypt(plainText, rawKey);\r\n\r\n            return {\r\n                success: true,\r\n                errorMsg: \"\",\r\n                ivHex: ivHex,\r\n                encryptedData: encrypted,\r\n            };\r\n        } catch (error) {\r\n            return {\r\n                success: true,\r\n                errorMsg: `encryptAgentData failed: ${error}`,  // Changed to template literal\r\n                ivHex: \"\",\r\n                encryptedData: \"\",\r\n            };\r\n        }\r\n    }\r\n\r\n    async decryptAgentData(\r\n        params: {\r\n            agentId: string;\r\n            bizModel: string;\r\n        },\r\n        ivHex: string,\r\n        encryptedData: string\r\n    ): Promise<{\r\n        success: boolean;\r\n        errorMsg: string;\r\n        plainText: string;\r\n    }> {\r\n        try {\r\n            const rawKey = await this.deriveKeyPair(params);\r\n            const plainText = this.decrypt(encryptedData, ivHex, rawKey);\r\n            return {\r\n                success: true,\r\n                errorMsg: \"\",\r\n                plainText: plainText,\r\n            };\r\n        } catch (error) {\r\n            return {\r\n                success: false,\r\n                errorMsg: `decryptAgentData failed: ${error}`,  // Changed to template literal\r\n                plainText: \"\",\r\n            };\r\n        }\r\n    }\r\n\r\n    private encrypt(\r\n        text: string,\r\n        key: Buffer\r\n    ): { ivHex: string; encrypted: string } {\r\n        // generate a random initialization vector iv\r\n        const iv = crypto.randomBytes(16);\r\n\r\n        // create cipher object\r\n        const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\r\n\r\n        let encrypted = cipher.update(text, \"utf8\", \"hex\");\r\n        encrypted += cipher.final(\"hex\");\r\n\r\n        //Return IV and encrypted data (IV needs to be used during decryption)\r\n        return { ivHex: iv.toString(\"hex\"), encrypted: encrypted };\r\n    }\r\n\r\n    private decrypt(encryptedData: string, ivHex: string, key: Buffer): string {\r\n        const decipher = crypto.createDecipheriv(\r\n            \"aes-256-cbc\",\r\n            key,\r\n            Buffer.from(ivHex, \"hex\")\r\n        );\r\n        let decrypted = decipher.update(encryptedData, \"hex\", \"utf8\");\r\n        decrypted += decipher.final(\"utf8\");\r\n        return decrypted;\r\n    }\r\n}\r\n"],"mappings":"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","names":["DeriveKeyProvider"]}