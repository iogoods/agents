{"version":3,"sources":["../src/providers/orca/positionProvider.ts","../../../node_modules/@solana/errors/src/codes.ts","../../../node_modules/@solana/errors/src/context.ts","../../../node_modules/@solana/errors/src/messages.ts","../../../node_modules/@solana/errors/src/message-formatter.ts","../../../node_modules/@solana/errors/src/error.ts","../../../node_modules/@solana/errors/src/stack-trace.ts","../../../node_modules/@solana/errors/src/rpc-enum-errors.ts","../../../node_modules/@solana/errors/src/instruction-error.ts","../../../node_modules/@solana/errors/src/transaction-error.ts","../../../node_modules/@solana/errors/src/json-rpc-error.ts","../../../node_modules/@solana/codecs-core/src/bytes.ts","../../../node_modules/@solana/codecs-core/src/codec.ts","../../../node_modules/@solana/codecs-core/src/combine-codec.ts","../../../node_modules/@solana/codecs-core/src/add-codec-sentinel.ts","../../../node_modules/@solana/codecs-core/src/assertions.ts","../../../node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts","../../../node_modules/@solana/codecs-core/src/fix-codec-size.ts","../../../node_modules/@solana/codecs-core/src/offset-codec.ts","../../../node_modules/@solana/codecs-core/src/resize-codec.ts","../../../node_modules/@solana/codecs-core/src/pad-codec.ts","../../../node_modules/@solana/codecs-core/src/reverse-codec.ts","../../../node_modules/@solana/codecs-core/src/transform-codec.ts","../../../node_modules/@solana/codecs-strings/src/assertions.ts","../../../node_modules/@solana/codecs-strings/src/baseX.ts","../../../node_modules/@solana/codecs-strings/src/base10.ts","../../../node_modules/@solana/codecs-strings/src/base16.ts","../../../node_modules/@solana/codecs-strings/src/base58.ts","../../../node_modules/@solana/codecs-strings/src/baseX-reslice.ts","../../../node_modules/@solana/codecs-strings/src/base64.ts","../../../node_modules/@solana/codecs-strings/src/null-characters.ts","../../../node_modules/@solana/text-encoding-impl/src/index.node.ts","../../../node_modules/@solana/codecs-strings/src/utf8.ts","../../../node_modules/@solana/accounts/src/account.ts","../../../node_modules/@solana/accounts/src/decode-account.ts","../../../node_modules/@solana/accounts/src/parse-account.ts","../../../node_modules/@solana/accounts/src/fetch-account.ts","../../../node_modules/@solana/accounts/src/maybe-account.ts","../../../node_modules/@solana/assertions/src/subtle-crypto.ts","../../../node_modules/@solana/assertions/src/crypto.ts","../../../node_modules/@solana/addresses/src/address.ts","../../../node_modules/@solana/addresses/src/vendor/noble/ed25519.ts","../../../node_modules/@solana/addresses/src/curve.ts","../../../node_modules/@solana/addresses/src/program-derived-address.ts","../../../node_modules/@solana/addresses/src/public-key.ts","../../../node_modules/@solana/functional/src/pipe.ts","../../../node_modules/@solana/instructions/src/instruction.ts","../../../node_modules/@solana/instructions/src/roles.ts","../../../node_modules/@solana/keys/src/private-key.ts","../../../node_modules/@solana/keys/src/public-key.ts","../../../node_modules/@solana/keys/src/signatures.ts","../../../node_modules/@solana/keys/src/key-pair.ts","../../../node_modules/@solana/programs/src/program-error.ts","../../../node_modules/@solana/rpc-spec-types/src/parse-json-with-bigints.ts","../../../node_modules/@solana/rpc-spec-types/src/rpc-message.ts","../../../node_modules/@solana/rpc-spec-types/src/stringify-json-with-bigints.ts","../../../node_modules/@solana/rpc-spec/src/rpc.ts","../../../node_modules/@solana/rpc-spec/src/rpc-api.ts","../../../node_modules/@solana/rpc-spec/src/rpc-transport.ts","../../../node_modules/@solana/rpc-transformers/src/tree-traversal.ts","../../../node_modules/@solana/rpc-transformers/src/request-transformer-bigint-downcast.ts","../../../node_modules/@solana/rpc-transformers/src/request-transformer-default-commitment.ts","../../../node_modules/@solana/rpc-transformers/src/request-transformer-integer-overflow.ts","../../../node_modules/@solana/rpc-transformers/src/request-transformer-options-object-position-config.ts","../../../node_modules/@solana/rpc-transformers/src/request-transformer.ts","../../../node_modules/@solana/rpc-transformers/src/response-transformer-bigint-upcast.ts","../../../node_modules/@solana/rpc-transformers/src/response-transformer-result.ts","../../../node_modules/@solana/rpc-transformers/src/response-transformer-throw-solana-error.ts","../../../node_modules/@solana/rpc-transformers/src/response-transformer.ts","../../../node_modules/@solana/rpc-transformers/src/response-transformer-allowed-numeric-values.ts","../../../node_modules/@solana/rpc-api/src/index.ts","../../../node_modules/@solana/rpc-transport-http/src/http-transport-headers.ts","../../../node_modules/@solana/rpc-transport-http/src/http-transport.ts","../../../node_modules/@solana/rpc-transport-http/src/is-solana-request.ts","../../../node_modules/@solana/rpc-transport-http/src/http-transport-for-solana-rpc.ts","../../../node_modules/@solana/fast-stable-stringify/src/index.ts","../../../node_modules/@solana/rpc/src/rpc-integer-overflow-error.ts","../../../node_modules/@solana/rpc/src/rpc-default-config.ts","../../../node_modules/@solana/rpc/src/rpc-request-coalescer.ts","../../../node_modules/@solana/rpc/src/rpc-request-deduplication.ts","../../../node_modules/@solana/rpc/src/rpc-transport.ts","../../../node_modules/@solana/rpc/src/rpc.ts","../../../node_modules/@solana/subscribable/src/async-iterable.ts","../../../node_modules/@solana/subscribable/src/data-publisher.ts","../../../node_modules/@solana/subscribable/src/demultiplex.ts","../../../node_modules/@solana/promises/src/race.ts","../../../node_modules/@solana/promises/src/abortable.ts","../../../node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions.ts","../../../node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions-api.ts","../../../node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions-channel.ts","../../../node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions-pubsub-plan.ts","../../../node_modules/@solana/rpc-subscriptions-api/src/index.ts","../../../node_modules/@solana/ws-impl/src/index.node.ts","../../../node_modules/@solana/rpc-subscriptions-channel-websocket/src/websocket-channel.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-integer-overflow-error.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-default-config.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-autopinger.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool-internal.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-json.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-json-bigint.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-channel.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-coalescer.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-transport.ts","../../../node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions.ts","../../../node_modules/@solana/codecs-numbers/src/assertions.ts","../../../node_modules/@solana/codecs-numbers/src/common.ts","../../../node_modules/@solana/codecs-numbers/src/utils.ts","../../../node_modules/@solana/codecs-numbers/src/f32.ts","../../../node_modules/@solana/codecs-numbers/src/f64.ts","../../../node_modules/@solana/codecs-numbers/src/i128.ts","../../../node_modules/@solana/codecs-numbers/src/i16.ts","../../../node_modules/@solana/codecs-numbers/src/i32.ts","../../../node_modules/@solana/codecs-numbers/src/i64.ts","../../../node_modules/@solana/codecs-numbers/src/i8.ts","../../../node_modules/@solana/codecs-numbers/src/short-u16.ts","../../../node_modules/@solana/codecs-numbers/src/u128.ts","../../../node_modules/@solana/codecs-numbers/src/u16.ts","../../../node_modules/@solana/codecs-numbers/src/u32.ts","../../../node_modules/@solana/codecs-numbers/src/u64.ts","../../../node_modules/@solana/codecs-numbers/src/u8.ts","../../../node_modules/@solana/rpc-types/src/blockhash.ts","../../../node_modules/@solana/rpc-types/src/cluster-url.ts","../../../node_modules/@solana/rpc-types/src/commitment.ts","../../../node_modules/@solana/rpc-types/src/lamports.ts","../../../node_modules/@solana/rpc-types/src/stringified-bigint.ts","../../../node_modules/@solana/rpc-types/src/stringified-number.ts","../../../node_modules/@solana/rpc-types/src/unix-timestamp.ts","../../../node_modules/@solana/codecs-data-structures/src/assertions.ts","../../../node_modules/@solana/codecs-data-structures/src/utils.ts","../../../node_modules/@solana/codecs-data-structures/src/array.ts","../../../node_modules/@solana/codecs-data-structures/src/bit-array.ts","../../../node_modules/@solana/codecs-data-structures/src/boolean.ts","../../../node_modules/@solana/codecs-data-structures/src/bytes.ts","../../../node_modules/@solana/codecs-strings/src/base16.ts","../../../node_modules/@solana/codecs-data-structures/src/constant.ts","../../../node_modules/@solana/codecs-data-structures/src/tuple.ts","../../../node_modules/@solana/codecs-data-structures/src/union.ts","../../../node_modules/@solana/codecs-data-structures/src/discriminated-union.ts","../../../node_modules/@solana/codecs-data-structures/src/enum-helpers.ts","../../../node_modules/@solana/codecs-data-structures/src/enum.ts","../../../node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts","../../../node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts","../../../node_modules/@solana/codecs-data-structures/src/map.ts","../../../node_modules/@solana/codecs-data-structures/src/unit.ts","../../../node_modules/@solana/codecs-data-structures/src/nullable.ts","../../../node_modules/@solana/codecs-data-structures/src/set.ts","../../../node_modules/@solana/codecs-data-structures/src/struct.ts","../../../node_modules/@solana/transaction-messages/src/blockhash.ts","../../../node_modules/@solana/codecs-strings/src/assertions.ts","../../../node_modules/@solana/codecs-strings/src/baseX.ts","../../../node_modules/@solana/codecs-strings/src/base58.ts","../../../node_modules/@solana/transaction-messages/src/codecs/address-table-lookup.ts","../../../node_modules/@solana/transaction-messages/src/codecs/header.ts","../../../node_modules/@solana/transaction-messages/src/codecs/instruction.ts","../../../node_modules/@solana/transaction-messages/src/codecs/transaction-version.ts","../../../node_modules/@solana/transaction-messages/src/codecs/message.ts","../../../node_modules/@solana/transaction-messages/src/compile/accounts.ts","../../../node_modules/@solana/transaction-messages/src/compile/address-table-lookups.ts","../../../node_modules/@solana/transaction-messages/src/compile/header.ts","../../../node_modules/@solana/transaction-messages/src/compile/instructions.ts","../../../node_modules/@solana/transaction-messages/src/compile/lifetime-token.ts","../../../node_modules/@solana/transaction-messages/src/compile/static-accounts.ts","../../../node_modules/@solana/transaction-messages/src/compile/message.ts","../../../node_modules/@solana/transaction-messages/src/compress-transaction-message.ts","../../../node_modules/@solana/transaction-messages/src/create-transaction-message.ts","../../../node_modules/@solana/transaction-messages/src/durable-nonce.ts","../../../node_modules/@solana/transaction-messages/src/fee-payer.ts","../../../node_modules/@solana/transaction-messages/src/instructions.ts","../../../node_modules/@solana/transaction-messages/src/decompile-message.ts","../../../node_modules/@solana/transactions/src/codecs/signatures-encoder.ts","../../../node_modules/@solana/transactions/src/codecs/transaction-codec.ts","../../../node_modules/@solana/transactions/src/compile-transaction.ts","../../../node_modules/@solana/transactions/src/signatures.ts","../../../node_modules/@solana/transactions/src/wire-transaction.ts","../../../node_modules/@solana/signers/src/deduplicate-signers.ts","../../../node_modules/@solana/signers/src/transaction-modifying-signer.ts","../../../node_modules/@solana/signers/src/transaction-partial-signer.ts","../../../node_modules/@solana/signers/src/transaction-sending-signer.ts","../../../node_modules/@solana/signers/src/transaction-signer.ts","../../../node_modules/@solana/signers/src/account-signer-meta.ts","../../../node_modules/@solana/signers/src/add-signers.ts","../../../node_modules/@solana/signers/src/fee-payer-signer.ts","../../../node_modules/@solana/signers/src/message-partial-signer.ts","../../../node_modules/@solana/signers/src/keypair-signer.ts","../../../node_modules/@solana/signers/src/message-modifying-signer.ts","../../../node_modules/@solana/signers/src/message-signer.ts","../../../node_modules/@solana/signers/src/noop-signer.ts","../../../node_modules/@solana/signers/src/transaction-with-single-sending-signer.ts","../../../node_modules/@solana/signers/src/sign-transaction.ts","../../../node_modules/@solana/text-encoding-impl/src/index.node.ts","../../../node_modules/@solana/signers/src/signable-message.ts","../../../node_modules/@solana/transaction-confirmation/src/confirmation-strategy-blockheight.ts","../../../node_modules/@solana/transaction-confirmation/src/confirmation-strategy-nonce.ts","../../../node_modules/@solana/transaction-confirmation/src/confirmation-strategy-recent-signature.ts","../../../node_modules/@solana/transaction-confirmation/src/confirmation-strategy-timeout.ts","../../../node_modules/@solana/transaction-confirmation/src/confirmation-strategy-racer.ts","../../../node_modules/@solana/transaction-confirmation/src/waiters.ts","../src/utils/loadWallet.ts","../src/utils/TEE/deriveKeyProvider.ts","../src/utils/TEE/remoteAttestationProvider.ts","../src/evaluators/orca/repositionEvaluator.ts","../src/utils/sendMessage.ts","../src/actions/orca/managePositions.ts","../src/utils/sendTransaction.ts","../src/index.ts"],"sourcesContent":["import { elizaLogger, IAgentRuntime, Memory, Provider, settings, State } from \"@elizaos/core\";\r\nimport { createSolanaRpc } from \"@solana/web3.js\";\r\nimport { loadWallet } from \"../../utils/loadWallet\";\r\nimport { Address, Rpc, SolanaRpcApi } from \"@solana/web3.js\";\r\nimport { fetchPositionsForOwner, HydratedPosition } from \"@orca-so/whirlpools\"\r\nimport { fetchWhirlpool, Whirlpool } from \"@orca-so/whirlpools-client\";\r\nimport { sqrtPriceToPrice, tickIndexToPrice } from \"@orca-so/whirlpools-core\";\r\nimport { fetchMint, Mint } from \"@solana-program/token-2022\"\r\n\r\nexport interface FetchedPositionStatistics {\r\n    whirlpoolAddress: Address;\r\n    positionMint: Address;\r\n    inRange: boolean;\r\n    distanceCenterPositionFromPoolPriceBps: number;\r\n    positionWidthBps: number;\r\n}\r\n\r\nexport const positionProvider: Provider = {\r\n    get: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state?: State\r\n    ) => {\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n        try {\r\n            const { address: ownerAddress } = await loadWallet(\r\n                runtime,\r\n                false\r\n            );\r\n            const rpc = createSolanaRpc(settings.SOLANA_RPC_URL!);\r\n            const positions = await fetchPositions(rpc, ownerAddress);\r\n            const positionsString = JSON.stringify(positions);\r\n            return positionsString\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in wallet provider:\", error);\r\n            return null;\r\n        }\r\n    },\r\n};\r\n\r\nconst fetchPositions = async (rpc: Rpc<SolanaRpcApi>, ownerAddress: Address): Promise<FetchedPositionStatistics[]> => {\r\n    try {\r\n        const positions = await fetchPositionsForOwner(rpc, ownerAddress);\r\n        const fetchedWhirlpools: Map<string, Whirlpool> = new Map();\r\n        const fetchedMints: Map<string, Mint> = new Map();\r\n        const FetchedPositionsStatistics: FetchedPositionStatistics[] = await Promise.all(positions.map(async (position) => {\r\n            const positionData = (position as HydratedPosition).data;\r\n            const positionMint = positionData.positionMint\r\n            const whirlpoolAddress = positionData.whirlpool;\r\n            if (!fetchedWhirlpools.has(whirlpoolAddress)) {\r\n                const whirlpool = await fetchWhirlpool(rpc, whirlpoolAddress);\r\n                if (whirlpool) {\r\n                    fetchedWhirlpools.set(whirlpoolAddress, whirlpool.data);\r\n                }\r\n            }\r\n            const whirlpool = fetchedWhirlpools.get(whirlpoolAddress);\r\n            const { tokenMintA, tokenMintB } = whirlpool;\r\n            if (!fetchedMints.has(tokenMintA)) {\r\n                const mintA = await fetchMint(rpc, tokenMintA);\r\n                fetchedMints.set(tokenMintA, mintA.data);\r\n            }\r\n            if (!fetchedMints.has(tokenMintB)) {\r\n                const mintB = await fetchMint(rpc, tokenMintB);\r\n                fetchedMints.set(tokenMintB, mintB.data);\r\n            }\r\n            const mintA = fetchedMints.get(tokenMintA);\r\n            const mintB = fetchedMints.get(tokenMintB);\r\n            const currentPrice = sqrtPriceToPrice(whirlpool.sqrtPrice, mintA.decimals, mintB.decimals);\r\n            const positionLowerPrice = tickIndexToPrice(positionData.tickLowerIndex, mintA.decimals, mintB.decimals);\r\n            const positionUpperPrice = tickIndexToPrice(positionData.tickUpperIndex, mintA.decimals, mintB.decimals);\r\n\r\n            const inRange = whirlpool.tickCurrentIndex >= positionData.tickLowerIndex && whirlpool.tickCurrentIndex <= positionData.tickUpperIndex;\r\n            const positionCenterPrice = (positionLowerPrice + positionUpperPrice) / 2;\r\n            const distanceCenterPositionFromPoolPriceBps = Math.abs(currentPrice - positionCenterPrice) / currentPrice * 10000;\r\n            const positionWidthBps = ((positionUpperPrice - positionLowerPrice) / positionCenterPrice * 10000) / 2;\r\n\r\n            return {\r\n                whirlpoolAddress,\r\n                positionMint: positionMint,\r\n                inRange,\r\n                distanceCenterPositionFromPoolPriceBps,\r\n                positionWidthBps,\r\n            } as FetchedPositionStatistics;\r\n        }));\r\n\r\n        return FetchedPositionsStatistics\r\n    } catch (error) {\r\n        throw new Error(\"Error during feching positions\");\r\n    }\r\n}","/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n\n/**\n * A union of every Solana error code\n *\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional `SolanaError` nested inside as `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: Uint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`ITransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context ? `${context[variableName as keyof typeof context]}` : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest as SolanaErrorContext[TErrorCode];\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        } as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/response.rs\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    logs: string[] | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: number | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError({ code: rawCode, data, message }: RpcErrorResponse): SolanaError {\n    let out: SolanaError;\n    const code = Number(rawCode);\n    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n        const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n            ...preflightErrorContext,\n            ...causeObject,\n        });\n    } else {\n        let errorContext;\n        switch (code) {\n            case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n            case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n            case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n            case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n            case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                // The server supplies no structured data, but rather a pre-formatted message. Put\n                // the server message in `context` so as not to completely lose the data. The long\n                // term fix for this is to add data to the server responses and modify the\n                // messages in `@solana/errors` to be actual format strings.\n                errorContext = { __serverMessage: message };\n                break;\n            default:\n                if (typeof data === 'object' && !Array.isArray(data)) {\n                    errorContext = data;\n                }\n        }\n        out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * Note that, if the sentinel is found in the encoded value, an error is thrown.\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until a `Uint8Array` sentinel is found.\n *\n * If the sentinel is not found in the byte array to decode, an error is thrown.\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * Note that, if the sentinel is found in the encoded value\n * or not found in the byte array to decode, an error is thrown.\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the `decoder` by reading the `prefix` encoder prefix.\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Bounds the size of the `codec` using the provided `prefix` codec prefix.\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder.\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/** The amount of bytes required to store the base account information without its data. */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/** Describe the generic account details applicable to every account. */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n};\n\n/** Defines a Solana account with its generic details and parsed or encoded data. */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/** Defines a Solana account with its generic details and encoded data. */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/** Decodes the data of a given account using the provided decoder. */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/** Asserts that an account has been decoded. */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/** Asserts that all accounts have been decoded. */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/** Parse an account object received from a base64-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/** Parse an account object received from a base58-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/** Parse an account object received from a json-parsed RPC call into an Account or MaybeAccount type. */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/** Optional configuration for fetching a singular account. */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch a base64-encoded account that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/** Fetch a json-parsed account that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/** Optional configuration for fetching multiple accounts. */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch multiple base64-encoded accounts that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/** Fetch multiple json-parsed accounts that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/** Defines a Solana account that may or may not exist after having tried to fetch it. */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/** Defines a Solana account with encoded data that may or may not exist after having tried to fetch it. */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/** Asserts that an account that may or may not exists, actually exists. */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/** Asserts that all accounts that may or may not exist, actually all exist. */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Address<TAddress extends string = string> = TAddress & {\n    readonly __brand: unique symbol;\n};\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7); // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y²\n    const u = mod(y2 - 1n); // u=y²-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: Uint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: Uint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport type { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve';\n\n/**\n * An address derived from a program address and a set of seeds.\n * It includes the bump seed used to derive the address and\n * ensure the address is not on the Ed25519 curve.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * A number between 0 and 255, inclusive.\n */\nexport type ProgramDerivedAddressBump = number & {\n    readonly __brand: unique symbol;\n};\n\n/**\n * Returns true if the input value is a program derived address.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * Fails if the input value is not a program derived address.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder } from './address';\n\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n","/**\n * General pipe function.\n * Provide an initial value and a list of functions to pipe it through.\n *\n * Following common implementations of pipe functions that use TypeScript,\n * this function supports a maximum arity of 10 for type safety.\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```typescript\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n * @param init  The initial value\n * @param fns   Any number of functions to pipe the value through\n * @returns     The final value with all functions applied\n */\nexport function pipe<TInitial>(init: TInitial): TInitial;\nexport function pipe<TInitial, R1>(init: TInitial, init_r1: (init: TInitial) => R1): R1;\nexport function pipe<TInitial, R1, R2>(init: TInitial, init_r1: (init: TInitial) => R1, r1_r2: (r1: R1) => R2): R2;\nexport function pipe<TInitial, R1, R2, R3>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n): R3;\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n): R4;\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n): R5;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n): R6;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n): R7;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n): R8;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n    r8_r9: (r8: R8) => R9,\n): R9;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n    r8_r9: (r8: R8) => R9,\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { IAccountLookupMeta, IAccountMeta } from './accounts';\n\nexport interface IInstruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: Uint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\nexport interface IInstructionWithAccounts<TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[]>\n    extends IInstruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\nexport interface IInstructionWithData<TData extends Uint8Array> extends IInstruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\n */\n\nexport enum AccountRole {\n    // Bitflag guide: is signer ⌄⌄ is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\nexport async function createPrivateKeyFromBytes(bytes: ReadonlyUint8Array, extractable?: boolean): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, 'Ed25519', extractable ?? false, ['sign']);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Signature = string & { readonly __brand: unique symbol };\nexport type SignatureBytes = Uint8Array & { readonly __brand: unique symbol };\n\nlet base58Encoder: Encoder<string> | undefined;\n\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        return false;\n    }\n    return true;\n}\n\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign('Ed25519', key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify('Ed25519', key, signature, data);\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ 'Ed25519', // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\nexport async function createKeyPairFromBytes(bytes: ReadonlyUint8Array, extractable?: boolean): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), 'Ed25519', /* extractable */ true, ['verify']),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n","import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n","/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n","import { RpcRequest } from './rpc-request';\n\nlet _nextMessageId = 0n;\nfunction getNextMessageId(): string {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\n\nexport function createRpcMessage<TParams>(request: RpcRequest<TParams>) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method: request.methodName,\n        params: request.params,\n    };\n}\n","/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigints(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n","import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    requestTransformer?: RpcRequestTransformer;\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    payload: unknown;\n    signal?: AbortSignal;\n}>;\n\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n","import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly __brand: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nexport function getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n","import { getTreeWalkerRequestTransformer } from './tree-traversal';\n\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n\nexport function downcastNodeToNumberIfBigint(value: bigint): number;\nexport function downcastNodeToNumberIfBigint<T>(value: T): T;\nexport function downcastNodeToNumberIfBigint(value: unknown): unknown {\n    return typeof value === 'bigint'\n        ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n          // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n          // downcasting `bigints` to `numbers`.\n          Number(value)\n        : value;\n}\n","import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getTreeWalkerRequestTransformer, KeyPath, TraversalState } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    defaultCommitment?: Commitment;\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n","import { getTreeWalkerResponseTransformer, KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n","import { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { result: unknown };\n\nexport function getResultResponseTransformer(): RpcResponseTransformer {\n    return json => (json as JsonRpcResponse).result;\n}\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return json => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n","import { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    /**\n     * Though technically forbidden in non-Node environments, we don't have a way to target\n     * TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n     * therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n     * when supplied in a non-Node context.\n     */\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        origin: true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n/**\n * Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n * in the `DisallowedHeaders` type.\n */\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport {\n    AllowedHttpRequestHeaders,\n    assertIsAllowedHttpRequestHeaders,\n    normalizeHeaders,\n} from './http-transport-headers';\n\ntype Config = Readonly<{\n    dispatcher_NODE_ONLY?: Dispatcher;\n    fromJson?: (rawResponse: string, payload: unknown) => RpcResponse;\n    headers?: AllowedHttpRequestHeaders;\n    toJson?: (payload: unknown) => string;\n    url: string;\n}>;\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n","import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n","import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigints } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { createHttpTransport } from './http-transport';\nimport { AllowedHttpRequestHeaders } from './http-transport-headers';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Readonly<{\n    dispatcher_NODE_ONLY?: Dispatcher;\n    headers?: AllowedHttpRequestHeaders;\n    url: string;\n}>;\n\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigints(payload) : JSON.stringify(payload),\n    });\n}\n","const objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        return '' + returnVal;\n    }\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\n/**\n * Lowercasing header names makes it easier to override user-supplied headers.\n */\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overriden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/** Creates a new Solana RPC using the default decorated HTTP transport. */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/** Creates a new Solana RPC using a custom transport. */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SolanaError,\n} from '@solana/errors';\n\nimport { DataPublisher } from './data-publisher';\n\ntype Config = Readonly<{\n    abortSignal: AbortSignal;\n    dataChannelName: string;\n    // FIXME: It would be nice to be able to constrain the type of `dataPublisher` to one that\n    //        definitely supports the `dataChannelName` and `errorChannelName` channels, and\n    //        furthermore publishes `TData` on the `dataChannelName` channel. This is more difficult\n    //        than it should be: https://tsplay.dev/NlZelW\n    dataPublisher: DataPublisher;\n    errorChannelName: string;\n}>;\n\nconst enum PublishType {\n    DATA,\n    ERROR,\n}\n\ntype IteratorKey = symbol;\ntype IteratorState<TData> =\n    | {\n          __hasPolled: false;\n          publishQueue: (\n              | {\n                    __type: PublishType.DATA;\n                    data: TData;\n                }\n              | {\n                    __type: PublishType.ERROR;\n                    err: unknown;\n                }\n          )[];\n      }\n    | {\n          __hasPolled: true;\n          onData: (data: TData) => void;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n      };\n\nlet EXPLICIT_ABORT_TOKEN: symbol;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return Symbol(\n        process.env.NODE_ENV !== \"production\"\n            ? \"This symbol is thrown from a socket's iterator when the connection is explicitly \" +\n                  'aborted by the user'\n            : undefined,\n    );\n}\n\nconst UNINITIALIZED = Symbol();\n\nexport function createAsyncIterableFromDataPublisher<TData>({\n    abortSignal,\n    dataChannelName,\n    dataPublisher,\n    errorChannelName,\n}: Config): AsyncIterable<TData> {\n    const iteratorState: Map<IteratorKey, IteratorState<TData>> = new Map();\n    function publishErrorToAllIterators(reason: unknown) {\n        for (const [iteratorKey, state] of iteratorState.entries()) {\n            if (state.__hasPolled) {\n                iteratorState.delete(iteratorKey);\n                state.onError(reason);\n            } else {\n                state.publishQueue.push({\n                    __type: PublishType.ERROR,\n                    err: reason,\n                });\n            }\n        }\n    }\n    const abortController = new AbortController();\n    abortSignal.addEventListener('abort', () => {\n        abortController.abort();\n        publishErrorToAllIterators((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n    });\n    const options = { signal: abortController.signal } as const;\n    let firstError: unknown = UNINITIALIZED;\n    dataPublisher.on(\n        errorChannelName,\n        err => {\n            if (firstError === UNINITIALIZED) {\n                firstError = err;\n                abortController.abort();\n                publishErrorToAllIterators(err);\n            }\n        },\n        options,\n    );\n    dataPublisher.on(\n        dataChannelName,\n        data => {\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onData } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n                    onData(data as TData);\n                } else {\n                    state.publishQueue.push({\n                        __type: PublishType.DATA,\n                        data: data as TData,\n                    });\n                }\n            });\n        },\n        options,\n    );\n    return {\n        async *[Symbol.asyncIterator]() {\n            if (abortSignal.aborted) {\n                return;\n            }\n            if (firstError !== UNINITIALIZED) {\n                throw firstError;\n            }\n            const iteratorKey = Symbol();\n            iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n            try {\n                while (true) {\n                    const state = iteratorState.get(iteratorKey);\n                    if (!state) {\n                        // There should always be state by now.\n                        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING);\n                    }\n                    if (state.__hasPolled) {\n                        // You should never be able to poll twice in a row.\n                        throw new SolanaError(\n                            SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                        );\n                    }\n                    const publishQueue = state.publishQueue;\n                    try {\n                        if (publishQueue.length) {\n                            state.publishQueue = [];\n                            for (const item of publishQueue) {\n                                if (item.__type === PublishType.DATA) {\n                                    yield item.data;\n                                } else {\n                                    throw item.err;\n                                }\n                            }\n                        } else {\n                            yield await new Promise<TData>((resolve, reject) => {\n                                iteratorState.set(iteratorKey, {\n                                    __hasPolled: true,\n                                    onData: resolve,\n                                    onError: reject,\n                                });\n                            });\n                        }\n                    } catch (e) {\n                        if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                            return;\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n            } finally {\n                iteratorState.delete(iteratorKey);\n            }\n        },\n    };\n}\n","import { TypedEventEmitter, TypedEventTarget } from './event-emitter';\n\ntype UnsubscribeFn = () => void;\n\nexport interface DataPublisher<TDataByChannelName extends Record<string, unknown> = Record<string, unknown>> {\n    on<const TChannelName extends keyof TDataByChannelName>(\n        channelName: TChannelName,\n        subscriber: (data: TDataByChannelName[TChannelName]) => void,\n        options?: { signal: AbortSignal },\n    ): UnsubscribeFn;\n}\n\nexport function getDataPublisherFromEventEmitter<TEventMap extends Record<string, Event>>(\n    eventEmitter: TypedEventEmitter<TEventMap> | TypedEventTarget<TEventMap>,\n): DataPublisher<{\n    [TEventType in keyof TEventMap]: TEventMap[TEventType] extends CustomEvent ? TEventMap[TEventType]['detail'] : null;\n}> {\n    return {\n        on(channelName, subscriber, options) {\n            function innerListener(ev: Event) {\n                if (ev instanceof CustomEvent) {\n                    const data = (ev as CustomEvent<TEventMap[typeof channelName]>).detail;\n                    (subscriber as unknown as (data: TEventMap[typeof channelName]) => void)(data);\n                } else {\n                    (subscriber as () => void)();\n                }\n            }\n            eventEmitter.addEventListener(channelName, innerListener, options);\n            return () => {\n                eventEmitter.removeEventListener(channelName, innerListener);\n            };\n        },\n    };\n}\n","import { DataPublisher, getDataPublisherFromEventEmitter } from './data-publisher';\n\nexport function demultiplexDataPublisher<\n    TDataPublisher extends DataPublisher,\n    const TChannelName extends Parameters<TDataPublisher['on']>[0],\n>(\n    publisher: TDataPublisher,\n    sourceChannelName: TChannelName,\n    messageTransformer: (\n        // FIXME: Deriving the type of the message from `TDataPublisher` and `TChannelName` would\n        //        help callers to constrain their transform functions.\n        message: unknown,\n    ) => [destinationChannelName: string, message: unknown] | void,\n): DataPublisher {\n    let innerPublisherState:\n        | {\n              readonly dispose: () => void;\n              numSubscribers: number;\n          }\n        | undefined;\n    const eventTarget = new EventTarget();\n    const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    return {\n        ...demultiplexedDataPublisher,\n        on(channelName, subscriber, options) {\n            if (!innerPublisherState) {\n                const innerPublisherUnsubscribe = publisher.on(sourceChannelName, sourceMessage => {\n                    const transformResult = messageTransformer(sourceMessage);\n                    if (!transformResult) {\n                        return;\n                    }\n                    const [destinationChannelName, message] = transformResult;\n                    eventTarget.dispatchEvent(\n                        new CustomEvent(destinationChannelName, {\n                            detail: message,\n                        }),\n                    );\n                });\n                innerPublisherState = {\n                    dispose: innerPublisherUnsubscribe,\n                    numSubscribers: 0,\n                };\n            }\n            innerPublisherState.numSubscribers++;\n            const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options);\n            let isActive = true;\n            function handleUnsubscribe() {\n                if (!isActive) {\n                    return;\n                }\n                isActive = false;\n                options?.signal.removeEventListener('abort', handleUnsubscribe);\n                innerPublisherState!.numSubscribers--;\n                if (innerPublisherState!.numSubscribers === 0) {\n                    innerPublisherState!.dispose();\n                    innerPublisherState = undefined;\n                }\n                unsubscribe();\n            }\n            options?.signal.addEventListener('abort', handleUnsubscribe);\n            return handleUnsubscribe;\n        },\n    };\n}\n","/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n","import { SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\nimport { createAsyncIterableFromDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsApi, RpcSubscriptionsPlan } from './rpc-subscriptions-api';\nimport { PendingRpcSubscriptionsRequest, RpcSubscribeOptions } from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<TRpcMethods> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: RpcSubscriptionsTransport;\n}>;\n\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\nexport function createSubscriptionRpc<TRpcSubscriptionsApiMethods>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);\n                if (!createRpcSubscriptionPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, {\n                        notificationName,\n                    });\n                }\n                const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);\n                return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction createPendingRpcSubscription<TNotification>(\n    transport: RpcSubscriptionsTransport,\n    subscriptionsPlan: RpcSubscriptionsPlan<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            const notificationsDataPublisher = await transport({\n                signal: abortSignal,\n                ...subscriptionsPlan,\n            });\n            return createAsyncIterableFromDataPublisher<TNotification>({\n                abortSignal,\n                dataChannelName: 'notification',\n                dataPublisher: notificationsDataPublisher,\n                errorChannelName: 'error',\n            });\n        },\n    };\n}\n","import { Callable, RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsTransportDataEvents } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsApiConfig<TApiMethods extends RpcSubscriptionsApiMethods> = Readonly<{\n    planExecutor: RpcSubscriptionsPlanExecutor<ReturnType<TApiMethods[keyof TApiMethods]>>;\n    requestTransformer?: RpcRequestTransformer;\n}>;\n\ntype RpcSubscriptionsPlanExecutor<TNotification> = (\n    config: Readonly<{\n        channel: RpcSubscriptionsChannel<unknown, unknown>;\n        request: RpcRequest;\n        signal: AbortSignal;\n    }>,\n) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n\nexport type RpcSubscriptionsPlan<TNotification> = Readonly<{\n    /**\n     * This method may be called with a newly-opened channel or a pre-established channel.\n     */\n    execute: (\n        config: Readonly<{\n            channel: RpcSubscriptionsChannel<unknown, unknown>;\n            signal: AbortSignal;\n        }>,\n    ) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n    /**\n     * This request is used to uniquely identify the subscription.\n     * It typically comes from the method name and parameters of the subscription call,\n     * after potentially being transformed by the RPC Subscriptions API.\n     */\n    request: RpcRequest;\n}>;\n\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config: RpcSubscriptionsApiConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...params: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsPlan<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const rawRequest = { methodName, params };\n                const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;\n                return {\n                    execute(planConfig) {\n                        return config.planExecutor({ ...planConfig, request });\n                    },\n                    request,\n                };\n            };\n        },\n    });\n}\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype RpcSubscriptionsChannelSolanaErrorCode =\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT;\n\nexport type RpcSubscriptionChannelEvents<TInboundMessage> = {\n    error: SolanaError<RpcSubscriptionsChannelSolanaErrorCode>;\n    message: TInboundMessage;\n};\n\nexport interface RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>\n    extends DataPublisher<RpcSubscriptionChannelEvents<TInboundMessage>> {\n    send(message: TOutboundMessage): Promise<void>;\n}\n\nexport type RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage> = (\n    config: Readonly<{\n        abortSignal: AbortSignal;\n    }>,\n) => Promise<RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>>;\n\nexport function transformChannelInboundMessages<TOutboundMessage, TNewInboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TInboundMessage) => TNewInboundMessage,\n): RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage>>({\n        ...channel,\n        on(type, subscriber, options) {\n            if (type !== 'message') {\n                return channel.on(\n                    type,\n                    subscriber as (data: RpcSubscriptionChannelEvents<TInboundMessage>[typeof type]) => void,\n                    options,\n                );\n            }\n            return channel.on(\n                'message',\n                message => (subscriber as (data: TNewInboundMessage) => void)(transform(message)),\n                options,\n            );\n        },\n    });\n}\n\nexport function transformChannelOutboundMessages<TNewOutboundMessage, TOutboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TNewOutboundMessage) => TOutboundMessage,\n): RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage>>({\n        ...channel,\n        send: message => channel.send(transform(message)),\n    });\n}\n","import {\n    getSolanaErrorFromJsonRpcError,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { safeRace } from '@solana/promises';\nimport { createRpcMessage, RpcRequest, RpcResponseData, RpcResponseTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\nimport { demultiplexDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionChannelEvents } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\n\ntype Config<TNotification> = Readonly<{\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification> | RpcResponseData<RpcSubscriptionId>>;\n    responseTransformer?: RpcResponseTransformer;\n    signal: AbortSignal;\n    subscribeRequest: RpcRequest;\n    unsubscribeMethodName: string;\n}>;\n\ntype RpcNotification<TNotification> = Readonly<{\n    method: string;\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\ntype RpcSubscriptionNotificationEvents<TNotification> = Omit<RpcSubscriptionChannelEvents<TNotification>, 'message'> & {\n    notification: TNotification;\n};\n\nconst subscriberCountBySubscriptionIdByChannel = new WeakMap<WeakKey, Record<number, number>>();\nfunction decrementSubscriberCountAndReturnNewCount(channel: WeakKey, subscriptionId?: number): number | undefined {\n    return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);\n}\nfunction incrementSubscriberCount(channel: WeakKey, subscriptionId?: number): void {\n    augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);\n}\nfunction augmentSubscriberCountAndReturnNewCount(\n    amount: -1 | 1,\n    channel: WeakKey,\n    subscriptionId?: number,\n): number | undefined {\n    if (subscriptionId === undefined) {\n        return;\n    }\n    let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);\n    if (!subscriberCountBySubscriptionId && amount > 0) {\n        subscriberCountBySubscriptionIdByChannel.set(\n            channel,\n            (subscriberCountBySubscriptionId = { [subscriptionId]: 0 }),\n        );\n    }\n    if (subscriberCountBySubscriptionId?.[subscriptionId] !== undefined) {\n        return (subscriberCountBySubscriptionId[subscriptionId] =\n            amount + subscriberCountBySubscriptionId[subscriptionId]);\n    }\n}\n\nconst cache = new WeakMap();\nfunction getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer<TNotification>(\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification>>,\n    subscribeRequest: RpcRequest,\n    responseTransformer?: RpcResponseTransformer,\n): DataPublisher<{\n    [channelName: `notification:${number}`]: TNotification;\n}> {\n    let publisherByResponseTransformer = cache.get(channel);\n    if (!publisherByResponseTransformer) {\n        cache.set(channel, (publisherByResponseTransformer = new WeakMap()));\n    }\n    const responseTransformerKey = responseTransformer ?? channel;\n    let publisher = publisherByResponseTransformer.get(responseTransformerKey);\n    if (!publisher) {\n        publisherByResponseTransformer.set(\n            responseTransformerKey,\n            (publisher = demultiplexDataPublisher(channel, 'message', rawMessage => {\n                const message = rawMessage as RpcNotification<unknown> | RpcResponseData<unknown>;\n                if (!('method' in message)) {\n                    return;\n                }\n                const transformedNotification = responseTransformer\n                    ? responseTransformer(message.params.result, subscribeRequest)\n                    : message.params.result;\n                return [`notification:${message.params.subscription}`, transformedNotification];\n            })),\n        );\n    }\n    return publisher;\n}\n\nexport async function executeRpcPubSubSubscriptionPlan<TNotification>({\n    channel,\n    responseTransformer,\n    signal,\n    subscribeRequest,\n    unsubscribeMethodName,\n}: Config<TNotification>): Promise<DataPublisher<RpcSubscriptionNotificationEvents<TNotification>>> {\n    let subscriptionId: number | undefined;\n    channel.on(\n        'error',\n        () => {\n            // An error on the channel indicates that the subscriptions are dead.\n            // There is no longer any sense hanging on to subscription ids.\n            // Erasing it here will prevent the unsubscribe code from running.\n            subscriptionId = undefined;\n            subscriberCountBySubscriptionIdByChannel.delete(channel);\n        },\n        { signal },\n    );\n    /**\n     * STEP 1\n     * Create a promise that rejects if this subscription is aborted and sends\n     * the unsubscribe message if the subscription is active at that time.\n     */\n    const abortPromise = new Promise<never>((_, reject) => {\n        function handleAbort(this: AbortSignal) {\n            /**\n             * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n             * materially the same notification will be coalesced on the server. This means they\n             * will be assigned the same subscription id, and will occupy one subscription slot. We\n             * must be careful not to send the unsubscribe message until the last subscriber aborts.\n             */\n            if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {\n                const unsubscribePayload = createRpcMessage({\n                    methodName: unsubscribeMethodName,\n                    params: [subscriptionId],\n                });\n                subscriptionId = undefined;\n                channel.send(unsubscribePayload).catch(() => {});\n            }\n            reject(this.reason);\n        }\n        if (signal.aborted) {\n            handleAbort.call(signal);\n        } else {\n            signal.addEventListener('abort', handleAbort);\n        }\n    });\n    /**\n     * STEP 2\n     * Send the subscription request.\n     */\n    const subscribePayload = createRpcMessage(subscribeRequest);\n    await channel.send(subscribePayload);\n    /**\n     * STEP 3\n     * Wait for the acknowledgement from the server with the subscription id.\n     */\n    const subscriptionIdPromise = new Promise<RpcSubscriptionId>((resolve, reject) => {\n        const abortController = new AbortController();\n        signal.addEventListener('abort', abortController.abort.bind(abortController));\n        const options = { signal: abortController.signal } as const;\n        channel.on(\n            'error',\n            err => {\n                abortController.abort();\n                reject(err);\n            },\n            options,\n        );\n        channel.on(\n            'message',\n            message => {\n                if (message && typeof message === 'object' && 'id' in message && message.id === subscribePayload.id) {\n                    abortController.abort();\n                    if ('error' in message) {\n                        reject(getSolanaErrorFromJsonRpcError(message.error));\n                    } else {\n                        resolve(message.result);\n                    }\n                }\n            },\n            options,\n        );\n    });\n    subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);\n    if (subscriptionId == null) {\n        throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n    }\n    incrementSubscriberCount(channel, subscriptionId);\n    /**\n     * STEP 4\n     * Filter out notifications unrelated to this subscription.\n     */\n    const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(\n        channel,\n        subscribeRequest,\n        responseTransformer,\n    );\n    const notificationKey = `notification:${subscriptionId}` as const;\n    return {\n        on(type, listener, options) {\n            switch (type) {\n                case 'notification':\n                    return notificationPublisher.on(\n                        notificationKey,\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['notification']) => void,\n                        options,\n                    );\n                case 'error':\n                    return channel.on(\n                        'error',\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['error']) => void,\n                        options,\n                    );\n                default:\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, {\n                        channelName: type,\n                        supportedChannelNames: ['notification', 'error'],\n                    });\n            }\n        },\n    };\n}\n","import {\n    createRpcSubscriptionsApi,\n    executeRpcPubSubSubscriptionPlan,\n    RpcSubscriptionsApi,\n    RpcSubscriptionsApiMethods,\n} from '@solana/rpc-subscriptions-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpcSubscriptions,\n    jsonParsedAccountsConfigs,\n    KEYPATH_WILDCARD,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { AccountNotificationsApi } from './account-notifications';\nimport { BlockNotificationsApi } from './block-notifications';\nimport { LogsNotificationsApi } from './logs-notifications';\nimport { ProgramNotificationsApi } from './program-notifications';\nimport { RootNotificationsApi } from './root-notifications';\nimport { SignatureNotificationsApi } from './signature-notifications';\nimport { SlotNotificationsApi } from './slot-notifications';\nimport { SlotsUpdatesNotificationsApi } from './slots-updates-notifications';\nimport { VoteNotificationsApi } from './vote-notifications';\n\nexport type SolanaRpcSubscriptionsApi = AccountNotificationsApi &\n    LogsNotificationsApi &\n    ProgramNotificationsApi &\n    RootNotificationsApi &\n    SignatureNotificationsApi &\n    SlotNotificationsApi;\nexport type SolanaRpcSubscriptionsApiUnstable = BlockNotificationsApi &\n    SlotsUpdatesNotificationsApi &\n    VoteNotificationsApi;\n\nexport type {\n    AccountNotificationsApi,\n    BlockNotificationsApi,\n    LogsNotificationsApi,\n    ProgramNotificationsApi,\n    RootNotificationsApi,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n    SlotsUpdatesNotificationsApi,\n    VoteNotificationsApi,\n};\n\ntype Config = RequestTransformerConfig;\n\nfunction createSolanaRpcSubscriptionsApi_INTERNAL<TApi extends RpcSubscriptionsApiMethods>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);\n    const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n        allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n    });\n    return createRpcSubscriptionsApi<TApi>({\n        planExecutor({ request, ...rest }) {\n            return executeRpcPubSubSubscriptionPlan({\n                ...rest,\n                responseTransformer,\n                subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, 'Subscribe') },\n                unsubscribeMethodName: request.methodName.replace(/Notifications$/, 'Unsubscribe'),\n            });\n        },\n        requestTransformer,\n    });\n}\n\nexport function createSolanaRpcSubscriptionsApi<TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<TApi>(config);\n}\n\nexport function createSolanaRpcSubscriptionsApi_UNSTABLE(config?: Config) {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        config,\n    );\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            accountNotifications: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            blockNotifications: [\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['value', 'block', 'transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'index',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlySignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlyUnsignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numRequiredSignatures',\n                ],\n                ['value', 'block', 'rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            programNotifications: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n        };\n    }\n    return memoizedKeypaths;\n}\n","// When building the browser bundle, this import gets replaced by `globalThis.WebSocket`.\nimport WebSocketImpl from 'ws';\n\nexport default globalThis.WebSocket\n    ? globalThis.WebSocket // Use native `WebSocket` in runtimes that support it (eg. Deno)\n    : WebSocketImpl;\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport { getDataPublisherFromEventEmitter } from '@solana/subscribable';\nimport WebSocket from '@solana/ws-impl';\n\nexport type Config = Readonly<{\n    sendBufferHighWatermark: number;\n    signal: AbortSignal;\n    url: string;\n}>;\n\ntype WebSocketMessage = ArrayBufferLike | ArrayBufferView | Blob | string;\n\nconst NORMAL_CLOSURE_CODE = 1000; // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n\nexport function createWebSocketChannel({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcSubscriptionsChannel<WebSocketMessage, string>> {\n    if (signal.aborted) {\n        return Promise.reject(signal.reason);\n    }\n    let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n    let hasConnected = false;\n    const listenerRemovers = new Set<() => void>();\n    function cleanupListeners() {\n        listenerRemovers.forEach(r => {\n            r();\n        });\n        listenerRemovers.clear();\n    }\n    function handleAbort() {\n        cleanupListeners();\n        if (!hasConnected) {\n            rejectOpen(signal.reason);\n        }\n        if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n            webSocket.close(NORMAL_CLOSURE_CODE);\n        }\n    }\n    function handleClose(ev: CloseEvent) {\n        cleanupListeners();\n        bufferDrainWatcher?.onCancel();\n        signal.removeEventListener('abort', handleAbort);\n        webSocket.removeEventListener('close', handleClose);\n        webSocket.removeEventListener('error', handleError);\n        webSocket.removeEventListener('message', handleMessage);\n        webSocket.removeEventListener('open', handleOpen);\n        if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, {\n                        cause: ev,\n                    }),\n                }),\n            );\n        }\n    }\n    function handleError(ev: Event) {\n        if (signal.aborted) {\n            return;\n        }\n        if (!hasConnected) {\n            const failedToConnectError = new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, {\n                errorEvent: ev,\n            });\n            rejectOpen(failedToConnectError);\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: failedToConnectError,\n                }),\n            );\n        }\n    }\n    function handleMessage(ev: MessageEvent) {\n        if (signal.aborted) {\n            return;\n        }\n        eventTarget.dispatchEvent(new CustomEvent('message', { detail: ev.data }));\n    }\n    const eventTarget = new EventTarget();\n    const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    function handleOpen() {\n        hasConnected = true;\n        resolveOpen({\n            ...dataPublisher,\n            async send(message) {\n                if (webSocket.readyState !== WebSocket.OPEN) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED);\n                }\n                if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {\n                    let onCancel!: () => void;\n                    const promise = new Promise<void>((resolve, reject) => {\n                        const intervalId = setInterval(() => {\n                            if (\n                                webSocket.readyState !== WebSocket.OPEN ||\n                                !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                            ) {\n                                clearInterval(intervalId);\n                                bufferDrainWatcher = undefined;\n                                resolve();\n                            }\n                        }, 16);\n                        onCancel = () => {\n                            bufferDrainWatcher = undefined;\n                            clearInterval(intervalId);\n                            reject(\n                                new SolanaError(\n                                    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                ),\n                            );\n                        };\n                    });\n                    bufferDrainWatcher = {\n                        onCancel,\n                        promise,\n                    };\n                }\n                if (bufferDrainWatcher) {\n                    if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {\n                        const TypedArrayConstructor = message.constructor as {\n                            new (...args: [typeof message]): typeof message;\n                        };\n                        // Clone the message to prevent mutation while queued.\n                        message = new TypedArrayConstructor(message);\n                    }\n                    await bufferDrainWatcher.promise;\n                }\n                webSocket.send(message);\n            },\n        });\n    }\n    const webSocket = new WebSocket(url);\n    signal.addEventListener('abort', handleAbort);\n    webSocket.addEventListener('close', handleClose);\n    webSocket.addEventListener('error', handleError);\n    webSocket.addEventListener('message', handleMessage);\n    webSocket.addEventListener('open', handleOpen);\n    let rejectOpen!: (e: SolanaError) => void;\n    let resolveOpen!: (value: RpcSubscriptionsChannel<WebSocketMessage, string>) => void;\n    return new Promise<RpcSubscriptionsChannel<WebSocketMessage, string>>((resolve, reject) => {\n        rejectOpen = reject;\n        resolveOpen = resolve;\n    });\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.window.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.window.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n","import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n","import { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n","import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n","import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigints } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigints),\n    );\n}\n","import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    intervalMs?: number;\n    maxSubscriptionsPerChannel?: number;\n    minChannels?: number;\n    sendBufferHighWatermark?: number;\n    url: TClusterUrl;\n}>;\n\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                  `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n","import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n","import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Blockhash = string & { readonly __brand: unique symbol };\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeBlockhash.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeBlockhash =>\n        blockhash(putativeBlockhash),\n    );\n}\n\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Blockhash, 32>;\n}\n\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nexport type Lamports = bigint & { readonly __brand: unique symbol };\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedBigInt = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedNumber = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nexport type UnixTimestamp = bigint & { readonly __brand: unique symbol };\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Encodes byte arrays as provided.\n *\n * To control the size of the encoded byte array, you can use\n * the `fixEncoderSize` or `addEncoderSizePrefix` functions.\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Decodes byte arrays as-is.\n *\n * To control the size of the decoded byte array, you can use\n * the `fixDecoderSize` or `addDecoderSizePrefix` functions.\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * To control the size of the encoded and decoded byte arrays,\n * you can use the `fixCodecSize` or `addCodecSizePrefix` functions.\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Creates a void encoder that always sets the provided byte array when encoding.\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Creates a void decoder that reads the next bytes and fails if they do not match the provided constant.\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Creates a void codec that always sets the provided byte array\n * when encoding and, when decoding, asserts that the next\n * bytes match the provided byte array.\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\n\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Creates a union encoder from the provided array of encoder.\n *\n * @param variants - The variant encoders of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Creates a union decoder from the provided array of decoder.\n *\n * @param variants - The variant decoders of the union.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Creates a union codec from the provided array of codec.\n *\n * @param variants - The variant codecs of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Defines a discriminated union using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariant<WebPageEvent, '__kind', 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariantContent<WebPageEvent, '__kind', 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/** Defines the config for discriminated union codecs. */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`.\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Creates a discriminated union encoder.\n *\n * @param variants - The variant encoders of the discriminated union.\n * @param config - A set of config for the encoder.\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Creates a discriminated union decoder.\n *\n * @param variants - The variant decoders of the discriminated union.\n * @param config - A set of config for the decoder.\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Creates a discriminated union codec.\n *\n * @param variants - The variant codecs of the discriminated union.\n * @param config - A set of config for the codec.\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/** Defines the config for enum codecs. */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * When set to `true`, numeric values will be used as discriminantors and\n     * an error will be thrown if a string value is found on the enum.\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Creates an enum encoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the encoder.\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Creates an enum decoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the decoder.\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates an enum codec.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the codec.\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Prefixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Prefixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Prefixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Suffixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Suffixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Suffixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` (or `null`) value should be represented.\n     *\n     * By default, no none value is used. This means a `null` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `null` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `null` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `null`.\n     * The value `0` is encoded for `null` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `null`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `null`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { assertIsBlockhash, type Blockhash } from '@solana/rpc-types';\n\nimport { TransactionMessageWithDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\n\ntype BlockhashLifetimeConstraint = Readonly<{\n    blockhash: Blockhash;\n    lastValidBlockHeight: bigint;\n}>;\n\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\nexport function isTransactionMessageWithBlockhashLifetime(\n    transaction: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transaction is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    const lifetimeConstraintShapeMatches =\n        'lifetimeConstraint' in transaction &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint';\n    if (!lifetimeConstraintShapeMatches) return false;\n    try {\n        assertIsBlockhash(transaction.lifetimeConstraint.blockhash);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transaction: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transaction is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransaction extends BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: TTransaction,\n): Omit<TTransaction, 'lifetimeConstraint'> & TransactionMessageWithBlockhashLifetime;\n\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransaction extends BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: TTransaction,\n): TransactionMessageWithBlockhashLifetime & TTransaction;\n\nexport function setTransactionMessageLifetimeUsingBlockhash(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n) {\n    if (\n        'lifetimeConstraint' in transaction &&\n        transaction.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transaction.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transaction;\n    }\n    const out = {\n        ...transaction,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            [\n                'writableIndices',\n                getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<readonly number[]>,\n            ],\n            [\n                'readableIndices',\n                getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<readonly number[]>,\n            ],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n            ['readableIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledTransactionMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledTransactionMessage>,\n        (value: CompiledTransactionMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledTransactionMessage, { readonly version: 'legacy' }>;\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', fixEncoderSize(getBase58Encoder(), 32)],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledTransactionMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<CompiledTransactionMessage> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledTransactionMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<CompiledTransactionMessage> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountRole,\n    IAccountLookupMeta,\n    IAccountMeta,\n    IInstruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = (IAccountLookupMeta | IAccountMeta)[] & { readonly __brand: unique symbol };\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly IInstruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (IAccountLookupMeta | IAccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    lookupTableAddress: Address;\n    readableIndices: readonly number[];\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<Address, { readonly readableIndices: number[]; readonly writableIndices: number[] }> = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readableIndices: [],\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            entry.readableIndices.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    numReadonlyNonSignerAccounts: number;\n    numReadonlySignerAccounts: number;\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { IInstruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    accountIndices?: number[];\n    data?: Uint8Array;\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly IInstruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { CompilableTransactionMessage } from '../compilable-transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\nexport function compileTransactionMessage(\n    transaction: CompilableTransactionMessage & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transaction: CompilableTransactionMessage,\n): VersionedCompiledTransactionMessage;\nexport function compileTransactionMessage(transaction: CompilableTransactionMessage): CompiledTransactionMessage {\n    const addressMap = getAddressMapFromInstructions(transaction.feePayer.address, transaction.instructions);\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transaction.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transaction.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transaction.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transaction.version,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be IAccountLookupMeta | IAccountMeta\ntype WidenInstructionAccounts<TInstruction extends IInstruction> =\n    TInstruction extends IInstruction<infer TProgramAddress, infer TAccounts>\n        ? IInstruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends IAccountMeta<infer TAddress>\n                      ? IAccountLookupMeta<TAddress> | IAccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: IInstruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<IInstruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): Extract<TransactionMessage, { version: TVersion }>;\nexport function createTransactionMessage<TVersion extends TransactionVersion>({\n    version,\n}: TransactionConfig<TVersion>): TransactionMessage {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version,\n    }) as TransactionMessage;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport {\n    AccountRole,\n    IInstruction,\n    IInstructionWithAccounts,\n    IInstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\ntype AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = IInstruction<'11111111111111111111111111111111'> &\n    IInstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    IInstructionWithData<AdvanceNonceAccountInstructionData>;\ntype AdvanceNonceAccountInstructionData = Uint8Array & {\n    readonly __brand: unique symbol;\n};\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\nexport type Nonce<TNonceValue extends string = string> = TNonceValue & { readonly __brand: unique symbol };\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    nonce: Nonce<TNonceValue>;\n}>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\nexport function assertIsDurableNonceTransactionMessage(\n    transaction: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transaction is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isDurableNonceTransaction(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\nexport function isAdvanceNonceAccountInstruction(\n    instruction: IInstruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: Uint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\nexport function isDurableNonceTransaction(\n    transaction: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transaction is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        transaction.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transaction.instructions[0])\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransaction extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transaction: TTransaction | (TransactionMessageWithDurableNonceLifetime & TTransaction),\n): TransactionMessageWithDurableNonceLifetime<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n    TTransaction {\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n\n    const firstInstruction = transaction.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (isDurableNonceTransaction(transaction) && transaction.lifetimeConstraint.nonce === nonce) {\n                return transaction as TransactionMessageWithDurableNonceLifetime<\n                    TNonceAccountAddress,\n                    TNonceAuthorityAddress,\n                    TNonceValue\n                > &\n                    TTransaction;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transaction.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transaction.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transaction.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transaction,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({\n            nonce,\n        }),\n    }) as TransactionMessageWithDurableNonceLifetime<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n        TTransaction;\n}\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\nexport interface ITransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<ITransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ITransactionMessageWithFeePayer<TFeePayerAddress> & Omit<TTransactionMessage, 'feePayer'> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as ITransactionMessageWithFeePayer<TFeePayerAddress> &\n            Omit<TTransactionMessage, 'feePayer'>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<ITransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { BaseTransactionMessage } from './transaction-message';\n\nexport function appendTransactionMessageInstruction<TTransaction extends BaseTransactionMessage>(\n    instruction: TTransaction['instructions'][number],\n    transaction: TTransaction,\n): TTransaction {\n    return appendTransactionMessageInstructions([instruction], transaction);\n}\n\nexport function appendTransactionMessageInstructions<TTransaction extends BaseTransactionMessage>(\n    instructions: ReadonlyArray<TTransaction['instructions'][number]>,\n    transaction: TTransaction,\n): TTransaction {\n    return Object.freeze({\n        ...transaction,\n        instructions: Object.freeze([...transaction.instructions, ...instructions]),\n    });\n}\n\nexport function prependTransactionMessageInstruction<TTransaction extends BaseTransactionMessage>(\n    instruction: TTransaction['instructions'][number],\n    transaction: TTransaction,\n): TTransaction {\n    return prependTransactionMessageInstructions([instruction], transaction);\n}\n\nexport function prependTransactionMessageInstructions<TTransaction extends BaseTransactionMessage>(\n    instructions: ReadonlyArray<TTransaction['instructions'][number]>,\n    transaction: TTransaction,\n): TTransaction {\n    return Object.freeze({\n        ...transaction,\n        instructions: Object.freeze([...instructions, ...transaction.instructions]),\n    });\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransactionMessage } from './compilable-transaction-message';\nimport { CompiledTransactionMessage } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport {\n    isAdvanceNonceAccountInstruction,\n    Nonce,\n    setTransactionMessageLifetimeUsingDurableNonce,\n} from './durable-nonce';\nimport { setTransactionMessageFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): IAccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: IAccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: IAccountLookupMeta[] = [];\n    const writableMetas: IAccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n\n        const highestIndex = Math.max(...lookup.readableIndices, ...lookup.writableIndices);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: IAccountLookupMeta[] = lookup.readableIndices.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: IAccountLookupMeta[] = lookup.writableIndices.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: IAccountMeta[],\n): IInstruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: IInstruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    lastValidBlockHeight?: bigint;\n};\n\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    config?: DecompileTransactionMessageConfig,\n): CompilableTransactionMessage {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: IInstruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        tx => setTransactionMessageFeePayer(feePayer, tx),\n        tx =>\n            instructions.reduce((acc, instruction) => {\n                return appendTransactionMessageInstruction(instruction, acc);\n            }, tx),\n        tx =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, tx)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, tx),\n    );\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","import {\n    CompilableTransactionMessage,\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\n\nimport {\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n    TransactionWithLifetime,\n} from './lifetime';\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from './transaction';\n\nexport function compileTransaction(\n    transactionMessage: CompilableTransactionMessage & TransactionMessageWithBlockhashLifetime,\n): Readonly<Transaction & TransactionWithBlockhashLifetime>;\n\nexport function compileTransaction(\n    transactionMessage: CompilableTransactionMessage & TransactionMessageWithDurableNonceLifetime,\n): Readonly<Transaction & TransactionWithDurableNonceLifetime>;\n\nexport function compileTransaction(\n    transactionMessage: CompilableTransactionMessage,\n): Readonly<Transaction & TransactionWithLifetime>;\n\nexport function compileTransaction(\n    transactionMessage: CompilableTransactionMessage,\n): Readonly<Transaction & TransactionWithLifetime> {\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'];\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    const transaction: Transaction & TransactionWithLifetime = {\n        lifetimeConstraint,\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    };\n\n    return Object.freeze(transaction);\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\n\nimport { Transaction } from './transaction';\n\nexport interface FullySignedTransaction extends Transaction {\n    readonly __brand: unique symbol;\n}\n\nlet base58Decoder: Decoder<string> | undefined;\n\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\nfunction uint8ArraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n\nexport async function partiallySignTransaction<T extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: T,\n): Promise<T> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && uint8ArraysEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\nexport async function signTransaction<T extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: T,\n): Promise<FullySignedTransaction & T> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertTransactionIsFullySigned(out);\n    Object.freeze(out);\n    return out;\n}\n\nexport function assertTransactionIsFullySigned(\n    transaction: Transaction,\n): asserts transaction is FullySignedTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\nexport type Base64EncodedWireTransaction = string & {\n    readonly __brand: unique symbol;\n};\n\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Removes all duplicated signers from a provided array by comparing their addresses. */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions<T extends Transaction>(\n        transactions: readonly T[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly T[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/** Defines a signer capable of signing and sending transactions simultaneously. */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link TransactionSigner} interface. */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link TransactionSigner} interface. */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    ITransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { ITransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/** An extension of the IAccountMeta type that keeps track of its transaction signer. */\nexport interface IAccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends IAccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\ntype IAccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | IAccountLookupMeta\n    | IAccountMeta\n    | IAccountSignerMeta<string, TSigner>;\n\n/** A variation of the instruction type that allows IAccountSignerMeta in its account metas. */\nexport type IInstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Pick<IInstruction<string, TAccounts>, 'accounts'>;\n\n/** A variation of the transaction message type that allows IAccountSignerMeta in its account metas. */\nexport type ITransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Partial<ITransactionMessageWithFeePayer<TAddress> | ITransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, IInstruction & IInstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/** Extract all signers from an instruction that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: IInstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/** Extract all signers from a transaction message that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends ITransactionMessageWithSigners<TAddress, TSigner> = ITransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { IInstruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage } from '@solana/transaction-messages';\n\nimport { IAccountSignerMeta, IInstructionWithSigners, ITransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Attaches the provided signers to the account metas of an instruction when applicable. */\nexport function addSignersToInstruction<TInstruction extends IInstruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (IInstructionWithSigners & TInstruction),\n): IInstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as IInstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as IAccountSignerMeta);\n        }),\n    });\n}\n\n/** Attaches the provided signers to the account metas of a transaction message when applicable. */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (ITransactionMessageWithSigners & TTransactionMessage),\n): ITransactionMessageWithSigners & TTransactionMessage {\n    if (transactionMessage.instructions.length === 0) {\n        return transactionMessage as ITransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n","import { BaseTransactionMessage, ITransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\nexport interface ITransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<ITransactionMessageWithFeePayer | ITransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ITransactionMessageWithFeePayerSigner<TFeePayerAddress> & Omit<TTransactionMessage, 'feePayer'> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessagePartialSigner} interface. */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/** Asserts that the provided value implements the {@link MessagePartialSigner} interface. */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a signer capable of signing messages and transactions using a CryptoKeyPair. */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/** Checks whether the provided value implements the {@link KeyPairSigner} interface. */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link KeyPairSigner} interface. */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/** Creates a KeyPairSigner from the provided Crypto KeyPair. */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/** Securely generates a signer capable of signing messages and transactions using a Crypto KeyPair. */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/** Creates a signer capable of signing messages and transactions using the 64 bytes of a KeyPair. */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/** Creates a signer capable of signing messages and transactions using the 32 bytes of a private key. */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/** Asserts that the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/** Defines a signer capable of signing messages. */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link MessageSigner} interface. */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/** Asserts that the provided value implements the {@link MessageSigner} interface. */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a no-operation signer that pretends to partially sign messages and transactions. */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/** Creates a NoopSigner from the provided Address. */\nexport function createNoopSigner(address: Address): NoopSigner {\n    const out: NoopSigner = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { CompilableTransactionMessage } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, ITransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a transaction message with exactly one {@link TransactionSendingSigner}. */\nexport type ITransactionMessageWithSingleSendingSigner = ITransactionMessageWithSigners & {\n    readonly __transactionWithSingleSendingSigner: unique symbol;\n};\n\n/** Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}. */\nexport function isTransactionMessageWithSingleSendingSigner<TTransactionMessage extends CompilableTransactionMessage>(\n    transaction: TTransactionMessage,\n): transaction is ITransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/** Asserts that the provided transaction has exactly one {@link TransactionSendingSigner}. */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends CompilableTransactionMessage,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is ITransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport {\n    CompilableTransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\nimport {\n    assertTransactionIsFullySigned,\n    compileTransaction,\n    FullySignedTransaction,\n    Transaction,\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, ITransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\ntype CompilableTransactionMessageWithSigners = CompilableTransactionMessage & ITransactionMessageWithSigners;\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithBlockhashLifetime>;\n\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithDurableNonceLifetime>>;\n\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithLifetime>>;\n\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithLifetime>> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will assert that the transaction is fully signed before returning.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithBlockhashLifetime>>;\n\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithDurableNonceLifetime>>;\n\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithLifetime>>;\n\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithLifetime>> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertTransactionIsFullySigned(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Signs and sends a transaction using any signers that may be stored in IAccountSignerMeta\n * instruction accounts as well as any signers provided explicitly to this function.\n * It will identify a single TransactionSendingSigners to use for sending the transaction, if any.\n * Otherwise, it will send the transaction using the provided fallbackSender.\n */\nexport async function signAndSendTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(transaction: TTransactionMessage, config?: TransactionSendingSignerConfig): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithLifetime>> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    );\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n    const signedTransaction: Readonly<Transaction & TransactionWithLifetime> = {\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    };\n\n    return Object.freeze(signedTransaction);\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/** Defines a message that needs signing and its current set of signatures if any. */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a signable message from a provided content.\n * If a string is provided, it will be UTF-8 encoded.\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n","import { SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SolanaError } from '@solana/errors';\nimport type { GetEpochInfoApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport type { Commitment } from '@solana/rpc-types';\n\ntype GetBlockHeightExceedencePromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment?: Commitment;\n    lastValidBlockHeight: bigint;\n}) => Promise<void>;\n\ntype CreateBlockHeightExceedencePromiseFactoryyConfig<TCluster> = {\n    rpc: Rpc<GetEpochInfoApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryyConfig<'devnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryyConfig<'testnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryyConfig<'mainnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryyConfig<TCluster>): GetBlockHeightExceedencePromiseFn {\n    return async function getBlockHeightExceedencePromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        lastValidBlockHeight,\n    }): Promise<never> {\n        callerAbortSignal.throwIfAborted();\n        const abortController = new AbortController();\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {\n            const { absoluteSlot, blockHeight } = await rpc\n                .getEpochInfo({ commitment })\n                .send({ abortSignal: abortController.signal });\n            return {\n                blockHeight,\n                differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight,\n            };\n        }\n        try {\n            const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] =\n                await Promise.all([\n                    rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),\n                    getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight(),\n                ]);\n            callerAbortSignal.throwIfAborted();\n            let currentBlockHeight = initialBlockHeight;\n            if (currentBlockHeight <= lastValidBlockHeight) {\n                let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;\n                for await (const slotNotification of slotNotifications) {\n                    const { slot } = slotNotification;\n                    if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {\n                        // Before making a final decision, recheck the actual block height.\n                        const {\n                            blockHeight: recheckedBlockHeight,\n                            differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight,\n                        } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();\n                        currentBlockHeight = recheckedBlockHeight;\n                        if (currentBlockHeight > lastValidBlockHeight) {\n                            // Verified; the block height has been exceeded.\n                            break;\n                        } else {\n                            // The block height has not been exceeded, which implies that the\n                            // difference between the slot height and the block height has grown\n                            // (ie. some blocks have been skipped since we started). Recalibrate the\n                            // difference and keep waiting.\n                            lastKnownDifferenceBetweenSlotHeightAndBlockHeight =\n                                currentDifferenceBetweenSlotHeightAndBlockHeight;\n                        }\n                    }\n                }\n            }\n            callerAbortSignal.throwIfAborted();\n            throw new SolanaError(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, {\n                currentBlockHeight,\n                lastValidBlockHeight,\n            });\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Decoder, getBase64Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SolanaError } from '@solana/errors';\nimport { safeRace } from '@solana/promises';\nimport type { GetAccountInfoApi, Rpc } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions } from '@solana/rpc-subscriptions';\nimport type { Base64EncodedDataResponse, Commitment } from '@solana/rpc-types';\nimport { Nonce } from '@solana/transaction-messages';\n\ntype GetNonceInvalidationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n    currentNonceValue: Nonce;\n    nonceAccountAddress: Address;\n}) => Promise<void>;\n\ntype CreateNonceInvalidationPromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetAccountInfoApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nconst NONCE_VALUE_OFFSET =\n    4 + // version(u32)\n    4 + // state(u32)\n    32; // nonce authority(pubkey)\n// Then comes the nonce value.\n\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'devnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'testnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'mainnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<TCluster>): GetNonceInvalidationPromiseFn {\n    return async function getNonceInvalidationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        currentNonceValue: expectedNonceValue,\n        nonceAccountAddress,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for nonce account changes.\n         */\n        const accountNotifications = await rpcSubscriptions\n            .accountNotifications(nonceAccountAddress, { commitment, encoding: 'base64' })\n            .subscribe({ abortSignal: abortController.signal });\n        const base58Decoder = getBase58Decoder();\n        const base64Encoder = getBase64Encoder();\n        function getNonceFromAccountData([base64EncodedBytes]: Base64EncodedDataResponse): Nonce {\n            const data = base64Encoder.encode(base64EncodedBytes);\n            const nonceValueBytes = data.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);\n            return base58Decoder.decode(nonceValueBytes) as Nonce;\n        }\n        const nonceAccountDidAdvancePromise = (async () => {\n            for await (const accountNotification of accountNotifications) {\n                const nonceValue = getNonceFromAccountData(accountNotification.value.data);\n                if (nonceValue !== expectedNonceValue) {\n                    throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                        actualNonceValue: nonceValue,\n                        expectedNonceValue,\n                    });\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current nonce\n         *         value to check if it has already been advanced.\n         */\n        const nonceIsAlreadyInvalidPromise = (async () => {\n            const { value: nonceAccount } = await rpc\n                .getAccountInfo(nonceAccountAddress, {\n                    commitment,\n                    dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n                    encoding: 'base58',\n                })\n                .send({ abortSignal: abortController.signal });\n            if (!nonceAccount) {\n                throw new SolanaError(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, {\n                    nonceAccountAddress,\n                });\n            }\n            const nonceValue =\n                // This works because we asked for the exact slice of data representing the nonce\n                // value, and furthermore asked for it in `base58` encoding.\n                nonceAccount.data[0] as unknown as Nonce;\n            if (nonceValue !== expectedNonceValue) {\n                throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                    actualNonceValue: nonceValue,\n                    expectedNonceValue,\n                });\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await safeRace([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import { getSolanaErrorFromTransactionError } from '@solana/errors';\nimport type { Signature } from '@solana/keys';\nimport { safeRace } from '@solana/promises';\nimport type { GetSignatureStatusesApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport { type Commitment, commitmentComparator } from '@solana/rpc-types';\n\ntype GetRecentSignatureConfirmationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n    signature: Signature;\n}) => Promise<void>;\n\ntype CreateRecentSignatureConfirmationPromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetSignatureStatusesApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'devnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'testnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'mainnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<TCluster>): GetRecentSignatureConfirmationPromiseFn {\n    return async function getRecentSignatureConfirmationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        signature,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for status changes to a signature.\n         */\n        const signatureStatusNotifications = await rpcSubscriptions\n            .signatureNotifications(signature, { commitment })\n            .subscribe({ abortSignal: abortController.signal });\n        const signatureDidCommitPromise = (async () => {\n            for await (const signatureStatusNotification of signatureStatusNotifications) {\n                if (signatureStatusNotification.value.err) {\n                    throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);\n                } else {\n                    return;\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current status.\n         *         This will only yield a result if the signature is still in the status cache.\n         */\n        const signatureStatusLookupPromise = (async () => {\n            const { value: signatureStatusResults } = await rpc\n                .getSignatureStatuses([signature])\n                .send({ abortSignal: abortController.signal });\n            const signatureStatus = signatureStatusResults[0];\n            if (\n                signatureStatus &&\n                signatureStatus.confirmationStatus &&\n                commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0\n            ) {\n                return;\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await safeRace([signatureDidCommitPromise, signatureStatusLookupPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Commitment } from '@solana/rpc-types';\n\ntype Config = Readonly<{\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n}>;\n\nexport async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }: Config) {\n    return await new Promise((_, reject) => {\n        const handleAbort = (e: AbortSignalEventMap['abort']) => {\n            clearTimeout(timeoutId);\n            const abortError = new DOMException((e.target as AbortSignal).reason, 'AbortError');\n            reject(abortError);\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort);\n        const timeoutMs = commitment === 'processed' ? 30_000 : 60_000;\n        const startMs = performance.now();\n        const timeoutId =\n            // We use `setTimeout` instead of `AbortSignal.timeout()` because we want to measure\n            // elapsed time instead of active time.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static\n            setTimeout(() => {\n                const elapsedMs = performance.now() - startMs;\n                reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, 'TimeoutError'));\n            }, timeoutMs);\n    });\n}\n","import type { Signature } from '@solana/keys';\nimport { safeRace } from '@solana/promises';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { createRecentSignatureConfirmationPromiseFactory } from './confirmation-strategy-recent-signature';\n\nexport interface BaseTransactionConfirmationStrategyConfig {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    getRecentSignatureConfirmationPromise: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>;\n}\n\ntype WithNonNullableAbortSignal<T> = Omit<T, 'abortSignal'> & Readonly<{ abortSignal: AbortSignal }>;\n\nexport async function raceStrategies<TConfig extends BaseTransactionConfirmationStrategyConfig>(\n    signature: Signature,\n    config: TConfig,\n    getSpecificStrategiesForRace: (config: WithNonNullableAbortSignal<TConfig>) => readonly Promise<unknown>[],\n) {\n    const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;\n    callerAbortSignal?.throwIfAborted();\n    const abortController = new AbortController();\n    if (callerAbortSignal) {\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n    }\n    try {\n        const specificStrategies = getSpecificStrategiesForRace({\n            ...config,\n            abortSignal: abortController.signal,\n        });\n        return await safeRace([\n            getRecentSignatureConfirmationPromise({\n                abortSignal: abortController.signal,\n                commitment,\n                signature,\n            }),\n            ...specificStrategies,\n        ]);\n    } finally {\n        abortController.abort();\n    }\n}\n","import { Signature } from '@solana/keys';\nimport { getSignatureFromTransaction, Transaction } from '@solana/transactions';\nimport {\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions/dist/types/lifetime';\n\nimport { createBlockHeightExceedencePromiseFactory } from './confirmation-strategy-blockheight';\nimport { createNonceInvalidationPromiseFactory } from './confirmation-strategy-nonce';\nimport { BaseTransactionConfirmationStrategyConfig, raceStrategies } from './confirmation-strategy-racer';\nimport { getTimeoutPromise } from './confirmation-strategy-timeout';\n\ninterface WaitForDurableNonceTransactionConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getNonceInvalidationPromise: ReturnType<typeof createNonceInvalidationPromiseFactory>;\n    transaction: Readonly<Transaction & TransactionWithDurableNonceLifetime>;\n}\n\ninterface WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getBlockHeightExceedencePromise: ReturnType<typeof createBlockHeightExceedencePromiseFactory>;\n    transaction: Readonly<Transaction & TransactionWithBlockhashLifetime>;\n}\n\ninterface WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getTimeoutPromise: typeof getTimeoutPromise;\n    signature: Signature;\n}\n\nexport async function waitForDurableNonceTransactionConfirmation(\n    config: WaitForDurableNonceTransactionConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {\n            return [\n                getNonceInvalidationPromise({\n                    abortSignal,\n                    commitment,\n                    currentNonceValue: transaction.lifetimeConstraint.nonce,\n                    nonceAccountAddress: transaction.lifetimeConstraint.nonceAccountAddress,\n                }),\n            ];\n        },\n    );\n}\n\nexport async function waitForRecentTransactionConfirmation(\n    config: WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({\n            abortSignal,\n            commitment,\n            getBlockHeightExceedencePromise,\n            transaction,\n        }) {\n            return [\n                getBlockHeightExceedencePromise({\n                    abortSignal,\n                    commitment,\n                    lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight,\n                }),\n            ];\n        },\n    );\n}\n\n/** @deprecated */\nexport async function waitForRecentTransactionConfirmationUntilTimeout(\n    config: WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        config.signature,\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise }) {\n            return [\n                getTimeoutPromise({\n                    abortSignal,\n                    commitment,\n                }),\n            ];\n        },\n    );\n}\n","import { KeyPairSigner, Address, createKeyPairSignerFromBytes, address } from \"@solana/web3.js\";\r\nimport bs58 from \"bs58\";\r\nimport { IAgentRuntime } from \"@elizaos/core\";\r\nimport { TEEMode } from \"./TEE/types\"\r\nimport { DeriveKeyProvider } from \"./TEE/deriveKeyProvider\";\r\n\r\nexport interface WalletResult {\r\n    signer?: KeyPairSigner;\r\n    address?: Address;\r\n}\r\n\r\n/**\r\n * Gets either a keypair or public key based on TEE mode and runtime settings\r\n * @param runtime The agent runtime\r\n * @param requirePrivateKey Whether to return a full keypair (true) or just public key (false)\r\n * @returns KeypairResult containing either keypair or public key\r\n */\r\nexport async function loadWallet(\r\n    runtime: IAgentRuntime,\r\n    requirePrivateKey: boolean = true\r\n): Promise<WalletResult> {\r\n    const teeMode = runtime.getSetting(\"TEE_MODE\") || TEEMode.OFF;\r\n\r\n    if (teeMode !== TEEMode.OFF) {\r\n        const walletSecretSalt = runtime.getSetting(\"WALLET_SECRET_SALT\");\r\n        if (!walletSecretSalt) {\r\n            throw new Error(\r\n                \"WALLET_SECRET_SALT required when TEE_MODE is enabled\"\r\n            );\r\n        }\r\n\r\n        const deriveKeyProvider = new DeriveKeyProvider(teeMode);\r\n        const deriveKeyResult = await deriveKeyProvider.deriveEd25519Keypair(\r\n            \"/\",\r\n            walletSecretSalt,\r\n            runtime.agentId\r\n        );\r\n\r\n        return requirePrivateKey\r\n            ? { signer: deriveKeyResult.keypair }\r\n            : { address: deriveKeyResult.keypair.address };\r\n    }\r\n\r\n    // TEE mode is OFF\r\n    if (requirePrivateKey) {\r\n        const privateKeyString =\r\n            runtime.getSetting(\"SOLANA_PRIVATE_KEY\") ??\r\n            runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n\r\n        if (!privateKeyString) {\r\n            throw new Error(\"Private key not found in settings\");\r\n        }\r\n\r\n        try {\r\n            // First try base58\r\n            const secretKey = bs58.decode(privateKeyString);\r\n            return { signer: await createKeyPairSignerFromBytes(secretKey) };\r\n        } catch (e) {\r\n            console.log(\"Error decoding base58 private key:\", e);\r\n            try {\r\n                // Then try base64\r\n                console.log(\"Try decoding base64 instead\");\r\n                const secretKey = Uint8Array.from(\r\n                    Buffer.from(privateKeyString, \"base64\")\r\n                );\r\n                return { signer: await createKeyPairSignerFromBytes(secretKey) };\r\n            } catch (e2) {\r\n                console.error(\"Error decoding private key: \", e2);\r\n                throw new Error(\"Invalid private key format\");\r\n            }\r\n        }\r\n    } else {\r\n        const publicKeyString =\r\n            runtime.getSetting(\"SOLANA_PUBLIC_KEY\") ??\r\n            runtime.getSetting(\"WALLET_PUBLIC_KEY\");\r\n\r\n        if (!publicKeyString) {\r\n            throw new Error(\"Public key not found in settings\");\r\n        }\r\n\r\n        return { address: address(publicKeyString) };\r\n    }\r\n}\r\n","import { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\r\nimport { createKeyPairSignerFromBytes, createKeyPairSignerFromPrivateKeyBytes, KeyPairSigner } from \"@solana/web3.js\";\r\nimport crypto from \"crypto\";\r\nimport { TappdClient } from \"@phala/dstack-sdk\";\r\nimport { RemoteAttestationProvider } from \"./remoteAttestationProvider\";\r\nimport { TEEMode, RemoteAttestationQuote } from \"./types\";\r\n\r\ninterface DeriveKeyAttestationData {\r\n    agentId: string;\r\n    publicKey: string;\r\n}\r\n\r\nclass DeriveKeyProvider {\r\n    private client: TappdClient;\r\n    private raProvider: RemoteAttestationProvider;\r\n\r\n    constructor(teeMode?: string) {\r\n        let endpoint: string | undefined;\r\n\r\n        // Both LOCAL and DOCKER modes use the simulator, just with different endpoints\r\n        switch (teeMode) {\r\n            case TEEMode.LOCAL:\r\n                endpoint = \"http://localhost:8090\";\r\n                console.log(\r\n                    \"TEE: Connecting to local simulator at localhost:8090\"\r\n                );\r\n                break;\r\n            case TEEMode.DOCKER:\r\n                endpoint = \"http://host.docker.internal:8090\";\r\n                console.log(\r\n                    \"TEE: Connecting to simulator via Docker at host.docker.internal:8090\"\r\n                );\r\n                break;\r\n            case TEEMode.PRODUCTION:\r\n                endpoint = undefined;\r\n                console.log(\r\n                    \"TEE: Running in production mode without simulator\"\r\n                );\r\n                break;\r\n            default:\r\n                throw new Error(\r\n                    `Invalid TEE_MODE: ${teeMode}. Must be one of: LOCAL, DOCKER, PRODUCTION`\r\n                );\r\n        }\r\n\r\n        this.client = endpoint ? new TappdClient(endpoint) : new TappdClient();\r\n        this.raProvider = new RemoteAttestationProvider(teeMode);\r\n    }\r\n\r\n    private async generateDeriveKeyAttestation(\r\n        agentId: string,\r\n        publicKey: string\r\n    ): Promise<RemoteAttestationQuote> {\r\n        const deriveKeyData: DeriveKeyAttestationData = {\r\n            agentId,\r\n            publicKey,\r\n        };\r\n        const reportdata = JSON.stringify(deriveKeyData);\r\n        console.log(\"Generating Remote Attestation Quote for Derive Key...\");\r\n        const quote = await this.raProvider.generateAttestation(reportdata);\r\n        console.log(\"Remote Attestation Quote generated successfully!\");\r\n        return quote;\r\n    }\r\n\r\n    async deriveEd25519Keypair(\r\n        path: string,\r\n        subject: string,\r\n        agentId: string\r\n    ): Promise<{ keypair: KeyPairSigner; attestation: RemoteAttestationQuote }> {\r\n        try {\r\n            if (!path || !subject) {\r\n                console.error(\r\n                    \"Path and Subject are required for key derivation\"\r\n                );\r\n            }\r\n\r\n            console.log(\"Deriving Key in TEE...\");\r\n            const derivedKey = await this.client.deriveKey(path, subject);\r\n            const uint8ArrayDerivedKey = derivedKey.asUint8Array();\r\n\r\n            const hash = crypto.createHash(\"sha256\");\r\n            hash.update(uint8ArrayDerivedKey);\r\n            const seed = hash.digest();\r\n            const seedArray = new Uint8Array(seed);\r\n            const keypair = await createKeyPairSignerFromPrivateKeyBytes(seedArray.slice(0, 32));\r\n\r\n            // Generate an attestation for the derived key data for public to verify\r\n            const attestation = await this.generateDeriveKeyAttestation(\r\n                agentId,\r\n                keypair.address\r\n            );\r\n            console.log(\"Key Derived Successfully!\");\r\n\r\n            return { keypair, attestation };\r\n        } catch (error) {\r\n            console.error(\"Error deriving key:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\nconst deriveKeyProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, _message?: Memory, _state?: State) => {\r\n        const teeMode = runtime.getSetting(\"TEE_MODE\");\r\n        const provider = new DeriveKeyProvider(teeMode);\r\n        const agentId = runtime.agentId;\r\n        try {\r\n            // Validate wallet configuration\r\n            if (!runtime.getSetting(\"WALLET_SECRET_SALT\")) {\r\n                console.error(\r\n                    \"Wallet secret salt is not configured in settings\"\r\n                );\r\n                return \"\";\r\n            }\r\n\r\n            try {\r\n                const secretSalt =\r\n                    runtime.getSetting(\"WALLET_SECRET_SALT\") || \"secret_salt\";\r\n                const solanaKeypair = await provider.deriveEd25519Keypair(\r\n                    \"/\",\r\n                    secretSalt,\r\n                    agentId\r\n                );\r\n                return JSON.stringify({\r\n                    solana: solanaKeypair.keypair.address,\r\n                });\r\n            } catch (error) {\r\n                console.error(\"Error creating PublicKey:\", error);\r\n                return \"\";\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error in derive key provider:\", error.message);\r\n            return `Failed to fetch derive key information: ${error instanceof Error ? error.message : \"Unknown error\"}`;\r\n        }\r\n    },\r\n};\r\n\r\nexport { deriveKeyProvider, DeriveKeyProvider };\r\n","import { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\r\nimport { TdxQuoteResponse, TappdClient } from \"@phala/dstack-sdk\";\r\nimport { RemoteAttestationQuote, TEEMode } from \"./types\";\r\n\r\nclass RemoteAttestationProvider {\r\n    private client: TappdClient;\r\n\r\n    constructor(teeMode?: string) {\r\n        let endpoint: string | undefined;\r\n\r\n        // Both LOCAL and DOCKER modes use the simulator, just with different endpoints\r\n        switch (teeMode) {\r\n            case TEEMode.LOCAL:\r\n                endpoint = \"http://localhost:8090\";\r\n                console.log(\r\n                    \"TEE: Connecting to local simulator at localhost:8090\"\r\n                );\r\n                break;\r\n            case TEEMode.DOCKER:\r\n                endpoint = \"http://host.docker.internal:8090\";\r\n                console.log(\r\n                    \"TEE: Connecting to simulator via Docker at host.docker.internal:8090\"\r\n                );\r\n                break;\r\n            case TEEMode.PRODUCTION:\r\n                endpoint = undefined;\r\n                console.log(\r\n                    \"TEE: Running in production mode without simulator\"\r\n                );\r\n                break;\r\n            default:\r\n                throw new Error(\r\n                    `Invalid TEE_MODE: ${teeMode}. Must be one of: LOCAL, DOCKER, PRODUCTION`\r\n                );\r\n        }\r\n\r\n        this.client = endpoint ? new TappdClient(endpoint) : new TappdClient();\r\n    }\r\n\r\n    async generateAttestation(\r\n        reportData: string\r\n    ): Promise<RemoteAttestationQuote> {\r\n        try {\r\n            console.log(\"Generating attestation for: \", reportData);\r\n            const tdxQuote: TdxQuoteResponse =\r\n                await this.client.tdxQuote(reportData);\r\n            const rtmrs = tdxQuote.replayRtmrs();\r\n            console.log(\r\n                `rtmr0: ${rtmrs[0]}\\nrtmr1: ${rtmrs[1]}\\nrtmr2: ${rtmrs[2]}\\nrtmr3: ${rtmrs[3]}f`\r\n            );\r\n            const quote: RemoteAttestationQuote = {\r\n                quote: tdxQuote.quote,\r\n                timestamp: Date.now(),\r\n            };\r\n            console.log(\"Remote attestation quote: \", quote);\r\n            return quote;\r\n        } catch (error) {\r\n            console.error(\"Error generating remote attestation:\", error);\r\n            throw new Error(\r\n                `Failed to generate TDX Quote: ${\r\n                    error instanceof Error ? error.message : \"Unknown error\"\r\n                }`\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// Keep the original provider for backwards compatibility\r\nconst remoteAttestationProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, _message: Memory, _state?: State) => {\r\n        const teeMode = runtime.getSetting(\"TEE_MODE\");\r\n        const provider = new RemoteAttestationProvider(teeMode);\r\n        const agentId = runtime.agentId;\r\n\r\n        try {\r\n            console.log(\"Generating attestation for: \", agentId);\r\n            const attestation = await provider.generateAttestation(agentId);\r\n            return `Your Agent's remote attestation is: ${JSON.stringify(attestation)}`;\r\n        } catch (error) {\r\n            console.error(\"Error in remote attestation provider:\", error);\r\n            throw new Error(\r\n                `Failed to generate TDX Quote: ${\r\n                    error instanceof Error ? error.message : \"Unknown error\"\r\n                }`\r\n            );\r\n        }\r\n    },\r\n};\r\n\r\nexport { remoteAttestationProvider, RemoteAttestationProvider };\r\n","import {\r\n    elizaLogger,\r\n    Evaluator,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n    HandlerCallback,\r\n} from \"@elizaos/core\";\r\nimport { sendMessage } from \"../../utils/sendMessage\";\r\nimport { extractAndValidateConfiguration } from \"../../actions/orca/managePositions\";\r\n\r\nexport const managePositionActionRetriggerEvaluator: Evaluator = {\r\n    name: \"MANAGE_POSITIONS_RETRIGGER_EVALUATOR\",\r\n    similes: [\"MANAGE_POSITIONS_RETRIGGER\"],\r\n    alwaysRun: true,\r\n    description: \"Schedules and monitors ongoing repositioning actions to ensure continuous operation.\",\r\n    validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => true,\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        elizaLogger.log(\"Che\");\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n        const config = await extractAndValidateConfiguration(message.content.text, runtime);\r\n        if (!config || typeof config.intervalSeconds !== \"number\" || config.intervalSeconds <= 0) {\r\n            elizaLogger.debug(\r\n                \"Configuration is invalid, null, or does not have a valid positive value for intervalSeconds. Exiting evaluator.\"\r\n            );\r\n            return;\r\n        }\r\n        const instervalMs = config.intervalSeconds * 1000;\r\n        elizaLogger.log(`Using time threshold: ${instervalMs} miliseconds`);\r\n        await new Promise((resolve) => setTimeout(resolve, instervalMs));\r\n        sendMessage({\r\n            agentId: runtime.agentId,\r\n            text: message.content.text, // Reuse the original message text\r\n        });\r\n    },\r\n    examples: [],\r\n};","type TextResponse = {\r\n    text: string;\r\n    user: string;\r\n    attachments?: { url: string; contentType: string; title: string }[];\r\n};\r\n\r\nexport async function sendMessage({\r\n    agentId,\r\n    text,\r\n}: {\r\n    agentId: string;\r\n    text: string;\r\n}): Promise<TextResponse[]> {\r\n    if (!text.trim()) {\r\n        throw new Error(\"Message text is required.\");\r\n    }\r\n    const userId = \"user\";\r\n    const roomId = `default-room-${agentId}`;\r\n    const requestBody = {\r\n        text,\r\n        userId,\r\n        roomId,\r\n    };\r\n    try {\r\n        const BASE_URL = \"http://localhost:3000\";\r\n        const response = await fetch(`${BASE_URL}/${agentId}/message`, {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n            },\r\n            body: JSON.stringify(requestBody)\r\n        });\r\n        if (!response.ok) {\r\n            throw new Error(`Failed to send message: ${response.statusText}`);\r\n        }\r\n        const data = (await response.json()) as TextResponse[];\r\n        return data;\r\n    } catch (error) {\r\n        console.error(\"[sendMessage]:\", error);\r\n        throw error;\r\n    }\r\n}\r\n","import {\r\n    Action,\r\n    elizaLogger,\r\n    generateText,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    parseJSONObjectFromText,\r\n    settings,\r\n    State,\r\n} from \"@elizaos/core\";\r\nimport {\r\n    address,\r\n    createSolanaRpc,\r\n    KeyPairSigner,\r\n    Rpc,\r\n    SolanaRpcApi\r\n} from \"@solana/web3.js\";\r\nimport { fetchMint } from \"@solana-program/token-2022\";\r\nimport {\r\n    fetchPosition,\r\n    fetchWhirlpool,\r\n    getPositionAddress,\r\n} from \"@orca-so/whirlpools-client\";\r\nimport { sqrtPriceToPrice } from \"@orca-so/whirlpools-core\";\r\nimport { loadWallet } from \"../../utils/loadWallet\";\r\nimport { sendTransaction } from \"../../utils/sendTransaction\";\r\nimport {\r\n    closePositionInstructions,\r\n    IncreaseLiquidityQuoteParam,\r\n    openPositionInstructions,\r\n    setDefaultFunder,\r\n    setDefaultSlippageToleranceBps,\r\n} from \"@orca-so/whirlpools\";\r\n\r\nexport const managePositions: Action = {\r\n    name: 'manage_positions',\r\n    similes: [\"AUTOMATE_REBALANCING\", \"AUTOMATE_POSITIONS\", \"START_MANAGING_POSITIONS\"],\r\n    description: \"Automatically manage positions by rebalancing them when they drift too far from the pool price\",\r\n\r\n    validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {\r\n        const config = await extractAndValidateConfiguration(message.content.text, runtime);\r\n        if (!config) {\r\n            elizaLogger.warn(\"Validation failed: No valid configuration provided.\");\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        params: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        elizaLogger.log(\"Start managing positions\");\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n        const { repositionThresholdBps, slippageToleranceBps }: ManagePositionsInput = await extractAndValidateConfiguration(message.content.text, runtime);\r\n        const fetchedPositions = await extractFetchedPositions(state.providers, runtime);\r\n        elizaLogger.log(`Validated configuration: repositionThresholdBps=${repositionThresholdBps}, slippageTolerance=${slippageToleranceBps}`);\r\n        elizaLogger.log(\"Fetched positions:\", fetchedPositions);\r\n\r\n        const { signer: wallet } = await loadWallet(runtime, true);\r\n        const rpc = createSolanaRpc(settings.SOLANA_RPC_URL!);\r\n        setDefaultSlippageToleranceBps(slippageToleranceBps);\r\n        setDefaultFunder(wallet);\r\n\r\n        await handleRepositioning(\r\n            fetchedPositions,\r\n            repositionThresholdBps,\r\n            rpc,\r\n            wallet\r\n        );\r\n\r\n        return true;\r\n    },\r\n    examples: []\r\n};\r\n\r\ninterface FetchedPosition {\r\n    whirlpoolAddress: string;\r\n    positionMint: string;\r\n    inRange: boolean;\r\n    distanceCenterPositionFromPoolPriceBps: number;\r\n    positionWidthBps: number;\r\n}\r\n\r\ninterface NewPriceBounds {\r\n    newLowerPrice: number;\r\n    newUpperPrice: number;\r\n}\r\n\r\ninterface ManagePositionsInput {\r\n    repositionThresholdBps: number;\r\n    intervalSeconds: number;\r\n    slippageToleranceBps: number;\r\n}\r\n\r\nasync function extractFetchedPositions(\r\n    text: string,\r\n    runtime: IAgentRuntime\r\n): Promise<FetchedPosition[]> {\r\n    const prompt = `Given this message: \"${text}\", extract the available data and return a JSON object with the following structure:\r\n        [\r\n            {\r\n                \"whirlpoolAddress\": string,\r\n                \"positionMint\": string,\r\n                \"inRange\": boolean,\r\n                \"distanceCenterPositionFromPoolPriceBps\": number,\r\n                \"positionWidthBps\": number\r\n            },\r\n        ]\r\n    `;\r\n    const content = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.LARGE,\r\n    });\r\n    const fetchedPositions = parseJSONObjectFromText(content) as FetchedPosition[];\r\n    return fetchedPositions;\r\n}\r\n\r\nfunction validateManagePositionsInput(obj: Record<string, any>): ManagePositionsInput {\r\n    if (\r\n        typeof obj.repositionThresholdBps !== \"number\" ||\r\n        !Number.isInteger(obj.repositionThresholdBps) ||\r\n        typeof obj.intervalSeconds !== \"number\" ||\r\n        !Number.isInteger(obj.intervalSeconds) ||\r\n        typeof obj.slippageToleranceBps !== \"number\" ||\r\n        !Number.isInteger(obj.slippageToleranceBps)\r\n    ) {\r\n        throw new Error(\"Invalid input: Object does not match the ManagePositionsInput type.\");\r\n    }\r\n    return obj as ManagePositionsInput;\r\n}\r\n\r\nexport async function extractAndValidateConfiguration(\r\n    text: string,\r\n    runtime: IAgentRuntime\r\n): Promise<ManagePositionsInput | null> {\r\n    elizaLogger.log(\"Extracting and validating configuration from text:\", text);\r\n\r\n    const prompt = `Given this message: \"${text}\". Extract the reposition threshold value, time interval, and slippage tolerance.\r\n        The threshold value and the slippage tolerance can be given in percentages or bps. You will always respond with the reposition threshold in bps.\r\n        Very important: Add null values for each field that is not present in the message.\r\n        Return the response as a JSON object with the following structure:\r\n        {\r\n            \"repositionThresholdBps\": number (integer value),\r\n            \"intervalSeconds\": number (integer value),\r\n            \"slippageToleranceBps\": number (integer value)\r\n        }\r\n    `;\r\n\r\n    const content = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.SMALL,\r\n    });\r\n\r\n    try {\r\n        const configuration = parseJSONObjectFromText(content);\r\n        return validateManagePositionsInput(configuration);\r\n    } catch (error) {\r\n        elizaLogger.warn(\"Invalid configuration detected:\", error);\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction calculatePriceBounds(\r\n    sqrtPrice: bigint,\r\n    decimalsA: number,\r\n    decimalsB: number,\r\n    positionWidthBps: number\r\n): NewPriceBounds {\r\n    const currentPrice = sqrtPriceToPrice(sqrtPrice, decimalsA, decimalsB);\r\n    const newLowerPrice = currentPrice * (1 - positionWidthBps / 10000);\r\n    const newUpperPrice = currentPrice * (1 + positionWidthBps / 10000);\r\n\r\n    return { newLowerPrice, newUpperPrice };\r\n}\r\n\r\nasync function handleRepositioning(\r\n    fetchedPositions: FetchedPosition[],\r\n    repositionThresholdBps: number,\r\n    rpc: Rpc<SolanaRpcApi>,\r\n    wallet: KeyPairSigner\r\n) {\r\n    return await Promise.all(\r\n        fetchedPositions.map(async (position) => {\r\n            const { inRange, distanceCenterPositionFromPoolPriceBps } = position;\r\n            if (!inRange || distanceCenterPositionFromPoolPriceBps > repositionThresholdBps) {\r\n                const positionMintAddress = address(position.positionMint);\r\n                const positionAddress = (await getPositionAddress(positionMintAddress))[0];\r\n                let positionData = await fetchPosition(rpc, positionAddress);\r\n                const whirlpoolAddress = positionData.data.whirlpool;\r\n                let whirlpool = await fetchWhirlpool(rpc, whirlpoolAddress);\r\n                const mintA = await fetchMint(rpc, whirlpool.data.tokenMintA);\r\n                const mintB = await fetchMint(rpc, whirlpool.data.tokenMintB);\r\n                const newPriceBounds: NewPriceBounds = calculatePriceBounds(\r\n                    whirlpool.data.sqrtPrice,\r\n                    mintA.data.decimals,\r\n                    mintB.data.decimals,\r\n                    position.positionWidthBps\r\n                );\r\n                let newLowerPrice = newPriceBounds.newLowerPrice;\r\n                let newUpperPrice = newPriceBounds.newUpperPrice;\r\n\r\n                elizaLogger.log(`Repositioning position: ${positionMintAddress}`);\r\n\r\n                let closeSuccess = false;\r\n                let closeTxId;\r\n                while (!closeSuccess) {\r\n                    try {\r\n                        const { instructions: closeInstructions, quote } = await closePositionInstructions(\r\n                            rpc,\r\n                            positionMintAddress,\r\n                        );\r\n                        closeTxId = await sendTransaction(rpc, closeInstructions, wallet);\r\n                        closeSuccess = closeTxId ? true : false;\r\n\r\n                        // Prepare for open position\r\n                        const increaseLiquidityQuoteParam: IncreaseLiquidityQuoteParam = {\r\n                            liquidity: quote.liquidityDelta\r\n                        };\r\n                        whirlpool = await fetchWhirlpool(rpc, whirlpoolAddress);\r\n                        const newPriceBounds: NewPriceBounds = calculatePriceBounds(\r\n                            whirlpool.data.sqrtPrice,\r\n                            mintA.data.decimals,\r\n                            mintB.data.decimals,\r\n                            position.positionWidthBps\r\n                        );\r\n                        newLowerPrice = newPriceBounds.newLowerPrice;\r\n                        newUpperPrice = newPriceBounds.newUpperPrice;\r\n                        let openSuccess = false;\r\n                        let openTxId;\r\n                        while (!openSuccess) {\r\n                            try {\r\n                                const { instructions: openInstructions, positionMint: newPositionMint } = await openPositionInstructions(\r\n                                    rpc,\r\n                                    whirlpoolAddress,\r\n                                    increaseLiquidityQuoteParam,\r\n                                    newLowerPrice,\r\n                                    newUpperPrice\r\n                                );\r\n                                openTxId = await sendTransaction(rpc, openInstructions, wallet);\r\n                                openSuccess = openTxId ? true : false;\r\n\r\n                                elizaLogger.log(`Successfully reopened position with mint: ${newPositionMint}`);\r\n                                return { positionMintAddress, closeTxId, openTxId };\r\n                            } catch (openError) {\r\n                                elizaLogger.warn(\r\n                                    `Open position failed for ${positionMintAddress}, retrying. Error: ${openError}`\r\n                                );\r\n                                whirlpool = await fetchWhirlpool(rpc, whirlpoolAddress);\r\n                                const newPriceBounds: NewPriceBounds = calculatePriceBounds(\r\n                                    whirlpool.data.sqrtPrice,\r\n                                    mintA.data.decimals,\r\n                                    mintB.data.decimals,\r\n                                    position.positionWidthBps\r\n                                );\r\n                                newLowerPrice = newPriceBounds.newLowerPrice;\r\n                                newUpperPrice = newPriceBounds.newUpperPrice;\r\n                            }\r\n                        }\r\n                    } catch (closeError) {\r\n                        elizaLogger.warn(\r\n                            `Close position failed for ${positionMintAddress}, retrying after fetching new prices. Error: ${closeError}`\r\n                        );\r\n                        whirlpool = await fetchWhirlpool(rpc, whirlpoolAddress);\r\n                        const newPriceBounds: NewPriceBounds = calculatePriceBounds(\r\n                            whirlpool.data.sqrtPrice,\r\n                            mintA.data.decimals,\r\n                            mintB.data.decimals,\r\n                            position.positionWidthBps\r\n                        );\r\n                        newLowerPrice = newPriceBounds.newLowerPrice;\r\n                        newUpperPrice = newPriceBounds.newUpperPrice;\r\n                    }\r\n                }\r\n            } else {\r\n                elizaLogger.log(`Position ${address(position.positionMint)} is in range, skipping.`);\r\n                return null;\r\n            }\r\n        })\r\n    );\r\n}","import { elizaLogger } from '@elizaos/core';\r\nimport {\r\n  getSetComputeUnitLimitInstruction,\r\n  getSetComputeUnitPriceInstruction\r\n} from '@solana-program/compute-budget';\r\nimport {\r\n  appendTransactionMessageInstructions,\r\n  createTransactionMessage,\r\n  getBase64EncodedWireTransaction,\r\n  getComputeUnitEstimateForTransactionMessageFactory,\r\n  IInstruction,\r\n  KeyPairSigner,\r\n  pipe,\r\n  prependTransactionMessageInstructions,\r\n  Rpc,\r\n  setTransactionMessageFeePayer,\r\n  setTransactionMessageLifetimeUsingBlockhash,\r\n  signTransactionMessageWithSigners,\r\n  SolanaRpcApi\r\n} from '@solana/web3.js';\r\n\r\n// For more information: https://orca-so.github.io/whirlpools/Whirlpools%20SDKs/Whirlpools/Send%20Transaction\r\nexport async function sendTransaction(rpc: Rpc<SolanaRpcApi>, instructions: IInstruction[], wallet: KeyPairSigner): Promise<string> {\r\n  const latestBlockHash = await rpc.getLatestBlockhash().send();\r\n  const transactionMessage = await pipe(\r\n    createTransactionMessage({ version: 0 }),\r\n    tx => setTransactionMessageFeePayer(wallet.address, tx),\r\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockHash.value, tx),\r\n    tx => appendTransactionMessageInstructions(instructions, tx)\r\n  )\r\n  const getComputeUnitEstimateForTransactionMessage =\r\n    getComputeUnitEstimateForTransactionMessageFactory({\r\n      rpc: rpc\r\n    });\r\n  const computeUnitEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage)\r\n  const safeComputeUnitEstimate = Math.max(computeUnitEstimate * 1.3, computeUnitEstimate + 100_000);\r\n  const prioritizationFee = await rpc.getRecentPrioritizationFees()\r\n    .send()\r\n    .then(fees =>\r\n      fees\r\n        .map(fee => Number(fee.prioritizationFee))\r\n        .sort((a, b) => a - b)\r\n        [Math.ceil(0.95 * fees.length) - 1]\r\n    );\r\n  const transactionMessageWithComputeUnitInstructions = await prependTransactionMessageInstructions([\r\n    getSetComputeUnitLimitInstruction({ units: safeComputeUnitEstimate }),\r\n    getSetComputeUnitPriceInstruction({ microLamports: prioritizationFee })\r\n  ], transactionMessage);\r\n  const signedTransaction = await signTransactionMessageWithSigners(transactionMessageWithComputeUnitInstructions)\r\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\r\n\r\n  const timeoutMs = 90000;\r\n  const startTime = Date.now();\r\n  while (Date.now() - startTime < timeoutMs) {\r\n    const transactionStartTime = Date.now();\r\n    const signature = await rpc.sendTransaction(base64EncodedWireTransaction, {\r\n      maxRetries: 0n,\r\n      skipPreflight: true,\r\n      encoding: 'base64'\r\n    }).send();\r\n    const statuses = await rpc.getSignatureStatuses([signature]).send();\r\n    if (statuses.value[0]) {\r\n      if (!statuses.value[0].err) {\r\n        elizaLogger.log(`Transaction confirmed: ${signature}`);\r\n        return signature\r\n      } else {\r\n        throw new Error(`Transaction failed: ${statuses.value[0].err.toString()}`);\r\n      }\r\n    }\r\n    const elapsedTime = Date.now() - transactionStartTime;\r\n    const remainingTime = Math.max(0, 1000 - elapsedTime);\r\n    if (remainingTime > 0) {\r\n      await new Promise(resolve => setTimeout(resolve, remainingTime));\r\n    }\r\n  }\r\n  throw new Error('Transaction timeout');\r\n}\r\n","import { Plugin } from \"@elizaos/core\";\r\nimport { positionProvider } from \"./providers/orca/positionProvider\";\r\nimport { managePositionActionRetriggerEvaluator } from \"./evaluators/orca/repositionEvaluator\";\r\nimport { managePositions } from \"./actions/orca/managePositions\";\r\n\r\nexport const solanaPluginV2: Plugin = {\r\n    name: \"solanaV2\",\r\n    description: \"Solana Plugin V2 for Eliza\",\r\n    actions: [managePositions],\r\n    evaluators: [managePositionActionRetriggerEvaluator],\r\n    providers: [positionProvider],\r\n};\r\n\r\nexport default solanaPluginV2;"],"mappings":"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","names":["e","isSolanaError","ORDERED_ERROR_NAMES","SolanaError","SolanaError","SolanaError","alphabet","alphabet","alphabet","alphabet","createEncoder","createDecoder","TextDecoder","TextEncoder","address","SolanaError","SolanaError","base58Encoder","SolanaError","address","e","AccountRole","SolanaError","signature","privateKey","unwrapBigIntValueObject","wrapBigIntValueObject","pipe","SolanaError","e","normalizeHeaders","EXPLICIT_ABORT_TOKEN","createExplicitAbortToken","e","SolanaError","getAllowedNumericKeypaths","memoizedKeypaths","index_node_default","WebSocketImpl","createSolanaJsonRpcIntegerOverflowError","e","pipe","transformChannelInboundMessages","transformChannelOutboundMessages","cache","createEncoder","createDecoder","memoizedBase58Encoder","memoizedBase58Decoder","getMemoizedBase58Encoder","getMemoizedBase58Decoder","base58Encoder","SolanaError","combineCodec","newOffset","createEncoder","createDecoder","createDecoder","createEncoder","getEncodedSize","createDecoder","assertValidBaseString","alphabet","SolanaError","getBaseXEncoder","partitionLeadingZeroes","getBigIntFromBaseX","getBaseXDecoder","getBaseXFromBigInt","getBase58Encoder","getBase58Decoder","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","transformDecoder","address","TYPE","AccountRole","getAddressComparator","isWritableRole","isSignerRole","l","signature","getBytesEncoder","SolanaError","address","SolanaError","address","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","signature","transaction","TextEncoder","o","base58Decoder","SolanaError","signature","safeRace","e","getTimeoutPromise","lamports","getU32Encoder","e","l","getBase64EncodedWireTransaction","createRecentSignatureConfirmationPromiseFactory","crypto","TappdClient","TappdClient","crypto","e","e2","whirlpool","mintA","mintB","elizaLogger","elizaLogger","settings","fetchMint","fetchWhirlpool","sqrtPriceToPrice","elizaLogger","signature","elizaLogger","elizaLogger","settings","sqrtPriceToPrice","fetchWhirlpool","fetchMint","newPriceBounds","elizaLogger"]}