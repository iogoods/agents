{"version":3,"sources":["../src/actions/arbitrageAction.ts","../src/providers/marketProvider.ts","../src/config/thresholds.ts","../src/core/addresses.ts","../src/core/utils.ts","../src/core/Arbitrage.ts","../src/services/ArbitrageService.ts","../src/index.ts"],"names":["ServiceType","BigNumber","Wallet"],"mappings":";;;;;;;;;;AAGO,IAAM,sBAAiC,GAAA;AAAA,EAC1C,IAAM,EAAA,mBAAA;AAAA,EACN,OAAA,EAAS,CAAC,iBAAA,EAAmB,eAAe,CAAA;AAAA,EAC5C,WAAa,EAAA,yCAAA;AAAA,EAEb,QAAA,EAAU,OAAO,OAAA,EAAwB,QAAqB,KAAA;AAE1D,IAAO,OAAA,OAAA,CAAQ,UAAW,CAAA,4BAA4B,CAAM,KAAA,SAAA;AAAA,GAChE;AAAA,EAEA,OAAA,EAAS,OAAO,OAAA,EAAwB,QAAqB,KAAA;AACzD,IAAA,MAAM,OAAU,GAAA,OAAA,CAAQ,UAAW,CAAA,WAAA,CAAY,SAAS,CAAA;AACxD,IAAM,MAAA,OAAA,GAAU,MAAM,OAAA,CAAQ,eAAgB,EAAA;AAE9C,IAAI,IAAA,OAAA,CAAQ,SAAS,CAAG,EAAA;AACpB,MAAM,MAAA,OAAA,CAAQ,iBAAiB,OAAO,CAAA;AAAA;AAG1C,IAAO,OAAA,IAAA;AAAA,GACX;AAAA,EAEA,QAAU,EAAA;AAAA,IACN;AAAA,MACI;AAAA,QACI,IAAM,EAAA,WAAA;AAAA,QACN,OAAA,EAAS,EAAE,IAAA,EAAM,8BAA+B;AAAA,OACpD;AAAA,MACA;AAAA,QACI,IAAM,EAAA,WAAA;AAAA,QACN,OAAS,EAAA;AAAA,UACL,IAAM,EAAA,+BAAA;AAAA,UACN,MAAQ,EAAA;AAAA;AACZ;AACJ;AACJ;AAER,CAAA;ACnCO,IAAM,cAA2B,GAAA;AAAA,EACpC,GAAA,EAAK,OAAO,OAAA,EAAwB,QAA8C,KAAA;AAC9E,IAAA,MAAM,OAAU,GAAA,OAAA,CAAQ,UAAWA,CAAAA,WAAAA,CAAY,SAAS,CAAA;AACxD,IAAM,MAAA,OAAA,GAAU,MAAM,OAAA,CAAQ,eAAgB,EAAA;AAE9C,IAAO,OAAA;AAAA,MACH,eAAe,OAAQ,CAAA,MAAA;AAAA,MACvB,WAAa,EAAA,GAAA;AAAA;AAAA,MACb,UAAY,EAAA,iBAAA,IAAI,IAAK,EAAA,EAAE,WAAY,EAAA;AAAA,MACnC,SAAS;AAAC;AAAA,KACd;AAAA;AAER,CAAA;ACPO,IAAM,kBAAuC,GAAA;AAAA,EAChD,kBAAA,EAAoB,SAAU,CAAA,IAAA,CAAK,iBAAiB,CAAA;AAAA;AAAA,EACpD,YAAA,EAAc,SAAU,CAAA,IAAA,CAAK,qBAAqB,CAAA;AAAA;AAAA,EAClD,QAAU,EAAA,GAAA;AAAA,EACV,qBAAuB,EAAA;AAC3B,CAAA;;;ACdO,IAAM,YAAe,GAAA,4CAAA;ACGrB,IAAM,QAAQC,SAAU,CAAA,IAAA,CAAK,EAAE,CAAA,CAAE,IAAI,EAAE,CAAA;ACoBvC,IAAM,YAAN,MAAgB;AAAA;AAAA,EAMnB,WAAA,CACY,MACA,EAAA,iBAAA,EACA,sBACV,EAAA;AAHU,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,iBAAA,GAAA,iBAAA;AACA,IAAA,IAAA,CAAA,sBAAA,GAAA,sBAAA;AARZ,IAAA,IAAA,CAAQ,gBAAkE,EAAC;AAC3E,IAAA,IAAA,CAAQ,UAA+B,GAAA,kBAAA;AACvC,IAAA,IAAA,CAAQ,WAAc,GAAA,CAAA;AACtB,IAAA,IAAA,CAAQ,WAAc,GAAA,GAAA;AAAA;AAMnB,EAEH,MAAM,gBAAgB,cAAiE,EAAA;AACnF,IAAA,WAAA,CAAY,IAAI,+BAA+B,CAAA;AAC/C,IAAA,MAAM,gBAAwC,EAAC;AAE/C,IAAA,KAAA,MAAW,CAAC,YAAc,EAAA,OAAO,KAAK,MAAO,CAAA,OAAA,CAAQ,cAAc,CAAG,EAAA;AAElE,MAAA,MAAM,YAAe,GAAA,MAAM,IAAK,CAAA,kBAAA,CAAmB,SAAS,YAAY,CAAA;AAGxE,MAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,CAAa,QAAQ,CAAK,EAAA,EAAA;AAC1C,QAAA,KAAA,IAAS,IAAI,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,CAAa,QAAQ,CAAK,EAAA,EAAA;AAC9C,UAAM,MAAA,WAAA,GAAc,MAAM,IAAK,CAAA,yBAAA;AAAA,YAC3B,aAAa,CAAC,CAAA;AAAA,YACd,aAAa,CAAC,CAAA;AAAA,YACd;AAAA,WACJ;AACA,UAAA,IAAI,WAAa,EAAA;AACb,YAAA,aAAA,CAAc,KAAK,WAAW,CAAA;AAAA;AAClC;AACJ;AACJ;AAIJ,IAAA,OAAO,aAAc,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,CAAM,KAAA,CAAA,CAAE,MAAO,CAAA,GAAA,CAAI,CAAE,CAAA,MAAM,CAAE,CAAA,QAAA,EAAU,CAAA;AAAA;AACzE,EAEA,MAAc,kBAAmB,CAAA,OAAA,EAAsB,YAA4C,EAAA;AAC/F,IAAA,MAAM,eAA4B,EAAC;AACnC,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC1B,MAAI,IAAA;AACA,QAAA,MAAM,QAAW,GAAA,MAAM,MAAO,CAAA,WAAA,CAAY,YAAY,CAAA;AACtD,QAAA,IAAI,QAAS,CAAA,EAAA,CAAG,IAAK,CAAA,UAAA,CAAW,kBAAkB,CAAG,EAAA;AACjD,UAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAC5B,eACK,KAAO,EAAA;AACZ,QAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,sBAAA,EAAyB,MAAO,CAAA,aAAa,KAAK,KAAK,CAAA;AAAA;AACzE;AAEJ,IAAO,OAAA,YAAA;AAAA;AACX,EAEA,MAAc,yBAAA,CACV,OACA,EAAA,OAAA,EACA,YACoC,EAAA;AACpC,IAAI,IAAA;AAEA,MAAA,MAAM,SAAS,MAAM,OAAA,CAAQ,YAAa,CAAA,YAAA,EAAc,cAAc,KAAK,CAAA;AAC3E,MAAA,MAAM,SAAS,MAAM,OAAA,CAAQ,YAAa,CAAA,YAAA,EAAc,cAAc,KAAK,CAAA;AAG3E,MAAA,MAAM,CAAC,SAAA,EAAW,UAAU,CAAA,GAAI,OAAO,EAAG,CAAA,MAAM,CAC1C,GAAA,CAAC,OAAS,EAAA,OAAO,CACjB,GAAA,CAAC,SAAS,OAAO,CAAA;AAEvB,MAAM,MAAA,MAAA,GAAS,MAAO,CAAA,EAAA,CAAG,MAAM,CAAA,GACzB,MAAO,CAAA,GAAA,CAAI,MAAM,CAAA,GACjB,MAAO,CAAA,GAAA,CAAI,MAAM,CAAA;AAEvB,MAAA,IAAI,MAAO,CAAA,EAAA,CAAG,IAAK,CAAA,UAAA,CAAW,kBAAkB,CAAG,EAAA;AAE/C,QAAA,MAAM,SAAS,MAAM,IAAA,CAAK,uBAAuB,SAAW,EAAA,UAAA,EAAY,cAAc,MAAM,CAAA;AAE5F,QAAO,OAAA;AAAA,UACH,aAAa,CAAC;AAAA,YACV,aAAe,EAAA,SAAA;AAAA,YACf,YAAc,EAAA;AAAA,WACjB,CAAA;AAAA,UACD,MAAA;AAAA,UACA,MAAA;AAAA,UACA,YAAA;AAAA,UACA,aAAe,EAAA,SAAA;AAAA,UACf,YAAc,EAAA;AAAA,SAClB;AAAA;AACJ,aACK,KAAO,EAAA;AACZ,MAAQ,OAAA,CAAA,KAAA,CAAM,yCAAyC,KAAK,CAAA;AAAA;AAEhE,IAAO,OAAA,IAAA;AAAA;AACX,EAEA,MAAM,kBAAA,CACF,OACA,EAAA,YAAA,EACA,WACa,EAAA;AACb,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC1B,MAAA,KAAA,IAAS,OAAU,GAAA,CAAA,EAAG,OAAW,IAAA,WAAA,EAAa,OAAW,EAAA,EAAA;AACrD,QAAI,IAAA;AACA,UAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,qBAAA,CAAsB,QAAQ,YAAY,CAAA;AACzE,UAAA,IAAI,WAAa,EAAA;AACb,YAAA,WAAA,CAAY,GAAI,CAAA,CAAA,gCAAA,EAAmC,WAAY,CAAA,IAAI,CAAE,CAAA,CAAA;AAErE,YAAM,MAAA,WAAA,CAAY,KAAK,CAAC,CAAA;AACxB,YAAA;AAAA;AACJ,iBACK,KAAO,EAAA;AACZ,UAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,QAAA,EAAW,OAAO,CAAA,QAAA,CAAA,EAAY,KAAK,CAAA;AACjD,UAAA,IAAI,YAAY,WAAa,EAAA;AACzB,YAAQ,OAAA,CAAA,KAAA,CAAM,mCAAmC,MAAM,CAAA;AAAA,WACpD,MAAA;AACH,YAAA,MAAM,IAAI,OAAQ,CAAA,CAAA,CAAA,KAAK,WAAW,CAAG,EAAA,IAAA,CAAK,WAAW,CAAC,CAAA;AAAA;AAC1D;AACJ;AACJ;AACJ;AACJ,EAEA,MAAc,qBACV,CAAA,MAAA,EACA,WACmC,EAAA;AAEnC,IAAM,MAAA,QAAA,GAAW,MAAM,MAAA,CAAO,aAAc,CAAA,sBAAA;AAAA,MACxC,YAAA;AAAA,MACA,MAAO,CAAA,MAAA;AAAA,MACP,MAAO,CAAA;AAAA,KACX;AAGA,IAAM,MAAA,kBAAA,GAAqB,MAAM,MAAA,CAAO,aAAc,CAAA,YAAA;AAAA,MAClD,YAAA;AAAA,MACA,MAAO,CAAA,YAAA;AAAA,MACP,MAAO,CAAA;AAAA,KACX;AAGA,IAAM,MAAA,YAAA,GAAe,MAAM,MAAA,CAAO,YAAa,CAAA,UAAA;AAAA,MAC3C,MAAO,CAAA,YAAA;AAAA,MACP,kBAAA;AAAA,MACA,KAAK,sBAAuB,CAAA;AAAA,KAChC;AAGA,IAAA,MAAM,UAAU,CAAC,GAAG,SAAS,OAAS,EAAA,MAAA,CAAO,aAAa,aAAa,CAAA;AACvE,IAAA,MAAM,QAAW,GAAA,CAAC,GAAG,QAAA,CAAS,MAAM,YAAY,CAAA;AAGhD,IAAA,MAAM,cAAc,MAAO,CAAA,MAAA,CAAO,IAAI,EAAE,CAAA,CAAE,IAAI,GAAG,CAAA;AAGjD,IAAM,MAAA,MAAA,GAAS,MAAM,IAAK,CAAA,YAAA;AAAA,MACtB,MAAO,CAAA,MAAA;AAAA,MACP,WAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAO,OAAA,IAAA,CAAK,sBAAuB,CAAA,MAAA,EAAQ,WAAW,CAAA;AAAA;AAC1D,EAEA,MAAc,YACV,CAAA,MAAA,EACA,WACA,EAAA,OAAA,EACA,UACA,WACsB,EAAA;AAEtB,IAAM,MAAA,WAAA,GAAc,MAAM,IAAK,CAAA,qBAAA;AAAA,MAC3B,MAAA;AAAA,MACA,WAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,kBAAA,CAAmB,WAAW,CAAA;AAG1D,IAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,sBAAA,CAAuB,mBAAoB,CAAA,WAAA;AAAA,MACtE,MAAA;AAAA,MACA,WAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,MACA,EAAE,QAAU,EAAA,WAAA,EAAa,QAAS;AAAA,KACtC;AAGA,IAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,MAAA,CAAO,gBAAgB,WAAW,CAAA;AAG9D,IAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,iBAAA,CAAkB,QAAQ,CAAA;AAEzD,IAAA,OAAO,CAAC,WAAW,CAAA;AAAA;AACvB,EAEA,MAAc,qBAAA,CACV,MACA,EAAA,WAAA,EACA,SACA,QACkB,EAAA;AAClB,IAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,sBAAA,CAAuB,WAAY,CAAA,WAAA;AAAA,MAC3D,MAAA;AAAA,MACA,WAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACJ;AACA,IAAA,OAAO,QAAS,CAAA,GAAA,CAAI,GAAG,CAAA,CAAE,IAAI,GAAG,CAAA;AAAA;AACpC,EAEA,MAAc,mBAAmB,WAAyC,EAAA;AACtE,IAAM,MAAA,EAAE,iBAAiB,WAAY,EAAA,GAAI,MAAM,eAAgB,CAAA,IAAA,CAAK,OAAO,QAAoB,CAAA;AAC/F,IAAA,MAAM,SAAY,GAAA,eAAA,CAAgB,EAAG,CAAA,WAAW,IAAI,eAAkB,GAAA,WAAA;AACtE,IAAA,OAAO,SAAU,CAAA,GAAA,CAAI,GAAG,CAAA,CAAE,IAAI,GAAG,CAAA;AAAA;AACrC,EAEA,MAAc,sBACV,CAAA,MAAA,EACA,WACmC,EAAA;AACnC,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,aAAa,CAAK,EAAA,EAAA;AACvC,MAAI,IAAA;AAEA,QAAM,MAAA,IAAA,CAAK,cAAe,CAAA,MAAA,EAAQ,WAAW,CAAA;AAG7C,QAAM,MAAA,QAAA,GAAW,MAAM,IAAA,CAAK,iBAAkB,CAAA,UAAA;AAAA,UAC1C,MAAA,CAAO,IAAI,CAAU,KAAA,MAAA;AAAA,YACjB,mBAAmB,KAAM,CAAA,iBAAA;AAAA,YACzB,QAAQ,IAAK,CAAA,MAAA;AAAA,YACb,WAAa,EAAA;AAAA,cACT,IAAI,KAAM,CAAA,EAAA;AAAA,cACV,UAAU,KAAM,CAAA,GAAA;AAAA,cAChB,UAAU,KAAM,CAAA,SAAA;AAAA,cAChB,OAAO,KAAM,CAAA,KAAA;AAAA,cACb,MAAM,KAAM,CAAA;AAAA;AAChB,WACF,CAAA,CAAA;AAAA,UACF,WAAc,GAAA;AAAA,SAClB;AAEA,QAAA,IAAI,WAAW,QAAU,EAAA;AACrB,UAAA,MAAM,IAAI,KAAA,CAAM,QAAS,CAAA,KAAA,CAAM,OAAO,CAAA;AAAA;AAG1C,QAAO,OAAA,QAAA;AAAA,eACF,KAAO,EAAA;AACZ,QAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,yBAAA,EAA4B,CAAI,GAAA,CAAC,YAAY,KAAK,CAAA;AAChE,QAAA,IAAI,CAAM,KAAA,IAAA,CAAK,WAAc,GAAA,CAAA,EAAS,MAAA,KAAA;AACtC,QAAA,MAAM,IAAI,OAAQ,CAAA,CAAA,CAAA,KAAK,WAAW,CAAG,EAAA,IAAA,CAAK,WAAW,CAAC,CAAA;AAAA;AAC1D;AAEJ,IAAO,OAAA,IAAA;AAAA;AACX,EAEA,MAAc,kBAAkB,QAAwC,EAAA;AACpE,IAAA,MAAM,KAAK,MAAM,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,eAAe,QAAQ,CAAA;AAC7D,IAAI,IAAA,CAAC,IAAI,EAAM,IAAA,CAAC,IAAI,QAAY,IAAA,CAAC,IAAI,KAAO,EAAA;AACxC,MAAM,MAAA,IAAI,MAAM,qBAAqB,CAAA;AAAA;AAGzC,IAAO,OAAA;AAAA,MACH,IAAI,EAAG,CAAA,EAAA;AAAA,MACP,GAAA,EAAK,EAAG,CAAA,QAAA,CAAS,QAAS,EAAA;AAAA,MAC1B,SAAA,EAAW,EAAG,CAAA,QAAA,CAAS,QAAS,EAAA;AAAA,MAChC,KAAA,EAAO,EAAG,CAAA,KAAA,CAAM,QAAS,EAAA;AAAA,MACzB,OAAO,EAAG,CAAA,IAAA;AAAA,MACV,IAAA,EAAM,KAAK,MAAO,CAAA,OAAA;AAAA,MAClB,iBAAmB,EAAA,QAAA;AAAA,MACnB,MAAA,EAAQ,KAAK,MAAO,CAAA;AAAA,KACxB;AAAA;AACJ,EAEA,MAAc,cAAe,CAAA,MAAA,EAAuB,WAAoC,EAAA;AACpF,IAAA,MAAM,YAAe,GAAA,MAAA,CAAO,GAAI,CAAA,CAAA,KAAA,KAAS,MAAM,iBAAiB,CAAA;AAChE,IAAA,MAAM,aAAa,MAAM,IAAA,CAAK,iBAAkB,CAAA,QAAA,CAAS,cAAc,WAAW,CAAA;AAElF,IAAA,IAAI,WAAW,UAAY,EAAA;AACvB,MAAA,MAAM,IAAI,KAAM,CAAA,CAAA,mBAAA,EAAsB,UAAW,CAAA,KAAA,CAAM,OAAO,CAAE,CAAA,CAAA;AAAA;AAIpE,IAAA,MAAM,EAAE,cAAA,EAAgB,YAAc,EAAA,YAAA,EAAiB,GAAA,UAAA;AACvD,IAAM,MAAA,IAAA,GAAO,cAAe,CAAA,GAAA,CAAI,YAAY,CAAA;AAC5C,IAAM,MAAA,MAAA,GAAS,YAAa,CAAA,GAAA,CAAI,IAAI,CAAA;AAEpC,IAAA,IAAI,MAAO,CAAA,GAAA,CAAI,IAAK,CAAA,UAAA,CAAW,kBAAkB,CAAG,EAAA;AAChD,MAAM,MAAA,IAAI,MAAM,8BAA8B,CAAA;AAAA;AAClD;AACJ,EAEA,MAAM,gCAAA,CAAiC,MAAuB,EAAA,WAAA,EAAqB,SAA+B,EAAA;AAC9G,IAAY,WAAA,CAAA,GAAA,CAAI,CAAuD,oDAAA,EAAA,WAAW,CAAE,CAAA,CAAA;AAEpF,IAAI,IAAA;AAEA,MAAM,MAAA,EAAE,iBAAiB,WAAY,EAAA,GAAI,MAAM,eAAgB,CAAA,IAAA,CAAK,OAAO,QAAoB,CAAA;AAG/F,MAAM,MAAA,yBAAA,GAA4B,MAAM,gCAAA,CAAiC,SAAS,CAAA;AAClF,MAAI,IAAA,uBAAA,GAA0BA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AAG9C,MAAA,KAAA,MAAW,SAAS,yBAA2B,EAAA;AAC3C,QAAM,MAAA,YAAA,GAAeA,WAAU,CAAA,IAAA,CAAK,KAAK,CAAA;AACzC,QAAI,IAAA,YAAA,CAAa,EAAG,CAAA,uBAAuB,CAAG,EAAA;AAC1C,UAA0B,uBAAA,GAAA,YAAA;AAAA;AAC9B;AAIJ,MAAM,MAAA,gBAAA,GAAmB,MAAM,IAAK,CAAA,4BAAA;AAAA,QAChC,eAAA;AAAA,QACA,WAAA;AAAA,QACA;AAAA,OACJ;AAGA,MAAI,IAAA,gBAAA,CAAiB,GAAI,CAAA,eAAe,CAAG,EAAA;AACvC,QAAM,MAAA,IAAI,MAAM,uCAAuC,CAAA;AAAA;AAI3D,MAAM,MAAA,gBAAA,GAAmB,MAAM,cAAA,CAAe,gBAAgB,CAAA;AAC9D,MAAA,IAAI,CAAC,gBAAkB,EAAA;AACnB,QAAM,MAAA,IAAI,MAAM,oBAAoB,CAAA;AAAA;AAIxC,MAAA,MAAM,mBAAmB,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,GAAA,KAAQ,GAAI,CAAA;AACrD,MAAA,MAAM,eAAe,gBAAmB,GAAA,EAAA;AAGxC,MAAA,MAAM,oBAAoB,WAAc,GAAA,CAAA;AACxC,MAAM,MAAA,gBAAA,GAAmB,MAAM,IAAA,CAAK,iBAAkB,CAAA,UAAA;AAAA,QAClD,MAAA,CAAO,IAAI,CAAU,KAAA,MAAA;AAAA,UACjB,mBAAmB,KAAM,CAAA,iBAAA;AAAA,UACzB,QAAQ,IAAK,CAAA,MAAA;AAAA,UACb,WAAa,EAAA;AAAA,YACT,IAAI,KAAM,CAAA,EAAA;AAAA,YACV,UAAU,KAAM,CAAA,GAAA;AAAA,YAChB,UAAU,KAAM,CAAA,SAAA;AAAA,YAChB,OAAO,KAAM,CAAA,KAAA;AAAA,YACb,MAAM,KAAM,CAAA;AAAA;AAChB,SACF,CAAA,CAAA;AAAA,QACF,iBAAA;AAAA,QACA;AAAA,UACI,YAAc,EAAA,gBAAA;AAAA,UACd;AAAA;AACJ,OACJ;AAGA,MAAA,IAAI,WAAW,gBAAkB,EAAA;AAC7B,QAAA,MAAM,IAAI,KAAM,CAAA,CAAA,0BAAA,EAA6B,gBAAiB,CAAA,KAAA,CAAM,OAAO,CAAE,CAAA,CAAA;AAAA;AAGjF,MAAA,WAAA,CAAY,IAAI,gCAAkC,EAAA;AAAA,QAC9C,WAAa,EAAA,iBAAA;AAAA,QACb,gBAAA,EAAkB,iBAAiB,QAAS,EAAA;AAAA,QAC5C,YAAY,gBAAiB,CAAA;AAAA,OAChC,CAAA;AAAA,aAEI,KAAO,EAAA;AACZ,MAAQ,OAAA,CAAA,KAAA,CAAM,oDAAoD,KAAK,CAAA;AACvE,MAAM,MAAA,KAAA;AAAA;AACV;AACJ,EAEA,MAAc,4BAAA,CACV,eACA,EAAA,WAAA,EACA,uBACkB,EAAA;AAClB,IAAA,WAAA,CAAY,IAAI,gCAAkC,EAAA;AAAA,MAC9C,OAAA,EAAS,gBAAgB,QAAS,EAAA;AAAA,MAClC,OAAA,EAAS,YAAY,QAAS,EAAA;AAAA,MAC9B,SAAA,EAAW,wBAAwB,QAAS;AAAA,KAC/C,CAAA;AAGD,IAAA,IAAI,gBAAmB,GAAA,eAAA;AACvB,IAAI,IAAA,WAAA,CAAY,EAAG,CAAA,gBAAgB,CAAG,EAAA;AAClC,MAAmB,gBAAA,GAAA,WAAA;AAAA;AAEvB,IAAI,IAAA,uBAAA,CAAwB,EAAG,CAAA,gBAAgB,CAAG,EAAA;AAC9C,MAAmB,gBAAA,GAAA,uBAAA;AAAA;AAIvB,IAAA,MAAM,UAAU,gBAAiB,CAAA,GAAA,CAAI,EAAE,CAAA,CAAE,IAAI,GAAG,CAAA;AAChD,IAAmB,gBAAA,GAAA,gBAAA,CAAiB,IAAI,OAAO,CAAA;AAE/C,IAAA,WAAA,CAAY,GAAI,CAAA,qBAAA,EAAuB,gBAAiB,CAAA,QAAA,EAAU,CAAA;AAClE,IAAO,OAAA,gBAAA;AAAA;AACX,EAEA,MAAc,sBAAA,CACV,aACA,EAAA,YAAA,EACA,cACA,MACkB,EAAA;AAClB,IAAA,WAAA,CAAY,IAAI,iCAAiC,CAAA;AAGjD,IAAA,MAAM,qBAAwB,GAAA,MAAM,aAAc,CAAA,WAAA,CAAY,YAAY,CAAA;AAC1E,IAAA,MAAM,sBAAyB,GAAA,MAAM,YAAa,CAAA,WAAA,CAAY,YAAY,CAAA;AAG1E,IAAM,MAAA,YAAA,GAAeA,WAAU,CAAA,IAAA,CAAK,GAAM,CAAA;AAG1C,IAAA,MAAM,cAAiB,GAAA,MAAM,aAAc,CAAA,cAAA,CAAe,cAAc,YAAY,CAAA;AACpF,IAAA,MAAM,eAAkB,GAAA,MAAM,YAAa,CAAA,cAAA,CAAe,cAAc,YAAY,CAAA;AAEpF,IAAA,MAAM,aAAgB,GAAA,MAAM,aAAc,CAAA,aAAA,CAAc,YAAY,CAAA;AACpE,IAAA,MAAM,cAAiB,GAAA,MAAM,YAAa,CAAA,aAAA,CAAc,YAAY,CAAA;AAGpE,IAAI,IAAA,IAAA,GAAOA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AAC3B,IAAA,IAAI,KAAQ,GAAA,YAAA;AACZ,IAAI,IAAA,aAAA,GAAgBA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AACpC,IAAI,IAAA,iBAAA,GAAoBA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AAExC,IAAO,OAAA,IAAA,CAAK,EAAG,CAAA,KAAK,CAAG,EAAA;AACnB,MAAA,MAAM,MAAM,IAAK,CAAA,GAAA,CAAI,KAAK,CAAA,CAAE,IAAI,CAAC,CAAA;AAGjC,MAAM,MAAA,cAAA,GAAiB,MAClB,CAAA,GAAA,CAAI,GAAG,CAAA,CACP,GAAI,CAAA,cAAA,CAAe,GAAI,CAAA,GAAG,CAAC,CAAA,CAC3B,GAAI,CAAA,eAAA,CAAgB,GAAI,CAAA,GAAG,CAAC,CAAA,CAC5B,GAAI,CAAA,aAAA,CAAc,GAAI,CAAA,GAAG,CAAC,CAAA,CAC1B,GAAI,CAAA,cAAA,CAAe,GAAI,CAAA,GAAG,CAAC,CAAA;AAEhC,MAAI,IAAA,cAAA,CAAe,GAAG,iBAAiB,CAAA,IAAK,eAAe,GAAI,CAAA,IAAA,CAAK,UAAW,CAAA,kBAAkB,CAAG,EAAA;AAChG,QAAoB,iBAAA,GAAA,cAAA;AACpB,QAAgB,aAAA,GAAA,GAAA;AAChB,QAAO,IAAA,GAAA,GAAA,CAAI,IAAI,CAAC,CAAA;AAAA,OACb,MAAA;AACH,QAAQ,KAAA,GAAA,GAAA,CAAI,IAAI,CAAC,CAAA;AAAA;AACrB;AAIJ,IAAgBA,aAAAA,GAAAA,WAAAA,CAAU,KAAK,IAAK,CAAA,GAAA;AAAA,MAChC,cAAc,QAAS,EAAA;AAAA,MACvB,sBAAsB,QAAS,EAAA;AAAA,MAC/B,uBAAuB,QAAS;AAAA,KACnC,CAAA;AAED,IAAY,WAAA,CAAA,GAAA,CAAI,CAA2C,wCAAA,EAAA,aAAa,CAAE,CAAA,CAAA;AAC1E,IAAO,OAAA,aAAA;AAAA;AAEf,CAAA;AAGA,eAAe,eAAe,SAAwC,EAAA;AAClE,EAAM,MAAA,OAAA,GAAU,SAAU,CAAA,GAAA,CAAI,IAAK,CAAA;AACnC,EAAA,WAAA,CAAY,GAAI,CAAA,CAAA,4BAAA,EAA+B,SAAS,CAAA,YAAA,EAAe,OAAO,CAAE,CAAA,CAAA;AAChF,EAAO,OAAA,OAAA;AACX;AAEA,eAAsB,iCAAiC,SAAuE,EAAA;AAC1H,EAAA,WAAA,CAAY,IAAI,2CAA2C,CAAA;AAC3D,EAAM,MAAA,YAAA,GAAe,MAAM,SAAA,CAAU,eAAgB,EAAA;AACrD,EAAA,MAAM,4BAA4B,YAAa,CAAA,GAAA,CAAI,CAAC,KAAA,KAAoC,MAAM,cAAc,CAAA;AAC5G,EAAY,WAAA,CAAA,GAAA,CAAI,CAAiE,8DAAA,EAAA,yBAAyB,CAAE,CAAA,CAAA;AAC5G,EAAO,OAAA,yBAAA;AACX;AAEA,eAAsB,gBAAgB,QAGnC,EAAA;AACC,EAAM,MAAA,OAAA,GAAU,MAAM,QAAA,CAAS,UAAW,EAAA;AAC1C,EAAA,MAAM,eAAkB,GAAA,OAAA,CAAQ,QAAYA,IAAAA,WAAAA,CAAU,KAAK,CAAC,CAAA;AAG5D,EAAA,MAAM,KAAQ,GAAA,MAAM,QAAS,CAAA,QAAA,CAAS,QAAQ,CAAA;AAC9C,EAAA,MAAM,SAAsB,EAAC;AAC7B,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,CAAA,EAAG,CAAK,EAAA,EAAA;AACxB,IAAA,MAAM,kBAAkB,MAAM,QAAA,CAAS,QAAS,CAAA,KAAA,CAAM,SAAS,CAAC,CAAA;AAChE,IAAA,IAAI,gBAAgB,aAAe,EAAA;AAC/B,MAAO,MAAA,CAAA,IAAA,CAAK,gBAAgB,aAAa,CAAA;AAAA;AAC7C;AAGJ,EAAA,MAAM,cAAc,MAAO,CAAA,MAAA,GAAS,CAC9B,GAAA,MAAA,CAAO,OAAO,CAAC,CAAA,EAAG,CAAM,KAAA,CAAA,CAAE,IAAI,CAAC,CAAC,EAAE,GAAI,CAAA,MAAA,CAAO,MAAM,CACnD,GAAA,eAAA;AAEN,EAAO,OAAA,EAAE,iBAAiB,WAAY,EAAA;AAC1C;AC1fO,IAAM,gBAAA,GAAN,cAA+B,OAAQ,CAAA;AAAA,EAAvC,WAAA,GAAA;AAAA,IAAA,KAAA,CAAA,GAAA,SAAA,CAAA;AACH,IAAA,IAAA,CAAQ,SAA8B,GAAA,IAAA;AACtC,IAAA,IAAA,CAAQ,YAAiC,GAAA,IAAA;AACzC,IAAA,IAAA,CAAQ,iBAAiB,EAAC;AAC1B,IAAA,IAAA,CAAQ,YAAe,GAAA,CAAA;AAAA;AAAA,EAGvB,WAAW,WAA2B,GAAA;AAClC,IAAA,OAAOD,WAAY,CAAA,SAAA;AAAA;AACvB,EAEA,IAAI,WAA2B,GAAA;AAC3B,IAAA,OAAOA,WAAY,CAAA,SAAA;AAAA;AACvB;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,OAAuC,EAAA;AACpD,IAAA,IAAA,CAAK,OAAU,GAAA,OAAA;AAGf,IAAI,IAAA,KAAA,GAAQ,OAAQ,CAAA,UAAA,CAAW,2BAA2B,CAAA;AAE1D,IAAI,IAAA,MAAA,GAAS,OAAQ,CAAA,UAAA,CAAW,4BAA4B,CAAA;AAI5D,IAAA,OAAA,CAAQ,IAAI,qCAAuC,EAAA;AAAA,MAC/C,KAAA;AAAA,MACA;AAAA,KACH,CAAA;AAED,IAAI,IAAA,CAAC,KAAS,IAAA,CAAC,MAAQ,EAAA;AACnB,MAAM,MAAA,IAAI,MAAM,4EAA4E,CAAA;AAAA;AAIhG,IAAI,IAAA,CAAC,SAAS,MAAQ,EAAA;AAClB,MAAQ,KAAA,GAAA,MAAA,CAAO,OAAQ,CAAA,UAAA,EAAY,QAAQ,CAAA;AAC3C,MAAQ,OAAA,CAAA,GAAA,CAAI,gCAAgC,KAAK,CAAA;AAAA;AAGrD,IAAA,IAAI,CAAC,KAAO,EAAA;AACR,MAAM,MAAA,IAAI,MAAM,gDAAgD,CAAA;AAAA;AAIpE,IAAM,MAAA,SAAA,GAAY,OAAQ,CAAA,UAAA,CAAW,2BAA2B,CAAA;AAChE,IAAA,IAAI,CAAC,SAAA,EAAiB,MAAA,IAAI,MAAM,uCAAuC,CAAA;AAGvE,IAAQ,OAAA,CAAA,GAAA,CAAI,4CAA4C,KAAK,CAAA;AAC7D,IAAM,MAAA,QAAA,GAAW,IAAI,iBAAA,CAAkB,KAAe,CAAA;AACtD,IAAA,MAAM,MAAS,GAAA,IAAIE,MAAO,CAAA,SAAA,EAAW,QAAQ,CAAA;AAG7C,IAAM,MAAA,YAAA,GAAe,OAAQ,CAAA,UAAA,CAAW,6BAA6B,CAAA;AACrE,IAAA,IAAI,CAAC,YAAA,EAAoB,MAAA,IAAI,MAAM,yCAAyC,CAAA;AAE5E,IAAM,MAAA,iBAAA,GAAoB,MAAM,uBAAwB,CAAA,MAAA;AAAA,MACpD,QAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAM,MAAA,qBAAA,GAAwB,OAAQ,CAAA,UAAA,CAAW,yBAAyB,CAAA;AAC1E,IAAA,IAAI,CAAC,qBAAA,EAA6B,MAAA,IAAI,MAAM,qCAAqC,CAAA;AAGjF,IAAA,MAAM,yBAAyB,IAAI,QAAA;AAAA,MAC/B,qBAAA;AAAA,MACA;AAAA,QACI,2DAAA;AAAA,QACA;AAAA,OACJ;AAAA,MACA;AAAA,KACJ;AAGA,IAAA,IAAA,CAAK,YAAY,IAAI,SAAA;AAAA,MACjB,MAAA;AAAA,MACA,iBAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAQ,OAAA,CAAA,GAAA,CAAI,uCAAuC,KAAK,CAAA;AACxD,IAAK,IAAA,CAAA,YAAA,GAAe,IAAI,SAAA,CAAU,KAAK,CAAA;AACvC,IAAA,IAAA,CAAK,sBAAuB,EAAA;AAAA;AAChC,EAEQ,sBAA+B,GAAA;AACnC,IAAI,IAAA,CAAC,KAAK,YAAc,EAAA;AAExB,IAAK,IAAA,CAAA,YAAA,CAAa,EAAG,CAAA,MAAA,EAAQ,MAAM;AAC/B,MAAA,OAAA,CAAQ,IAAI,kCAAkC,CAAA;AAE9C,MAAK,IAAA,CAAA,YAAA,EAAc,IAAK,CAAA,IAAA,CAAK,SAAU,CAAA;AAAA,QACnC,OAAS,EAAA,KAAA;AAAA,QACT,EAAI,EAAA,CAAA;AAAA,QACJ,MAAQ,EAAA,eAAA;AAAA,QACR,MAAA,EAAQ,CAAC,UAAU;AAAA,OACtB,CAAC,CAAA;AAAA,KACL,CAAA;AAED,IAAA,IAAA,CAAK,YAAa,CAAA,EAAA,CAAG,SAAW,EAAA,OAAO,IAAiB,KAAA;AACpD,MAAM,MAAA,OAAA,GAAU,IAAK,CAAA,KAAA,CAAM,IAAI,CAAA;AAC/B,MAAI,IAAA,OAAA,CAAQ,MAAQ,EAAA,MAAA,EAAQ,MAAQ,EAAA;AAChC,QAAA,IAAA,CAAK,eAAe,MAAO,CAAA,QAAA,CAAS,QAAQ,MAAO,CAAA,MAAA,CAAO,QAAQ,EAAE,CAAA;AAAA;AACxE,KACH,CAAA;AAED,IAAA,IAAA,CAAK,YAAa,CAAA,EAAA,CAAG,OAAS,EAAA,CAAC,KAAU,KAAA;AACrC,MAAQ,OAAA,CAAA,KAAA,CAAM,oBAAoB,KAAK,CAAA;AAAA,KAC1C,CAAA;AAED,IAAK,IAAA,CAAA,YAAA,CAAa,EAAG,CAAA,OAAA,EAAS,MAAM;AAChC,MAAA,OAAA,CAAQ,IAAI,6BAA6B,CAAA;AAEzC,MAAA,UAAA,CAAW,MAAM,IAAK,CAAA,UAAA,CAAW,IAAK,CAAA,OAAO,GAAG,GAAI,CAAA;AAAA,KACvD,CAAA;AAAA;AACL,EAEA,MAAM,eAAmD,GAAA;AACrD,IAAA,IAAI,CAAC,IAAK,CAAA,SAAA,EAAiB,MAAA,IAAI,MAAM,kCAAkC,CAAA;AACvE,IAAA,OAAO,IAAK,CAAA,SAAA,CAAU,eAAgB,CAAA,IAAA,CAAK,cAAc,CAAA;AAAA;AAC7D,EAEA,MAAM,iBAAiB,OAAgD,EAAA;AACnE,IAAA,IAAI,CAAC,IAAK,CAAA,SAAA,EAAiB,MAAA,IAAI,MAAM,kCAAkC,CAAA;AACvE,IAAA,MAAM,WAAc,GAAA,EAAA;AACpB,IAAA,OAAO,KAAK,SAAU,CAAA,kBAAA,CAAmB,OAAS,EAAA,IAAA,CAAK,cAAc,WAAW,CAAA;AAAA;AACpF,EAEA,MAAM,IAAsB,GAAA;AACxB,IAAA,IAAI,KAAK,YAAc,EAAA;AACnB,MAAA,IAAA,CAAK,aAAa,KAAM,EAAA;AACxB,MAAA,IAAA,CAAK,YAAe,GAAA,IAAA;AAAA;AACxB;AAER,CAAA;;;AC9JA,IAAM,gBAAA,GAAmB,IAAI,gBAAiB,EAAA;AAE9C,IAAM,eAA0B,GAAA;AAAA,EAC5B,IAAM,EAAA,kBAAA;AAAA,EACN,WAAa,EAAA,oCAAA;AAAA,EACb,OAAA,EAAS,CAAC,sBAAsB,CAAA;AAAA,EAChC,SAAA,EAAW,CAAC,cAAc,CAAA;AAAA,EAC1B,QAAA,EAAU,CAAC,gBAAgB;AAC/B,CAAA;AAEA,IAAO,aAAQ,GAAA","file":"index.mjs","sourcesContent":["import { Action, IAgentRuntime, Memory, ServiceType } from \"@elizaos/core\";\r\nimport { ArbitrageService } from \"../services/ArbitrageService\";\r\n\r\nexport const executeArbitrageAction: Action = {\r\n    name: \"EXECUTE_ARBITRAGE\",\r\n    similes: [\"TRADE_ARBITRAGE\", \"RUN_ARBITRAGE\"],\r\n    description: \"Execute arbitrage trades across markets\",\r\n\r\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\r\n        // Validate settings are present\r\n        return runtime.getSetting(\"arbitrage.walletPrivateKey\") !== undefined;\r\n    },\r\n\r\n    handler: async (runtime: IAgentRuntime, _message: Memory) => {\r\n        const service = runtime.getService(ServiceType.ARBITRAGE) as ArbitrageService;\r\n        const markets = await service.evaluateMarkets();\r\n\r\n        if (markets.length > 0) {\r\n            await service.executeArbitrage(markets);\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Find arbitrage opportunities\" }\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Scanning for arbitrage trades\",\r\n                    action: \"EXECUTE_ARBITRAGE\"\r\n                }\r\n            }\r\n        ]\r\n    ]\r\n};","import { Provider, IAgentRuntime, Memory, ServiceType } from \"@elizaos/core\";\r\nimport { ArbitrageService } from \"../services/ArbitrageService\";\r\nimport { ArbitrageState } from \"../type\";\r\n\r\nexport const marketProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, _message: Memory): Promise<ArbitrageState> => {\r\n        const service = runtime.getService(ServiceType.ARBITRAGE) as ArbitrageService;\r\n        const markets = await service.evaluateMarkets();\r\n\r\n        return {\r\n            opportunities: markets.length,\r\n            totalProfit: \"0\", // Calculate total profit\r\n            lastUpdate: new Date().toISOString(),\r\n            markets: {}  // This will be populated by the service\r\n        };\r\n    }\r\n};","import { BigNumber } from \"ethers\";\r\n\r\nexport interface MarketThresholds {\r\n    minProfitThreshold: BigNumber;\r\n    maxTradeSize: BigNumber;\r\n    gasLimit: number;\r\n    minerRewardPercentage: number;\r\n}\r\n\r\nexport const DEFAULT_THRESHOLDS: MarketThresholds = {\r\n    minProfitThreshold: BigNumber.from(\"100000000000000\"), // 0.0001 ETH\r\n    maxTradeSize: BigNumber.from(\"1000000000000000000\"), // 1 ETH\r\n    gasLimit: 500000,\r\n    minerRewardPercentage: 90\r\n};","export const WETH_ADDRESS = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\r\n\r\n// Uniswap V2 Factory addresses for major DEXes\r\nexport const FACTORY_ADDRESSES = {\r\n    UNISWAP: \"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\",\r\n    SUSHISWAP: \"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\",\r\n    SHIBASWAP: \"0x115934131916C8b277DD010Ee02de363c09d037c\"\r\n};\r\n\r\n// Uniswap lookup contract for price checks\r\nexport const UNISWAP_LOOKUP_CONTRACT_ADDRESS = \"0x5EF1009b9FCD4fec3094a5564047e190D72Bd511\";","import { BigNumber, Wallet } from \"ethers\";\r\n\r\n// Constants\r\nexport const ETHER = BigNumber.from(10).pow(18);\r\nexport const DEFAULT_GAS_LIMIT = 250000;\r\n\r\n// Math utilities\r\nexport function bigNumberToDecimal(value: BigNumber, base = 18): number {\r\n    const divisor = BigNumber.from(10).pow(base);\r\n    return value.mul(10000).div(divisor).toNumber() / 10000;\r\n}\r\n\r\n// Authentication utilities\r\nexport const getDefaultRelaySigningKey = (): string => {\r\n    console.warn(\r\n        \"No FLASHBOTS_RELAY_SIGNING_KEY specified. Creating temporary key...\"\r\n    );\r\n    return Wallet.createRandom().privateKey;\r\n};\r\n\r\n// Add error handling utilities\r\nexport const handleArbitrageError = (error: Error): void => {\r\n    console.error(`Arbitrage Error: ${error.message}`);\r\n    // Add any specific error handling logic\r\n};","import { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { Contract } from \"@ethersproject/contracts\";\r\nimport { Provider, TransactionResponse } from \"@ethersproject/providers\";\r\nimport { Wallet } from \"@ethersproject/wallet\";\r\nimport { FlashbotsBundleProvider } from \"@flashbots/ethers-provider-bundle\";\r\nimport { DEFAULT_THRESHOLDS, MarketThresholds } from '../config/thresholds';\r\nimport { WETH_ADDRESS } from \"./addresses\";\r\nimport { EthMarket } from \"./EthMarket\";\r\nimport { CrossedMarketDetails, MarketsByToken, MarketType } from \"./types\";\r\nimport { ETHER } from \"./utils\";\r\nimport { elizaLogger } from \"@elizaos/core\";\r\n\r\nexport interface BundleEntry {\r\n  to: string;\r\n  gas: number;\r\n  gas_price: string;\r\n  value: number;\r\n  input: string;\r\n  from: string;\r\n  signedTransaction: string;\r\n  signer: string;\r\n}\r\n\r\nexport class Arbitrage {\r\n    private bundleEntries: { bundle: BundleEntry[], blockNumber: number }[] = [];\r\n    private thresholds: MarketThresholds = DEFAULT_THRESHOLDS;\r\n    private MAX_RETRIES = 3;\r\n    private RETRY_DELAY = 1000; // 1 second\r\n\r\n    constructor(\r\n        private wallet: Wallet,\r\n        private flashbotsProvider: FlashbotsBundleProvider,\r\n        private bundleExecutorContract: Contract\r\n    ) {}\r\n\r\n    async evaluateMarkets(marketsByToken: MarketsByToken): Promise<CrossedMarketDetails[]> {\r\n        elizaLogger.log(\"Starting market evaluation...\");\r\n        const opportunities: CrossedMarketDetails[] = [];\r\n\r\n        for (const [tokenAddress, markets] of Object.entries(marketsByToken)) {\r\n            // Filter out markets with insufficient liquidity\r\n            const validMarkets = await this.filterValidMarkets(markets, tokenAddress);\r\n            \r\n            // Compare each market pair for arbitrage opportunities\r\n            for (let i = 0; i < validMarkets.length; i++) {\r\n                for (let j = i + 1; j < validMarkets.length; j++) {\r\n                    const opportunity = await this.checkArbitrageOpportunity(\r\n                        validMarkets[i],\r\n                        validMarkets[j],\r\n                        tokenAddress\r\n                    );\r\n                    if (opportunity) {\r\n                        opportunities.push(opportunity);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sort opportunities by profit\r\n        return opportunities.sort((a, b) => b.profit.sub(a.profit).toNumber());\r\n    }\r\n\r\n    private async filterValidMarkets(markets: EthMarket[], tokenAddress: string): Promise<EthMarket[]> {\r\n        const validMarkets: EthMarket[] = [];\r\n        for (const market of markets) {\r\n            try {\r\n                const reserves = await market.getReserves(tokenAddress);\r\n                if (reserves.gt(this.thresholds.minProfitThreshold)) {\r\n                    validMarkets.push(market);\r\n                }\r\n            } catch (error) {\r\n                console.error(`Error checking market ${market.marketAddress}:`, error);\r\n            }\r\n        }\r\n        return validMarkets;\r\n    }\r\n\r\n    private async checkArbitrageOpportunity(\r\n        market1: EthMarket,\r\n        market2: EthMarket,\r\n        tokenAddress: string\r\n    ): Promise<CrossedMarketDetails | null> {\r\n        try {\r\n            // Get prices from both markets\r\n            const price1 = await market1.getTokensOut(WETH_ADDRESS, tokenAddress, ETHER);\r\n            const price2 = await market2.getTokensOut(WETH_ADDRESS, tokenAddress, ETHER);\r\n\r\n            // Calculate potential profit\r\n            const [buyMarket, sellMarket] = price1.gt(price2) \r\n                ? [market2, market1] \r\n                : [market1, market2];\r\n            \r\n            const profit = price1.gt(price2) \r\n                ? price1.sub(price2) \r\n                : price2.sub(price1);\r\n\r\n            if (profit.gt(this.thresholds.minProfitThreshold)) {\r\n                // Calculate optimal trade volume\r\n                const volume = await this.calculateOptimalVolume(buyMarket, sellMarket, tokenAddress, profit);\r\n                \r\n                return {\r\n                    marketPairs: [{\r\n                        buyFromMarket: buyMarket,\r\n                        sellToMarket: sellMarket\r\n                    }],\r\n                    profit,\r\n                    volume,\r\n                    tokenAddress,\r\n                    buyFromMarket: buyMarket,\r\n                    sellToMarket: sellMarket\r\n                };\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error checking arbitrage opportunity:\", error);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    async takeCrossedMarkets(\r\n        markets: CrossedMarketDetails[], \r\n        currentBlock: number, \r\n        maxAttempts: number\r\n    ): Promise<void> {\r\n        for (const market of markets) {\r\n            for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n                try {\r\n                    const transaction = await this.executeArbitrageTrade(market, currentBlock);\r\n                    if (transaction) {\r\n                        elizaLogger.log(`Successful arbitrage execution: ${transaction.hash}`);\r\n                        // Wait for confirmation\r\n                        await transaction.wait(1);\r\n                        break;\r\n                    }\r\n                } catch (error) {\r\n                    console.error(`Attempt ${attempt} failed:`, error);\r\n                    if (attempt === maxAttempts) {\r\n                        console.error(\"Max attempts reached for market\", market);\r\n                    } else {\r\n                        await new Promise(r => setTimeout(r, this.RETRY_DELAY));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async executeArbitrageTrade(\r\n        market: CrossedMarketDetails,\r\n        blockNumber: number\r\n    ): Promise<TransactionResponse | null> {\r\n        // Prepare the trade calls\r\n        const buyCalls = await market.buyFromMarket.sellTokensToNextMarket(\r\n            WETH_ADDRESS,\r\n            market.volume,\r\n            market.sellToMarket\r\n        );\r\n\r\n        // Calculate intermediate amounts\r\n        const intermediateAmount = await market.buyFromMarket.getTokensOut(\r\n            WETH_ADDRESS,\r\n            market.tokenAddress,\r\n            market.volume\r\n        );\r\n\r\n        // Prepare sell call\r\n        const sellCallData = await market.sellToMarket.sellTokens(\r\n            market.tokenAddress,\r\n            intermediateAmount,\r\n            this.bundleExecutorContract.address\r\n        );\r\n\r\n        // Combine all calls\r\n        const targets = [...buyCalls.targets, market.sellToMarket.marketAddress];\r\n        const payloads = [...buyCalls.data, sellCallData];\r\n\r\n        // Calculate miner reward (90% of profit)\r\n        const minerReward = market.profit.mul(90).div(100);\r\n\r\n        // Create and simulate bundle\r\n        const bundle = await this.createBundle(\r\n            market.volume,\r\n            minerReward,\r\n            targets,\r\n            payloads,\r\n            blockNumber\r\n        );\r\n\r\n        // Execute if simulation successful\r\n        return this.executeBundleWithRetry(bundle, blockNumber);\r\n    }\r\n\r\n    private async createBundle(\r\n        volume: BigNumber,\r\n        minerReward: BigNumber,\r\n        targets: string[],\r\n        payloads: string[],\r\n        blockNumber: number\r\n    ): Promise<BundleEntry[]> {\r\n        // Estimate gas\r\n        const gasEstimate = await this.estimateGasWithBuffer(\r\n            volume,\r\n            minerReward,\r\n            targets,\r\n            payloads\r\n        );\r\n\r\n        // Get optimal gas price\r\n        const gasPrice = await this.getOptimalGasPrice(blockNumber);\r\n\r\n        // Create transaction\r\n        const transaction = await this.bundleExecutorContract.populateTransaction.uniswapWeth(\r\n            volume,\r\n            minerReward,\r\n            targets,\r\n            payloads,\r\n            { gasLimit: gasEstimate, gasPrice }\r\n        );\r\n\r\n        // Sign transaction\r\n        const signedTx = await this.wallet.signTransaction(transaction);\r\n        \r\n        // Create bundle entry\r\n        const bundleEntry = await this.createBundleEntry(signedTx);\r\n        \r\n        return [bundleEntry];\r\n    }\r\n\r\n    private async estimateGasWithBuffer(\r\n        volume: BigNumber,\r\n        minerReward: BigNumber,\r\n        targets: string[],\r\n        payloads: string[]\r\n    ): Promise<BigNumber> {\r\n        const estimate = await this.bundleExecutorContract.estimateGas.uniswapWeth(\r\n            volume,\r\n            minerReward,\r\n            targets,\r\n            payloads\r\n        );\r\n        return estimate.mul(120).div(100); // Add 20% buffer\r\n    }\r\n\r\n    private async getOptimalGasPrice(blockNumber: number): Promise<BigNumber> {\r\n        const { currentGasPrice, avgGasPrice } = await getGasPriceInfo(this.wallet.provider as Provider);\r\n        const basePrice = currentGasPrice.gt(avgGasPrice) ? currentGasPrice : avgGasPrice;\r\n        return basePrice.mul(110).div(100); // Add 10% to be competitive\r\n    }\r\n\r\n    private async executeBundleWithRetry(\r\n        bundle: BundleEntry[], \r\n        blockNumber: number\r\n    ): Promise<TransactionResponse | null> {\r\n        for (let i = 0; i < this.MAX_RETRIES; i++) {\r\n            try {\r\n                // Simulate first\r\n                await this.simulateBundle(bundle, blockNumber);\r\n                \r\n                // If simulation successful, submit\r\n                const response = await this.flashbotsProvider.sendBundle(\r\n                    bundle.map(entry => ({\r\n                        signedTransaction: entry.signedTransaction,\r\n                        signer: this.wallet,\r\n                        transaction: {\r\n                            to: entry.to,\r\n                            gasLimit: entry.gas,\r\n                            gasPrice: entry.gas_price,\r\n                            value: entry.value,\r\n                            data: entry.input\r\n                        }\r\n                    })),\r\n                    blockNumber + 1\r\n                );\r\n\r\n                if ('error' in response) {\r\n                    throw new Error(response.error.message);\r\n                }\r\n\r\n                return response as unknown as TransactionResponse;\r\n            } catch (error) {\r\n                console.error(`Bundle execution attempt ${i + 1} failed:`, error);\r\n                if (i === this.MAX_RETRIES - 1) throw error;\r\n                await new Promise(r => setTimeout(r, this.RETRY_DELAY));\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private async createBundleEntry(signedTx: string): Promise<BundleEntry> {\r\n        const tx = await this.wallet.provider.getTransaction(signedTx);\r\n        if (!tx?.to || !tx?.gasPrice || !tx?.value) {\r\n            throw new Error(\"Invalid transaction\");\r\n        }\r\n\r\n        return {\r\n            to: tx.to,\r\n            gas: tx.gasLimit.toNumber(),\r\n            gas_price: tx.gasPrice.toString(),\r\n            value: tx.value.toNumber(),\r\n            input: tx.data,\r\n            from: this.wallet.address,\r\n            signedTransaction: signedTx,\r\n            signer: this.wallet.address\r\n        };\r\n    }\r\n\r\n    private async simulateBundle(bundle: BundleEntry[], blockNumber: number): Promise<void> {\r\n        const stringBundle = bundle.map(entry => entry.signedTransaction);\r\n        const simulation = await this.flashbotsProvider.simulate(stringBundle, blockNumber);\r\n\r\n        if ('error' in simulation) {\r\n            throw new Error(`Simulation failed: ${simulation.error.message}`);\r\n        }\r\n\r\n        // Verify profitability\r\n        const { bundleGasPrice, coinbaseDiff, totalGasUsed } = simulation;\r\n        const cost = bundleGasPrice.mul(totalGasUsed);\r\n        const profit = coinbaseDiff.sub(cost);\r\n\r\n        if (profit.lte(this.thresholds.minProfitThreshold)) {\r\n            throw new Error(\"Bundle not profitable enough\");\r\n        }\r\n    }\r\n\r\n    async submitBundleWithAdjustedGasPrice(bundle: BundleEntry[], blockNumber: number, blocksApi: any): Promise<void> {\r\n        elizaLogger.log(`Submitting bundle with adjusted gas price for block ${blockNumber}`);\r\n        \r\n        try {\r\n            // Get current gas prices\r\n            const { currentGasPrice, avgGasPrice } = await getGasPriceInfo(this.wallet.provider as Provider);\r\n            \r\n            // Monitor competing bundles\r\n            const competingBundlesGasPrices = await monitorCompetingBundlesGasPrices(blocksApi);\r\n            let competingBundleGasPrice = BigNumber.from(0);\r\n            \r\n            // Find highest competing gas price\r\n            for (const price of competingBundlesGasPrices) {\r\n                const currentPrice = BigNumber.from(price);\r\n                if (currentPrice.gt(competingBundleGasPrice)) {\r\n                    competingBundleGasPrice = currentPrice;\r\n                }\r\n            }\r\n\r\n            // Calculate adjusted gas price\r\n            const adjustedGasPrice = await this.adjustGasPriceForTransaction(\r\n                currentGasPrice,\r\n                avgGasPrice,\r\n                competingBundleGasPrice\r\n            );\r\n\r\n            // Validate adjusted gas price\r\n            if (adjustedGasPrice.lte(currentGasPrice)) {\r\n                throw new Error(\"Adjusted gas price is not competitive\");\r\n            }\r\n\r\n            // Validate bundle gas\r\n            const isValidBundleGas = await checkBundleGas(adjustedGasPrice);\r\n            if (!isValidBundleGas) {\r\n                throw new Error(\"Invalid bundle gas\");\r\n            }\r\n\r\n            // Set submission window\r\n            const currentTimestamp = Math.floor(Date.now() / 1000);\r\n            const maxTimestamp = currentTimestamp + 60; // 1 minute window\r\n\r\n            // Submit bundle\r\n            const targetBlockNumber = blockNumber + 1;\r\n            const bundleSubmission = await this.flashbotsProvider.sendBundle(\r\n                bundle.map(entry => ({\r\n                    signedTransaction: entry.signedTransaction,\r\n                    signer: this.wallet,\r\n                    transaction: {\r\n                        to: entry.to,\r\n                        gasLimit: entry.gas,\r\n                        gasPrice: entry.gas_price,\r\n                        value: entry.value,\r\n                        data: entry.input\r\n                    }\r\n                })),\r\n                targetBlockNumber,\r\n                {\r\n                    minTimestamp: currentTimestamp,\r\n                    maxTimestamp: maxTimestamp\r\n                }\r\n            );\r\n\r\n            // Check submission result\r\n            if ('error' in bundleSubmission) {\r\n                throw new Error(`Bundle submission failed: ${bundleSubmission.error.message}`);\r\n            }\r\n\r\n            elizaLogger.log(\"Bundle submitted successfully:\", {\r\n                blockNumber: targetBlockNumber,\r\n                adjustedGasPrice: adjustedGasPrice.toString(),\r\n                bundleHash: bundleSubmission.bundleHash\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error(\"Failed to submit bundle with adjusted gas price:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async adjustGasPriceForTransaction(\r\n        currentGasPrice: BigNumber,\r\n        avgGasPrice: BigNumber,\r\n        competingBundleGasPrice: BigNumber\r\n    ): Promise<BigNumber> {\r\n        elizaLogger.log(\"Calculating adjusted gas price\", {\r\n            current: currentGasPrice.toString(),\r\n            average: avgGasPrice.toString(),\r\n            competing: competingBundleGasPrice.toString()\r\n        });\r\n\r\n        // Find highest gas price\r\n        let adjustedGasPrice = currentGasPrice;\r\n        if (avgGasPrice.gt(adjustedGasPrice)) {\r\n            adjustedGasPrice = avgGasPrice;\r\n        }\r\n        if (competingBundleGasPrice.gt(adjustedGasPrice)) {\r\n            adjustedGasPrice = competingBundleGasPrice;\r\n        }\r\n\r\n        // Add premium to ensure priority (10% increase)\r\n        const premium = adjustedGasPrice.mul(10).div(100);\r\n        adjustedGasPrice = adjustedGasPrice.add(premium);\r\n\r\n        elizaLogger.log(\"Adjusted gas price:\", adjustedGasPrice.toString());\r\n        return adjustedGasPrice;\r\n    }\r\n\r\n    private async calculateOptimalVolume(\r\n        buyFromMarket: MarketType,\r\n        sellToMarket: MarketType,\r\n        tokenAddress: string,\r\n        profit: BigNumber\r\n    ): Promise<BigNumber> {\r\n        elizaLogger.log(\"Entering calculateOptimalVolume\");\r\n\r\n        // Determine the available liquidity in both markets\r\n        const availableLiquidityBuy = await buyFromMarket.getReserves(tokenAddress);\r\n        const availableLiquiditySell = await sellToMarket.getReserves(tokenAddress);\r\n\r\n        // Set a maximum trade size limit to manage risk\r\n        const maxTradeSize = BigNumber.from(100000); // Adjust as needed\r\n\r\n        // Calculate price impacts and trading fees\r\n        const priceImpactBuy = await buyFromMarket.getPriceImpact(tokenAddress, maxTradeSize);\r\n        const priceImpactSell = await sellToMarket.getPriceImpact(tokenAddress, maxTradeSize);\r\n\r\n        const tradingFeeBuy = await buyFromMarket.getTradingFee(tokenAddress);\r\n        const tradingFeeSell = await sellToMarket.getTradingFee(tokenAddress);\r\n\r\n        // Binary Search Initialization\r\n        let left = BigNumber.from(1);\r\n        let right = maxTradeSize;\r\n        let optimalVolume = BigNumber.from(0);\r\n        let maxExpectedProfit = BigNumber.from(0);\r\n\r\n        while (left.lt(right)) {\r\n            const mid = left.add(right).div(2);\r\n\r\n            // Calculate expected profit at mid\r\n            const expectedProfit = profit\r\n                .mul(mid)\r\n                .sub(priceImpactBuy.mul(mid))\r\n                .sub(priceImpactSell.mul(mid))\r\n                .sub(tradingFeeBuy.mul(mid))\r\n                .sub(tradingFeeSell.mul(mid));\r\n\r\n            if (expectedProfit.gt(maxExpectedProfit) && expectedProfit.gte(this.thresholds.minProfitThreshold)) {\r\n                maxExpectedProfit = expectedProfit;\r\n                optimalVolume = mid;\r\n                left = mid.add(1);\r\n            } else {\r\n                right = mid.sub(1);\r\n            }\r\n        }\r\n\r\n        // Ensure that the optimal volume does not exceed available liquidity\r\n        optimalVolume = BigNumber.from(Math.min(\r\n            optimalVolume.toNumber(),\r\n            availableLiquidityBuy.toNumber(),\r\n            availableLiquiditySell.toNumber()\r\n        ));\r\n\r\n        elizaLogger.log(`calculateOptimalVolume: optimalVolume = ${optimalVolume}`);\r\n        return optimalVolume;\r\n    }\r\n}\r\n\r\n// Helper functions\r\nasync function checkBundleGas(bundleGas: BigNumber): Promise<boolean> {\r\n    const isValid = bundleGas.gte(42000);\r\n    elizaLogger.log(`checkBundleGas: bundleGas = ${bundleGas}, isValid = ${isValid}`);\r\n    return isValid;\r\n}\r\n\r\nexport async function monitorCompetingBundlesGasPrices(blocksApi: { getRecentBlocks: () => any; }): Promise<Array<BigNumber>> {\r\n    elizaLogger.log(\"Entering monitorCompetingBundlesGasPrices\");\r\n    const recentBlocks = await blocksApi.getRecentBlocks();\r\n    const competingBundlesGasPrices = recentBlocks.map((block: { bundleGasPrice: any; }) => block.bundleGasPrice);\r\n    elizaLogger.log(`monitorCompetingBundlesGasPrices: competingBundlesGasPrices = ${competingBundlesGasPrices}`);\r\n    return competingBundlesGasPrices;\r\n}\r\n\r\nexport async function getGasPriceInfo(provider: Provider): Promise<{ \r\n    currentGasPrice: BigNumber, \r\n    avgGasPrice: BigNumber \r\n}> {\r\n    const feeData = await provider.getFeeData();\r\n    const currentGasPrice = feeData.gasPrice || BigNumber.from(0);\r\n    \r\n    // Get average from last few blocks\r\n    const block = await provider.getBlock(\"latest\");\r\n    const prices: BigNumber[] = [];\r\n    for (let i = 0; i < 5; i++) {\r\n        const historicalBlock = await provider.getBlock(block.number - i);\r\n        if (historicalBlock.baseFeePerGas) {\r\n            prices.push(historicalBlock.baseFeePerGas);\r\n        }\r\n    }\r\n    \r\n    const avgGasPrice = prices.length > 0 \r\n        ? prices.reduce((a, b) => a.add(b)).div(prices.length)\r\n        : currentGasPrice;\r\n\r\n    return { currentGasPrice, avgGasPrice };\r\n}\r\n\r\nexport async function calculateOptimalVolume(\r\n    buyFromMarket: MarketType,\r\n    sellToMarket: MarketType,\r\n    tokenAddress: string,\r\n    profit: BigNumber\r\n): Promise<BigNumber> {\r\n    const buyLiquidity = await buyFromMarket.getReserves(tokenAddress);\r\n    const sellLiquidity = await sellToMarket.getReserves(tokenAddress);\r\n    \r\n    // Start with 1% of the smaller liquidity pool\r\n    let optimalVolume = buyLiquidity.lt(sellLiquidity) \r\n        ? buyLiquidity.div(100)\r\n        : sellLiquidity.div(100);\r\n\r\n    // Adjust based on price impact\r\n    const buyImpact = await buyFromMarket.getPriceImpact(tokenAddress, optimalVolume);\r\n    const sellImpact = await sellToMarket.getPriceImpact(tokenAddress, optimalVolume);\r\n    \r\n    // If price impact is too high, reduce volume\r\n    if (buyImpact.add(sellImpact).gt(BigNumber.from(300))) { // 3% total impact\r\n        optimalVolume = optimalVolume.mul(80).div(100); // Reduce by 20%\r\n    }\r\n\r\n    return optimalVolume;\r\n}","import { Service, ServiceType, IAgentRuntime } from \"@elizaos/core\";\r\nimport { Arbitrage } from \"../core/Arbitrage\";\r\nimport { WebSocket } from 'ws';\r\nimport { CrossedMarketDetails, MarketsByToken } from \"../type\";\r\nimport { WebSocketProvider } from \"@ethersproject/providers\";\r\nimport { Wallet } from \"@ethersproject/wallet\";\r\nimport { FlashbotsBundleProvider } from \"@flashbots/ethers-provider-bundle\";\r\nimport { Contract } from \"@ethersproject/contracts\";\r\n\r\n// Declare the ARBITRAGE service type\r\ndeclare module \"@elizaos/core\" {\r\n    interface ServiceTypeMap {\r\n        arbitrage: Service & ArbitrageService;\r\n    }\r\n\r\n    export enum ServiceType {\r\n        ARBITRAGE = \"arbitrage\"\r\n    }\r\n}\r\n\r\nexport class ArbitrageService extends Service {\r\n    private arbitrage: Arbitrage | null = null;\r\n    private wsConnection: WebSocket | null = null;\r\n    private marketsByToken = {};\r\n    private currentBlock = 0;\r\n    private runtime!: IAgentRuntime;\r\n\r\n    static get serviceType(): ServiceType {\r\n        return ServiceType.ARBITRAGE;\r\n    }\r\n\r\n    get serviceType(): ServiceType {\r\n        return ServiceType.ARBITRAGE;\r\n    }\r\n\r\n    // Remove unnecessary constructor\r\n    // constructor() {\r\n    //     super();\r\n    // }\r\n\r\n    async initialize(runtime: IAgentRuntime): Promise<void> {\r\n        this.runtime = runtime;\r\n\r\n        // Get WebSocket URL with multiple fallback options\r\n        let wsUrl = runtime.getSetting(\"ARBITRAGE_ETHEREUM_WS_URL\")\r\n\r\n        let rpcUrl = runtime.getSetting(\"ARBITRAGE_EVM_PROVIDER_URL\") \r\n                    \r\n\r\n        // Debug logging\r\n        console.log('ArbitrageService initialize - URLs:', {\r\n            wsUrl,\r\n            rpcUrl\r\n        });\r\n\r\n        if (!wsUrl && !rpcUrl) {\r\n            throw new Error(\"Missing both ARBITRAGE_ETHEREUM_WS_URL and ARBITRAGE_EVM_PROVIDER_URL envs\");\r\n        }\r\n\r\n        // If we only have RPC URL, derive WS URL\r\n        if (!wsUrl && rpcUrl) {\r\n            wsUrl = rpcUrl.replace('https://', 'wss://');\r\n            console.log('Using derived WebSocket URL:', wsUrl);\r\n        }\r\n\r\n        if (!wsUrl) {\r\n            throw new Error(\"No WebSocket URL available after all fallbacks\");\r\n        }\r\n\r\n        // Initialize wallet and providers\r\n        const walletKey = runtime.getSetting(\"ARBITRAGE_EVM_PRIVATE_KEY\") \r\n        if (!walletKey) throw new Error(\"Missing ARBITRAGE_EVM_PRIVATE_KEY env\");\r\n\r\n        // Initialize provider\r\n        console.log('Initializing WebSocketProvider with URL:', wsUrl);\r\n        const provider = new WebSocketProvider(wsUrl as string);\r\n        const wallet = new Wallet(walletKey, provider);\r\n\r\n        // Initialize Flashbots provider\r\n        const flashbotsKey = runtime.getSetting(\"FLASHBOTS_RELAY_SIGNING_KEY\") \r\n        if (!flashbotsKey) throw new Error(\"Missing FLASHBOTS_RELAY_SIGNING_KEY env\");\r\n\r\n        const flashbotsProvider = await FlashbotsBundleProvider.create(\r\n            provider,\r\n            wallet,\r\n            flashbotsKey\r\n        );\r\n\r\n        // Initialize bundle executor contract\r\n        const bundleExecutorAddress = runtime.getSetting(\"BUNDLE_EXECUTOR_ADDRESS\");\r\n        if (!bundleExecutorAddress) throw new Error(\"Missing BUNDLE_EXECUTOR_ADDRESS env\");\r\n\r\n        // Create Contract instance\r\n        const bundleExecutorContract = new Contract(\r\n            bundleExecutorAddress,\r\n            [\r\n                'function execute(bytes[] calldata calls) external payable',\r\n                'function executeWithToken(bytes[] calldata calls, address tokenAddress, uint256 tokenAmount) external payable'\r\n            ],\r\n            wallet\r\n        );\r\n\r\n        // Initialize Arbitrage instance with Contract instance\r\n        this.arbitrage = new Arbitrage(\r\n            wallet,\r\n            flashbotsProvider,\r\n            bundleExecutorContract\r\n        );\r\n\r\n        // Setup WebSocket connection\r\n        console.log('Setting up WebSocket connection to:', wsUrl);\r\n        this.wsConnection = new WebSocket(wsUrl);\r\n        this.setupWebSocketHandlers();\r\n    }\r\n\r\n    private setupWebSocketHandlers(): void {\r\n        if (!this.wsConnection) return;\r\n\r\n        this.wsConnection.on('open', () => {\r\n            console.log('WebSocket connection established');\r\n            // Subscribe to new blocks\r\n            this.wsConnection?.send(JSON.stringify({\r\n                jsonrpc: '2.0',\r\n                id: 1,\r\n                method: 'eth_subscribe',\r\n                params: ['newHeads']\r\n            }));\r\n        });\r\n\r\n        this.wsConnection.on('message', async (data: string) => {\r\n            const message = JSON.parse(data);\r\n            if (message.params?.result?.number) {\r\n                this.currentBlock = Number.parseInt(message.params.result.number, 16);\r\n            }\r\n        });\r\n\r\n        this.wsConnection.on('error', (error) => {\r\n            console.error('WebSocket error:', error);\r\n        });\r\n\r\n        this.wsConnection.on('close', () => {\r\n            console.log('WebSocket connection closed');\r\n            // Attempt to reconnect after a delay\r\n            setTimeout(() => this.initialize(this.runtime), 5000);\r\n        });\r\n    }\r\n\r\n    async evaluateMarkets(): Promise<CrossedMarketDetails[]> {\r\n        if (!this.arbitrage) throw new Error(\"ArbitrageService not initialized\");\r\n        return this.arbitrage.evaluateMarkets(this.marketsByToken);\r\n    }\r\n\r\n    async executeArbitrage(markets: CrossedMarketDetails[]): Promise<void> {\r\n        if (!this.arbitrage) throw new Error(\"ArbitrageService not initialized\");\r\n        const maxAttempts = 10;\r\n        return this.arbitrage.takeCrossedMarkets(markets, this.currentBlock, maxAttempts);\r\n    }\r\n\r\n    async stop(): Promise<void> {\r\n        if (this.wsConnection) {\r\n            this.wsConnection.close();\r\n            this.wsConnection = null;\r\n        }\r\n    }\r\n}","import { Plugin, Action, Provider, IAgentRuntime } from \"@elizaos/core\";\r\nimport { executeArbitrageAction } from \"./actions/arbitrageAction\";\r\nimport { marketProvider } from \"./providers/marketProvider\";\r\nimport { ArbitrageService } from \"./services/ArbitrageService\";\r\n// Create a single instance of the service\r\n\r\nconst arbitrageService = new ArbitrageService();\r\n\r\nconst arbitragePlugin: Plugin = {\r\n    name: \"arbitrage-plugin\",\r\n    description: \"Automated arbitrage trading plugin\",\r\n    actions: [executeArbitrageAction],\r\n    providers: [marketProvider],\r\n    services: [arbitrageService]\r\n};\r\n\r\nexport default arbitragePlugin;"]}